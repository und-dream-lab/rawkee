//
// Copyright (C) 2004-2005 North Dakota State University (http://atl.ndsu.edu/resources/maya_x3d.php) 
// 
//This library is free software; you can redistribute it and/or 
//modify it under the terms of the GNU Lesser General Public License 
//as published by the Free Software Foundation; either version 2.1 of 
//the License, or (at your option) any later version.

//This library is distributed in the hope that it will be useful, but 
//WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
//or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
//License for more details.

//You should have received a copy of the GNU Lesser General Public License 
//along with this library; if not, write to the Free Software Foundation, Inc., 
//59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

// File: x3d_node_creation_procs.mel
//
//
// Authors:	Aaron Bergstrom
//         	Computer Visualization Manger
//         	NDSU Archaeology Technologies Laboratory
//         	http://atl.ndsu.edu/
//

//---------------------------------------------------------
// Procedure for creating an x3dViewpoint Node
//---------------------------------------------------------
global proc createX3DViewpoints()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $camString = `createNode camera`;
		string $newTrans[] = `listRelatives -p $camString`;
		parent $newTrans[0] $selTrans[0];
		select $selTrans[0];
	}
	else
	{
		string $camString = `createNode camera`;
		string $newTrans[] = `listRelatives -p $camString`;
		select $newTrans[0];
	}

}


//
//---------------------------------------------------------


//---------------------------------------------------------
// Procedure for creating an maya Directional Light Node
//---------------------------------------------------------
global proc createX3DDirectionalLights()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newDirLight = `createNode -n "dLightShape#" directionalLight`;//-p $newTrans`;
		string $newTrans[] = `listRelatives -p $newDirLight`;
		parent $newTrans[0] $selTrans[0];
		select $selTrans[0];
	}
	else
	{
		string $newDirLight = `createNode -n "dLightShape#" directionalLight`;//-p $newTrans`;
		string $newTrans[] = `listRelatives -p $newDirLight`;
		select $newTrans[0];
	}

}

//---------------------------------------------------------
// Procedure for creating an maya Spot Light Node
//---------------------------------------------------------
global proc createX3DSpotLights()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newSpotLight = `createNode -n "sLightShape#" spotLight`;
		string $newTrans[] = `listRelatives -p $newSpotLight`;
		parent $newTrans[0] $selTrans[0];
		select $selTrans[0];
	}
	else
	{
		string $newSpotLight = `createNode -n "sLightShape#" spotLight`;
		string $newTrans[] = `listRelatives -p $newSpotLight`;
		select $newTrans[0];
	}


}


//---------------------------------------------------------
// Procedure for creating an maya Point Light Node
//---------------------------------------------------------
global proc createX3DPointLights()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newPointLight = `createNode -n "pLightShape#" pointLight`;
		string $newTrans[] = `listRelatives -p $newPointLight`;
		parent $newTrans[0] $selTrans[0];
		select $selTrans[0];
	}
	else
	{
		string $newPointLight = `createNode -n "pLightShape#" pointLight`;
		string $newTrans[] = `listRelatives -p $newPointLight`;
		select $newTrans[0];
	}
}

//---------------------------------------------------------
// Procedure for creating an x3dNavigation Node
//---------------------------------------------------------
global proc createX3DNavigationInfos()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newTrans = `createNode "transform" -p $selTrans[0]`;
		string $newNavNode = `createNode  -n "navInfo#" "x3dNavigationInfo" -p $newTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode "transform"`;
		string $newNavNode = `createNode -n "navInfo#" "x3dNavigationInfo" -p $newTrans`;
	
		select $newTrans;
	}

}

//---------------------------------------------------------
// Procedure for creating an x3dWorldInfo Node
//---------------------------------------------------------
global proc createX3DWorldInfos()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newTrans = `createNode "transform" -p $selTrans[0]`;
		string $newWorldNode = `createNode  -n "worldInfo#" "x3dWorldInfo" -p $newTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode "transform"`;
		string $newWorldNode = `createNode -n "worldInfo#" "x3dWorldInfo" -p $newTrans`;
	
		select $newTrans;
	}
}


//---------------------------------------------------------
// Procedure for creating an empty transform node
//---------------------------------------------------------
global proc createX3DTransforms()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newTrans = `createNode transform -p $selTrans[0]`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		select $newTrans;
	}
}

//---------------------------------------------------------
// Procedure for creating an empty transform node that gets exported as a Group Node
//---------------------------------------------------------
global proc createX3DGroups()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newGroup = `createNode x3dGroup -p $selTrans[0]`;
		select $selTrans[0];
	}
	else
	{
		string $newGroup = `createNode x3dGroup`;
		select $newGroup;
	}
}

//---------------------------------------------------------
//Procedure for creating a Maya "lodGroup" node setup for
//export as an X3D LOD node. Unlike most other x3d node 
//creation procedures, maya nodes selected before this 
//procedure is called are become children of the created 
//lodGroup node.
//---------------------------------------------------------
global proc createX3DlodGroup()
{
	LevelOfDetailGroup;
	string $nodeSel[] = `ls -sl`;
	if($nodeSel[0] == "") print("You must first select the node(s) that you would like added to the LOD before the a new LOD can be created.\n");
}

//---------------------------------------------------------
// Procedure for creating an empty transform node that gets exported as a Switch Node
//---------------------------------------------------------
global proc createX3DSwitches()
{
	string $selTrans[] = getSelectedGroupingNodes();

	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newSwitch = `createNode x3dSwitch -p $selTrans[0]`;
		select $selTrans[0];
	}
	else
	{
		string $newSwitch = `createNode -n "switch#" "x3dSwitch"`;
		select $newSwitch;
	}
}

//---------------------------------------------------------
//Procedure for creating an x3dBillboard node
//---------------------------------------------------------
global proc createX3DBillboards()
{
	string $selTrans[] = getSelectedGroupingNodes();

	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newBillboard = `createNode x3dBillboard -p $selTrans[0]`;
		select $selTrans[0];
	}
	else
	{
		string $newBillboard = `createNode -n "billboard#" "x3dBillboard"`;
		select $newBillboard;
	}
}

//---------------------------------------------------------
//Procedure for creating an x3dProximitySensor
//---------------------------------------------------------
global proc createX3DProximitySensors()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $pSensor = `createNode x3dProximitySensor -p $selTrans[0]`;
		select $selTrans[0];
	}
	else
	{
		string $pSensor = `createNode x3dProximitySensor`;
		string $newTrans[] = `listRelatives -p $pSensor`;
		select $newTrans[0];
	}
}

global proc createX3DVisibilitySensors()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $pSensor = `createNode x3dVisibilitySensor -p $selTrans[0]`;
		select $selTrans[0];
	}
	else
	{
		string $pSensor = `createNode x3dVisibilitySensor`;
		string $newTrans[] = `listRelatives -p $pSensor`;
		select $newTrans[0];
	}
}

global proc createX3DGamepadSensors()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $pSensor = `createNode x3dGamepadSensor -p $selTrans[0]`;
		select $selTrans[0];
	}
	else
	{
		string $pSensor = `createNode x3dGamepadSensor`;
		string $newTrans[] = `listRelatives -p $pSensor`;
		select $newTrans[0];
	}
}

//---------------------------------------------------------
// Procedure for creating an empty transform node that gets exported as a Collision Node
//---------------------------------------------------------
global proc createX3DCollisions()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newCollide = `createNode x3dCollision -p $selTrans[0]`;
		select $selTrans[0];
	}
	else
	{
		string $newCollide = `createNode x3dCollision`;
		select $newCollide;
	}
}

global proc createX3DInlines()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newInline = `createNode x3dInline -p $selTrans[0]`;
		select $selTrans[0];
	}
	else
	{
		string $newInline = `createNode x3dInline`;
		select $newInline;
	}
}

global proc createX3DAnchors()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newAnchor = `createNode x3dAnchor -p $selTrans[0]`;
		select $selTrans[0];
	}
	else
	{
		string $newAnchor = `createNode x3dAnchor`;
		select $newAnchor;
	}
}

//---------------------------------------------------------
// Procedures for creating Metadata nodes
//
//---------------------------------------------------------

global proc createX3DMetadataDoubles()
{
	createNode x3dMetadataDouble;
}

global proc createX3DMetadataFloats()
{
	createNode x3dMetadataFloat;
}

global proc createX3DMetadataIntegers()
{
	createNode x3dMetadataInteger;
}

global proc createX3DMetadataSets()
{
	createNode x3dMetadataSet;
}

global proc createX3DMetadataStrings()
{
	createNode x3dMetadataString;
}

//---------------------------------------------------------
// Procedures to create underworld nodes that represent
// x3d nodes.
//---------------------------------------------------------
global proc addX3DCoordinate(string $x3dParent)
{
	string $underworld = `createNode x3dCoordinate -n "coordinate#" -p $x3dParent`;
	x3dTotalTransformDisable($underworld);
}

global proc addX3DTextureCoordinate(string $x3dParent)
{
	string $underworld = `createNode x3dTextureCoordinate -n "textureCoordinate#" -p $x3dParent`;
	x3dTotalTransformDisable($underworld);
}

global proc addX3DColor(string $x3dParent)
{
	string $underworld = `createNode x3dColor -n "color#" -p $x3dParent`;
	x3dTotalTransformDisable($underworld);
}

global proc addX3DColorRGBA(string $x3dParent)
{
	string $underworld = `createNode x3dColorRGBA -n "colorRGBA#" -p $x3dParent`;
	x3dTotalTransformDisable($underworld);
}

global proc addX3DNormal(string $x3dParent)
{
	string $underworld = `createNode x3dNormal -n "normal#" -p $x3dParent`;
	x3dTotalTransformDisable($underworld);
}

global proc addX3DIndexedFaceSet(string $aMesh)
{
	string $underworld = `createNode x3dIndexedFaceSet -n "ifs#" -p $aMesh`;
	x3dTotalTransformDisable($underworld);
}

global proc addX3DCone(string $aMesh, int $setIt)
{
	string $underworld = `createNode -n "x3dCone#" "x3dCone" -p $aMesh`;
	x3dTotalTransformDisable($underworld);
}

global proc addX3DCylinder(string $aMesh, int $setIt)
{
	string $underworld = `createNode -n "x3dCylinder#" "x3dCylinder" -p $aMesh`;
	x3dTotalTransformDisable($underworld);
}

global proc addX3DBox(string $aMesh, int $setIt)
{
	string $underworld = `createNode -n "x3dBox#" "x3dBox" -p $aMesh`;
	x3dTotalTransformDisable($underworld);
}

global proc addX3DSphere(string $aMesh, int $setIt)
{
	string $underworld = `createNode -n "x3dSphere#" "x3dSphere" -p $aMesh`;
	x3dTotalTransformDisable($underworld);
}

//---------------------------------------------------------


//---------------------------------------------------------
// Procedure for creating an Polygon IndexedFaceSet Node
//---------------------------------------------------------
global proc createX3DIndexedFaceSets()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newTrans = `createNode "transform" -p $selTrans[0]`;
		string $tempMesh = `createNode "mesh" -p $newTrans`;
		hyperShade -assign initialShadingGroup $tempMesh;
		string $tempBox = `createNode "polyCube" -n "temporary"`;
		string $tempMesh1 = $tempMesh + ".inMesh";
		string $tempBox1 = $tempBox + ".output";
		connectAttr $tempBox1 $tempMesh1;
				
		string $newTransName = ("iFaceSet#");
		string $fTransName = `rename $newTrans $newTransName`;
			
		string $newMeshName = ("iFaceSetShape#");
		string $fMeshName = `rename $tempMesh $newMeshName`;
		addX3DIndexedFaceSet($fMeshName);
		delete -ch $fMeshName;
		
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode "transform"`;
		string $tempMesh = `createNode "mesh" -p $newTrans`;
		hyperShade -assign initialShadingGroup $tempMesh;
		string $tempBox = `createNode "polyCube" -n "temporary"`;
		string $tempMesh1 = $tempMesh + ".inMesh";
		string $tempBox1 = $tempBox + ".output";
		connectAttr $tempBox1 $tempMesh1;
		
		string $newTransName = ("iFaceSet#");
		string $fTransName = `rename $newTrans $newTransName`;
				
		string $newMeshName = ("iFaceSetShape#");
		string $fMeshName = `rename $tempMesh $newMeshName`;
		addX3DIndexedFaceSet($fMeshName);
		delete -ch $fMeshName;
		select $fTransName;
	}

}

//---------------------------------------------------------
// Procedure for creating an Polygon Cone Primitive Node
//---------------------------------------------------------
global proc createX3DCones()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newTrans = `createNode "transform" -p $selTrans[0]`;
		string $tempMesh = `createNode "mesh" -p $newTrans`;
		hyperShade -assign initialShadingGroup $tempMesh;
		string $tempCone = `createNode "polyCone"`;
		string $tempMesh1 = $tempMesh + ".inMesh";
		string $tempCone1 = $tempCone + ".output";
		connectAttr $tempCone1 $tempMesh1;
				
		string $newMeshName = "pConeShape#";
		string $fMeshName = `rename $tempMesh $newMeshName`;
		
		string $newTransName = "pCone#";
		string $fTransName = `rename $newTrans $newTransName`;
		string $underworld = `createNode x3dCone -p $fMeshName`;
		connectAttr ($underworld+".bottomRadius") ($tempCone+".radius");
		connectAttr ($underworld+".height") ($tempCone+".height");
		x3dTotalTransformDisable($underworld);

		select $selTrans[0];
	}
	else
	{
		
		string $newTrans = `createNode "transform"`;
		string $tempMesh = `createNode "mesh" -p $newTrans`;
		hyperShade -assign initialShadingGroup $tempMesh;
		string $tempCone = `createNode "polyCone"`;
		string $tempMesh1 = $tempMesh + ".inMesh";
		string $tempCone1 = $tempCone + ".output";
		connectAttr $tempCone1 $tempMesh1;
		
		string $newMeshName = "pConeShape#";
		string $fMeshName = `rename $tempMesh $newMeshName`;
		
		string $newTransName = "pCone#";
		string $fTransName = `rename $newTrans $newTransName`;
		string $underworld = `createNode x3dCone -p $fMeshName`;
		connectAttr ($underworld+".bottomRadius") ($tempCone+".radius");
		connectAttr ($underworld+".height") ($tempCone+".height");
		x3dTotalTransformDisable($underworld);
		select $fTransName;
	}

}

//---------------------------------------------------------
// Procedure for creating an Polygon Cylinder Primitive Node
//---------------------------------------------------------
global proc createX3DCylinders()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newTrans = `createNode "transform" -p $selTrans[0]`;
		string $tempMesh = `createNode "mesh" -p $newTrans`;
		hyperShade -assign initialShadingGroup $tempMesh;
		string $tempCylinder = `createNode "polyCylinder"`;
		setAttr ($tempCylinder+".subdivisionsCaps") 1;
		string $tempMesh1 = $tempMesh + ".inMesh";
		string $tempCylinder1 = $tempCylinder + ".output";
		connectAttr $tempCylinder1 $tempMesh1;

		string $newMeshName = "pCylinderShape#";
		string $fMeshName = `rename $tempMesh $newMeshName`;
	
		string $newTransName = "pCylinder#";
		string $fTransName = `rename $newTrans $newTransName`;
		string $underworld = `createNode x3dCylinder -p $fMeshName`;
		connectAttr ($underworld+".radius") ($tempCylinder+".radius");
		connectAttr ($underworld+".height") ($tempCylinder+".height");
		x3dTotalTransformDisable($underworld);
		select $selTrans[0];
	}
	else
	{
		
		string $newTrans = `createNode "transform"`;
		string $tempMesh = `createNode "mesh" -p $newTrans`;
		hyperShade -assign initialShadingGroup $tempMesh;
		string $tempCylinder = `createNode "polyCylinder"`;
		setAttr ($tempCylinder+".subdivisionsCaps") 1;
		string $tempMesh1 = $tempMesh + ".inMesh";
		string $tempCylinder1 = $tempCylinder + ".output";
		connectAttr $tempCylinder1 $tempMesh1;
		
		string $newMeshName = "pCylinderShape#";
		string $fMeshName = `rename $tempMesh $newMeshName`;
		
		string $newTransName = "pCylinder#";
		string $fTransName = `rename $newTrans $newTransName`;
		string $underworld = `createNode x3dCylinder -p $fMeshName`;
		connectAttr ($underworld+".radius") ($tempCylinder+".radius");
		connectAttr ($underworld+".height") ($tempCylinder+".height");
		x3dTotalTransformDisable($underworld);
		select $fTransName;
	}

}

//---------------------------------------------------------
// Procedure for creating an Polygon Sphere Primitive Node
//---------------------------------------------------------
global proc createX3DSpheres()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newTrans = `createNode "transform" -p $selTrans[0]`;
		string $tempMesh = `createNode "mesh" -p $newTrans`;
		hyperShade -assign initialShadingGroup $tempMesh;
		string $tempSphere = `createNode "polySphere"`;
		string $tempMesh1 = $tempMesh + ".inMesh";
		string $tempSphere1 = $tempSphere + ".output";
		connectAttr $tempSphere1 $tempMesh1;
		
		string $newMeshName = "pSphereShape#";
		string $fMeshName = `rename $tempMesh $newMeshName`;
		
		string $newTransName = "pSphere#";
		string $fTransName = `rename $newTrans $newTransName`;
		string $underworld = `createNode x3dSphere -p $fMeshName`;
		connectAttr ($underworld+".radius") ($tempSphere+".radius");
		x3dTotalTransformDisable($underworld);

		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode "transform"`;
		string $tempMesh = `createNode "mesh" -p $newTrans`;
		hyperShade -assign initialShadingGroup $tempMesh;
		string $tempSphere = `createNode "polySphere"`;
		string $tempMesh1 = $tempMesh + ".inMesh";
		string $tempSphere1 = $tempSphere + ".output";
		connectAttr $tempSphere1 $tempMesh1;
		
		string $newMeshName = "pSphereShape#";
		string $fMeshName = `rename $tempMesh $newMeshName`;
		
		string $newTransName = "pSphere#";
		string $fTransName = `rename $newTrans $newTransName`;
		string $underworld = `createNode x3dSphere -p $fMeshName`;
		connectAttr ($underworld+".radius") ($tempSphere+".radius");
		x3dTotalTransformDisable($underworld);
		select $fTransName;
	}

}

//---------------------------------------------------------
// Procedure for creating an Polygon Box Primitive Node
//---------------------------------------------------------
global proc createX3DBoxes()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newTrans = `createNode "transform" -p $selTrans[0]`;
		string $tempMesh = `createNode "mesh" -p $newTrans`;
		hyperShade -assign initialShadingGroup $tempMesh;
		string $tempBox = `createNode "polyCube"`;
		string $tempMesh1 = $tempMesh + ".inMesh";
		string $tempBox1 = $tempBox + ".output";
		connectAttr $tempBox1 $tempMesh1;
				
		string $newMeshName = "pCubeShape#";
		string $fMeshName = `rename $tempMesh $newMeshName`;
		
		string $newTransName = "pCube#";
		string $fTransName = `rename $newTrans $newTransName`;
		string $underworld = `createNode x3dBox -p $fMeshName`;
		connectAttr ($underworld+".size0") ($tempBox+".width");
		connectAttr ($underworld+".size1") ($tempBox+".height");
		connectAttr ($underworld+".size2") ($tempBox+".depth");
		x3dTotalTransformDisable($underworld);

		select -add $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode "transform"`;
		string $tempMesh = `createNode "mesh" -p $newTrans`;
		hyperShade -assign initialShadingGroup $tempMesh;
		string $tempBox = `createNode "polyCube"`;
		string $tempMesh1 = $tempMesh + ".inMesh";
		string $tempBox1 = $tempBox + ".output";
		connectAttr $tempBox1 $tempMesh1;
		
		string $newMeshName = "pCubeShape#";
		string $fMeshName = `rename $tempMesh $newMeshName`;
		
		string $newTransName = "pCube#";
		string $fTransName = `rename $newTrans $newTransName`;
		string $underworld = `createNode x3dBox -p $fMeshName`;
		connectAttr ($underworld+".size0") ($tempBox+".width");
		connectAttr ($underworld+".size1") ($tempBox+".height");
		connectAttr ($underworld+".size2") ($tempBox+".depth");
		x3dTotalTransformDisable($underworld);
		select $fTransName;
	}

}

//---------------------------------------------------------
// Procedure for creating an x3dTouchSensor Node
//---------------------------------------------------------
global proc createX3DTouchSensors()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $oldTrans = $selTrans[0];
		string $newTouchSensor = `createNode x3dTouchSensor -p $oldTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $newTouchSensor = `createNode x3dTouchSensor -p $newTrans`;

		select $newTrans;
	}

}

//---------------------------------------------------------
// Procedure for creating an x3dTimeSensor Node
//---------------------------------------------------------
global proc createX3DTimeSensors()
{
//	string $selTrans[] = getSelectedGroupingNodes();
//	int $selSize = size($selTrans);
//	if($selSize > 0)
//	{
//		string $newTrans = `createNode transform -p $selTrans[0]`;
//		string $newTimeSensor = `createNode x3dTimeSensor -p $newTrans`;
//		select $selTrans[0];
//	}
//	else
//	{
		string $newTrans = `createNode transform`;
		string $newTimeSensor = `createNode x3dTimeSensor -p $newTrans`;
	
		select $newTrans;
//	}

}

global proc createX3DBooleanFilters()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $oldTrans = $selTrans[0];
		string $newBooleanFilter = `createNode x3dBooleanFilter -p $oldTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $newBooleanFilter = `createNode x3dBooleanFilter -p $newTrans`;

		select $newTrans;
	}

}

global proc createX3DBooleanSequencers()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $oldTrans = $selTrans[0];
		string $newBooleanSequencer = `createNode x3dBooleanSequencer -p $oldTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $newBooleanSequencer = `createNode x3dBooleanSequencer -p $newTrans`;

		select $newTrans;
	}

}

global proc createX3DBooleanToggles()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $oldTrans = $selTrans[0];
		string $newBooleanToggle = `createNode x3dBooleanToggle -p $oldTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $newBooleanToggle = `createNode x3dBooleanToggle -p $newTrans`;

		select $newTrans;
	}

}

global proc createX3DBooleanTriggers()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $oldTrans = $selTrans[0];
		string $newBooleanTrigger = `createNode x3dBooleanTrigger -p $oldTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $newBooleanTrigger = `createNode x3dBooleanTrigger -p $newTrans`;

		select $newTrans;
	}

}

global proc createX3DIntegerSequencers()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $oldTrans = $selTrans[0];
		string $newIntegerSequencer = `createNode x3dIntegerSequencer -p $oldTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $newIntegerSequencer = `createNode x3dIntegerSequencer -p $newTrans`;

		select $newTrans;
	}

}

global proc createX3DIntegerTriggers()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $oldTrans = $selTrans[0];
		string $newIntegerTrigger = `createNode x3dIntegerTrigger -p $oldTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $newIntegerTrigger = `createNode x3dIntegerTrigger -p $newTrans`;

		select $newTrans;
	}

}

global proc createX3DTimeTriggers()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $oldTrans = $selTrans[0];
		string $newTimeTrigger = `createNode x3dTimeTrigger -p $oldTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $newTimeTrigger = `createNode x3dTimeTrigger -p $newTrans`;

		select $newTrans;
	}

}

global proc createX3DCylinderSensors()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $oldTrans = $selTrans[0];
		string $newCylinderSensor = `createNode x3dCylinderSensor -p $oldTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $newCylinderSensor = `createNode x3dCylinderSensor -p $newTrans`;

		select $newTrans;
	}

}

global proc createX3DPlaneSensors()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $oldTrans = $selTrans[0];
		string $newPlaneSensor = `createNode x3dPlaneSensor -p $oldTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $newPlaneSensor = `createNode x3dPlaneSensor -p $newTrans`;

		select $newTrans;
	}

}

global proc createX3DSphereSensors()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $oldTrans = $selTrans[0];
		string $newSphereSensor = `createNode x3dSphereSensor -p $oldTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $newSphereSensor = `createNode x3dSphereSensor -p $newTrans`;

		select $newTrans;
	}

}

global proc createX3DKeySensors()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newTrans = `createNode transform -p $selTrans[0]`;
		string $newKeySensor = `createNode x3dKeySensor -p $newTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $newKeySensor =`createNode x3dKeySensor -p $newTrans`;

		select $newTrans;
	}

}

global proc createX3DLoadSensors()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newTrans = `createNode transform -p $selTrans[0]`;
		string $newLoadSensor = `createNode x3dLoadSensor -p $newTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $newLoadSensor =`createNode x3dLoadSensor -p $newTrans`;

		select $newTrans;
	}

}

global proc createX3DStringSensors()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newTrans = `createNode transform -p $selTrans[0]`;
		string $newStringSensor = `createNode x3dStringSensor -p $newTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $newStringSensor =`createNode x3dStringSensor -p $newTrans`;

		select $newTrans;
	}

}

global proc createX3DSounds()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newTrans = `createNode transform -p $selTrans[0]`;
		string $newSound = `createNode x3dSound -p $newTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $newSound =`createNode x3dSound -p $newTrans`;

		select $newTrans;
	}

}

global proc createX3DAudioClips()
{
	string $soundNodes[] = `ls -sl`;
	string $newAudio = `createNode audio`;
	if(size($soundNodes) > 0)
	{
		string $nodeType = `nodeType $soundNodes[0]`;
		if($nodeType == "x3dSound")
		{
			int $val = `connectionInfo -id ($soundNodes[0]+".audioIn")`;
			if($val == 0) connectAttr ($newAudio+".audioOut") ($soundNodes[0]+".audioIn");
		}
	}
	select $newAudio;
}

//---------------------------------------------------------
// Procedure for creating an x3dPositionInterpolator Node
//---------------------------------------------------------
global proc createX3DPositionInterpolators()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newTrans = `createNode transform -p $selTrans[0]`;
		string $newPI = `createNode x3dPositionInterpolator -p $newTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $newPI =`createNode x3dPositionInterpolator -p $newTrans`;

		select $newTrans;
	}

}

//---------------------------------------------------------
// Procedure for creating an x3dOrientationInterpolator Node
//---------------------------------------------------------
global proc createX3DOrientationInterpolators()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newTrans = `createNode transform -p $selTrans[0]`;
		string $newPI = `createNode x3dOrientationInterpolator -p $newTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $newPI =`createNode x3dOrientationInterpolator -p $newTrans`;

		select $newTrans;
	}

}

global proc createX3DColorInterpolators()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newTrans = `createNode transform -p $selTrans[0]`;
		string $newCI = `createNode x3dColorInterpolator -p $newTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $newCI =`createNode x3dColorInterpolator -p $newTrans`;

		select $newTrans;
	}

}

global proc createX3DCoordinateInterpolators()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newTrans = `createNode transform -p $selTrans[0]`;
		string $newCoordinateI = `createNode x3dCoordinateInterpolator -p $newTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $newCoordinateI =`createNode x3dCoordinateInterpolator -p $newTrans`;

		select $newTrans;
	}

}

global proc createX3DNormalInterpolators()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newTrans = `createNode transform -p $selTrans[0]`;
		string $newNormalI = `createNode x3dNormalInterpolator -p $newTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $newNormalI =`createNode x3dNormalInterpolator -p $newTrans`;

		select $newTrans;
	}

}

global proc createX3DScalarInterpolators()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newTrans = `createNode transform -p $selTrans[0]`;
		string $newScalarI = `createNode x3dScalarInterpolator -p $newTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $newScalarI =`createNode x3dScalarInterpolator -p $newTrans`;

		select $newTrans;
	}

}

//---------------------------------------------------------
// Procedure for creating an x3dScript Node
//---------------------------------------------------------
global proc createX3DScripts()
{
	string $selTrans[] = getSelectedGroupingNodes();
	int $selSize = size($selTrans);
	if($selSize > 0)
	{
		string $newTrans = `createNode transform -p $selTrans[0]`;
		string $thisSNode = `createNode x3dScript -p $newTrans`;
		select $selTrans[0];
	}
	else
	{
		string $newTrans = `createNode transform`;
		string $thisSNode = `createNode x3dScript -p $newTrans`;
	
		select $newTrans;
	}

}

//---------------------------------------------------------
// Procedure for adding attributes that display proper
// x3d SFRotation values when the object is oriented using
// Maya's rotate tool.
//---------------------------------------------------------
global proc addSFRotationAttributes(string $ann, int $attrName)
{
	string $longN = "rotation";
	string $shortN = "rotn";
	
	switch($attrName)
	{
		case 0:
			$longN = "rotation";
			$shortN = "rotn";
			break;
			
		case 1:
			$longN = "orientation";
			$shortN = "orin";
			break;
			
		case 2:
			$longN = "direction";
			$shortN = "dirn";
			break;
		default:
			break;
	}
	
	if(`attributeExists "xnt" $ann`){
		if(`attributeExists $longN $ann`)
		{
		}
		else
		{
			int $theXntValue = `getAttr ($ann+".xnt")`;
			int $needsTheFix = 0;
			switch($theXntValue)
			{
				case 1:
					$needTheFix = 1;
					break;
				default:
					break;
			}
			if($needTheFix != 1 ){
				if($longN != "direction"){
					addAttr -ln $longN -sn $shortN -s true -k true -numberOfChildren 4 -attributeType compound $ann;
				}
				else
				{
					addAttr -ln $longN -sn $shortN -s true -k true -numberOfChildren 3 -attributeType compound $ann;
				}
				addAttr -ln ($longN+"X") -sn ($shortN+"X") -s true -k true -at "float"  -defaultValue 0 -minValue -1 -maxValue 1 -p $longN $ann;
				addAttr -ln ($longN+"Y") -sn ($shortN+"Y") -s true -k true -at "float"  -defaultValue 0 -minValue -1 -maxValue 1 -p $longN $ann;
				addAttr -ln ($longN+"Z") -sn ($shortN+"Z") -s true -k true -at "float"  -defaultValue 1 -minValue -1 -maxValue 1 -p $longN $ann;
				if($longN != "direction")	addAttr -ln ($longN+"W") -sn ($shortN+"W") -s true -k true -at "float"  -defaultValue 0 -minValue -6.3 -maxValue 6.3 -p $longN $ann;

				
				// The following added attributes and maya connections are necessary because there is a bug in the "store" flag that won't save 
				// user defined attributes to disk unless that attribute is connected to another. By adding the additional attributes and connections 
				// below maya saves our desired rotation values to the file.
				addAttr -ln ($longN+"XC") -sn ($shortN+"XC") -s true -k true -at "float" -hidden true -defaultValue 0 -minValue -1 -maxValue 1 $ann;
				addAttr -ln ($longN+"YC") -sn ($shortN+"YC") -s true -k true -at "float" -hidden true -defaultValue 0 -minValue -1 -maxValue 1 $ann;
				addAttr -ln ($longN+"ZC") -sn ($shortN+"ZC") -s true -k true -at "float" -hidden true -defaultValue 1 -minValue -1 -maxValue 1 $ann;
				if($longN != "direction") addAttr -ln ($longN+"WC") -sn ($shortN+"WC") -s true -k true -at "float" -hidden true -defaultValue 0 -minValue -6.3 -maxValue 6.3 $ann;
				
				connectAttr ($ann+"."+$shortN+"X") ($ann+"."+$shortN+"XC");
				connectAttr ($ann+"."+$shortN+"Y") ($ann+"."+$shortN+"YC");
				connectAttr ($ann+"."+$shortN+"Z") ($ann+"."+$shortN+"ZC");
				if($longN != "direction") connectAttr ($ann+"."+$shortN+"W") ($ann+"."+$shortN+"WC");
				
				string $nodeTypeCk = `nodeType $ann`;
				if($nodeTypeCk == "transform" && $longN == "rotation")
				{
					addAttr -ln "scaleOrientation" -sn "so" -s true -k true -numberOfChildren 4 -attributeType compound $ann;
					addAttr -ln "scaleOrientationX" -sn "soX" -s true -k true -at "float" -defaultValue 0 -minValue 1 -maxValue 1 -p "scaleOrientation" $ann;
					addAttr -ln "scaleOrientationY" -sn "soY" -s true -k true -at "float" -defaultValue 0 -minValue 1 -maxValue 1 -p "scaleOrientation" $ann;
					addAttr -ln "scaleOrientationZ" -sn "soZ" -s true -k true -at "float" -defaultValue 0 -minValue 1 -maxValue 1 -p "scaleOrientation" $ann;
					addAttr -ln "scaleOrientationW" -sn "soW" -s true -k true -at "float" -defaultValue 0 -minValue 1 -maxValue 1 -p "scaleOrientation" $ann;
					
				// The following added attributes and maya connections are necessary because there is a bug in the "store" flag that won't save 
				// user defined attributes to disk unless that attribute is connected to another. By adding the additional attributes and connections 
				// below maya saves our desired rotation values to the file.
					addAttr -ln "scaleOrientationC" -sn "soC" -s true -k true -numberOfChildren 4 -attributeType compound $ann;
					addAttr -ln "scaleOrientationXC" -sn "soXC" -s true -k true -at "float" -hidden true -defaultValue 0 -minValue 1 -maxValue 1 -p "scaleOrientationC" $ann;
					addAttr -ln "scaleOrientationYC" -sn "soYC" -s true -k true -at "float" -hidden true -defaultValue 0 -minValue 1 -maxValue 1 -p "scaleOrientationC" $ann;
					addAttr -ln "scaleOrientationZC" -sn "soZC" -s true -k true -at "float" -hidden true -defaultValue 0 -minValue 1 -maxValue 1 -p "scaleOrientationC" $ann;
					addAttr -ln "scaleOrientationWC" -sn "soWC" -s true -k true -at "float" -hidden true -defaultValue 0 -minValue 1 -maxValue 1 -p "scaleOrientationC" $ann;
					connectAttr ($ann+".soX") ($ann+".soXC");
					connectAttr ($ann+".soY") ($ann+".soYC");
					connectAttr ($ann+".soZ") ($ann+".soZC");
					connectAttr ($ann+".soW") ($ann+".soWC");
				}
			}
		}
		int $xntValue = `getAttr ($ann+".xnt")`;
		switch($xntValue)
		{
			case 0:
				expression -s ("float $sfRotArray[] = x3dSFRotationConversion("+$ann+".rotateY, "+$ann+".rotateX, "+$ann+".rotateZ);\r\n"+$ann+"."+$longN+"X = $sfRotArray[0];\r\n"+$ann+"."+$longN+"Y = $sfRotArray[1];\r\n"+$ann+"."+$longN+"Z = $sfRotArray[2];\r\n"+$ann+"."+$longN+"W = $sfRotArray[3];\r") -ae 1 -uc none;		
				break;
			
			//A case of "1" would tell us that the node is a "Group" node and doesn't have any form of angle associated with it.
			case 1:
				break;
			
			case 2:
				expression -s ("float $sfRotArray[] = x3dSFRotationConversion("+$ann+".rotateY, "+$ann+".rotateX, "+$ann+".rotateZ);\r\n"+$ann+"."+$longN+"X = $sfRotArray[0];\r\n"+$ann+"."+$longN+"Y = $sfRotArray[1];\r\n"+$ann+"."+$longN+"Z = $sfRotArray[2];\r\n"+$ann+"."+$longN+"W = $sfRotArray[3];\r") -ae 1 -uc none;		
				break;
			
			default:
				expression -s ("float $sfRotArray[] = x3dSFRotationConversion("+$ann+".rotateY, "+$ann+".rotateX, "+$ann+".rotateZ);\r\n"+$ann+"."+$longN+"X = $sfRotArray[0];\r\n"+$ann+"."+$longN+"Y = $sfRotArray[1];\r\n"+$ann+"."+$longN+"Z = $sfRotArray[2];\r") -ae 1 -uc none;		
				break;
			
		}
	//x3dSFRotationConversion(float $ay, float $ax, float $az)
		
	}
}

//-----------------------------------------------------------
//Procedure for checking whether or not a child can be added
//to any particular tranform node.
//-----------------------------------------------------------
global proc int setX3DNodeTypeValue(string $cTransform, int $whichChoice)
{
	int $isAcceptable = 1;
	string $cRelatives[] = `listRelatives -c $cTransform`;
	string $theType = "";
	string $muggleNodes[];
	if(`objExists $cRelatives[0]`){
		$theType = `nodeType $cRelatives[0]`;
		$muggleNodes[0] = $cTransform;
		$muggleNodes[1] = $cRelatives[0];
	}
	
	if($theType == "camera")
	{
		addViewpointDefaults($muggleNodes);
		$isAcceptable = 0;
		addAttr -ln "x3dNodeType" -sn "xnt" -at short -defaultValue 2 $cTransform;
		addSFRotationAttributes($cTransform, 1);
	}
	if($theType == "directionalLight")
	{
		addDirectionalLightDefaults($muggleNodes);
		$isAcceptable = 0;
		addAttr -ln "x3dNodeType" -sn "xnt" -at short -defaultValue 3 $cTransform;
		addSFRotationAttributes($cTransform, 2);
	}
	if($theType == "spotLight")
	{
		addSpotLightDefaults($muggleNodes);
		$isAcceptable = 0;
		addAttr -ln "x3dNodeType" -sn "xnt" -at short -defaultValue 4 $cTransform;
		addSFRotationAttributes($cTransform, 2);
	}
	if($theType == "pointLight")
	{
		addPointLightDefaults($muggleNodes);
		$isAcceptable = 0;
		addAttr -ln "x3dNodeType" -sn "xnt" -at short -defaultValue 5 $cTransform;
//		addSFRotationAttributes($cTransform, 5);
	}
	if($isAcceptable)
	{
		string $tNodeType = `nodeType $cTransform`;
		if($tNodeType == "transform")
		{
			addAttr -ln "x3dNodeType" -sn "xnt" -at short -defaultValue $whichChoice $cTransform;
			int $tNumber = 0;
			if($whichChoice == 1) $tNumber = -1;
			addSFRotationAttributes($cTransform, $tNumber);
		}
	}
	return $isAcceptable;
}

//addSFRotationAttributes(string $ann, int $attrName)

//-----------------------------------------------------------
// Procedure for getting selected transform nodes
//-----------------------------------------------------------
global proc string[] getSelectedGroupingNodes()
{
	string $selGroupingNodes[];
	int $aNum = 0;
	string $listOfNodes[] = `selectedNodes`;
	int $lonSize = size($listOfNodes);
	int $cThr;
	for($cThr=0;$cThr<$lonSize;$cThr++)
	{
		string $ncName = $listOfNodes[$cThr];
		string $id = `nodeType $ncName`;
		switch($id)
		{
			case "transform":
				$selGroupingNodes[$aNum] = $listOfNodes[$cThr];
				$aNum = $aNum+1;
				break;
			
			case "x3dGroup":
				$selGroupingNodes[$aNum] = $listOfNodes[$cThr];
				$aNum = $aNum+1;
				break;
			
			case "x3dCollision":
				$selGroupingNodes[$aNum] = $listOfNodes[$cThr];
				$aNum = $aNum+1;
				break;
			
			case "x3dSwitch":
				$selGroupingNodes[$aNum] = $listOfNodes[$cThr];
				$aNum = $aNum+1;
				break;
			
			case "x3dLOD":
				$selGroupingNodes[$aNum] = $listOfNodes[$cThr];
				$aNum = $aNum+1;
				break;
				
			case "x3dAnchor":
				$selGroupingNodes[$aNum] = $listOfNodes[$cThr];
				$aNum = $aNum+1;
				break;
				
			default:
				break;
		}
	}
	return $selGroupingNodes;
}

//-----------------------------------------------------------
// Procedure to be called from the expression where the
// conversion is done
//-----------------------------------------------------------
global proc float[] x3dSFRotationConversion(float $ay, float $ax, float $az)
{
	float $returnFloats[] = {0,0,1,0};
	
	
	//csv - (c)osine (s)ine (v)alues
	float $cv[] = { cos($az/2), cos($ay/2), cos($ax/2) };//switch: z took the place of y - y took the place of x
	float $sv[] = { sin($az/2), sin($ay/2), sin($ax/2) }; 
	int $i;
	for ($i=0; $i< 3; $i++)
	{
//		print($cv[$i]+"\n");
//		print($sv[$i]+"\n");
	}
//	print("\n\n");
	float $aCosFloat = ( $cv[0] * $cv[1] * $cv[2] ) + ( $sv[0] * $sv[1] * $sv[2] );
	float $wVec = 2 * acos( $aCosFloat );
	float $xVec = ( $cv[0] * $cv[1] * $sv[2] ) - ( $sv[0] * $sv[1] * $cv[2]); 
	float $yVec = ( $cv[0] * $sv[1] * $cv[2] ) + ( $sv[0] * $cv[1] * $sv[2]);
	float $zVec = ( $sv[0] * $cv[1] * $cv[2] ) - ( $cv[0] * $sv[1] * $sv[2]);
	
	float $denominator = ($xVec * $xVec) + ($yVec * $yVec) + ($zVec * $zVec);
	if($denominator == 0)
	{
		$xVec = 0;
		$yVec = 0;
		$zVec = 1;
		$wVec = 0;
	}

	$returnFloats[0] = $xVec;
	$returnFloats[1] = $yVec;
	$returnFloats[2] = $zVec;
	$returnFloats[3] = $wVec;
	
	return $returnFloats;
}

//----------------------------------------------------------------------------
// Procedure for disabling the MPxTransform related attributes of the 
// underworld nodes.
//----------------------------------------------------------------------------
global proc x3dTotalTransformDisable(string $ann)
{
	x3dTranslateDisable($ann);
	x3dRotateDisable($ann);
	x3dShearDisable($ann);
	x3dScaleDisable($ann);
	x3dVisibilityDisable($ann);
}

//----------------------------------------------------------------------------
//Disabling Transform Node attributes to conform with X3D Nodes
//----------------------------------------------------------------------------

global proc x3dTranslateDisable(string $ann)
{
	setAttr -l on -k false ($ann+".translate");
	setAttr -l on -k false ($ann+".translateX");
	setAttr -l on -k false ($ann+".translateY");
	setAttr -l on -k false ($ann+".translateZ");
}

global proc x3dRotateDisable(string $ann)
{
	setAttr -l on -k false ($ann+".rotate");
	setAttr -l on -k false ($ann+".rotateX");
	setAttr -l on -k false ($ann+".rotateY");
	setAttr -l on -k false ($ann+".rotateZ");
}

global proc x3dShearDisable(string $ann)
{
	setAttr -l on ($ann+".shear");
}

global proc x3dScaleDisable(string $ann)
{
	setAttr -l on -k false ($ann+".scale");
	setAttr -l on -k false ($ann+".scaleX");
	setAttr -l on -k false ($ann+".scaleY");
	setAttr -l on -k false ($ann+".scaleZ");
}

global proc x3dVisibilityDisable(string $ann)
{
	setAttr -k false ($ann+".visibility");
}

//----------------------------------------------------
//necessary numerical id assignment for the purpose of 
//updating visibility within switch node children
//----------------------------------------------------
//global proc int getNewSwitchId()
//{
//	string $transList[] = `lsType "transform"`;
//	string $switchList[];
//	string $switchList[] = `ls -et x3dSwitch`;
	
//	int $newSID = 0;
//	int $tlSize = size($transList);
//	int $i;
/*	
	int $j=0;
	for($i=0;$i<$tlSize-1;$i++)
	{
		string $tNodeType = `nodeType $transList[$i]`;
		if($tNodeType == "x3dSwitch")
		{
			$switchList[$j] = $transList[$i];
			$j = $j+1;
		}
	}
*/	
//	int $slSize = size($switchList);
//	for($i=0;$i<$slSize;$i++)
//	{
//		int $testId = `getAttr ($switchList[$i]+".switchId")`;
//		if($newSID <= $testId) $newSID = $testId+1;
//	}
//	return $newSID;
//}