global string $x3dAEsn[];

global proc x3dChangeAllTexturesChop(string $newDir, string $chop)
{
	string $fileNodes[] = `ls -et file`;
	int $listSize = size($fileNodes);
	int $i;
	for($i=0;$i<$listSize;$i++)
	{
		string $oldLoc = `getAttr ($fileNodes[$i]+".fileTextureName")`;
		string $cutFN[];
		tokenize($oldLoc,$chop,$cutFN);
		int $tSize = size($cutFN);
		string $newLoc = $newDir + $cutFN[$tSize-1];
		setAttr -type "string" ($fileNodes[$i]+".fileTextureName") $newLoc;
	}
}
global proc x3dChangeAllTextures(string $newDir)
{
	x3dChangeAllTexturesChop($newDir, "/");
}

global proc x3dDeleteAllClothSolvers()
{
	string $cSolvers[] = `ls -type cpClothSolver`;
	int $csize = size($cSolvers);
	int $i;
	for($i=0;$i<$csize;$i++)
	{
		delete $cSolvers[$i];
	}
}

global proc x3dDeleteStubbornNodes(string $delName)
{
	string $x3dThings[] = `ls -type $delName`;
	int $i;
	for($i=0;$i<size($x3dThings);$i++)
	{
		delete $x3dThings[$i];
	}
}

global proc x3dOldTextureAtts()
{
	string $textures[] = `ls -sn -et "bulge" -et "checker" -et "cloth" -et "file" -et "fluidTexture2D" -et "fractal" -et "grid" -et "mountain" -et "noise" -et "ocean" -et "ramp" -et "water"`;
	int $ts = size($textures);
	int $i;
	for($i=0;$i<$ts;$i++)
	{
		if(attributeExists("x3dpix",$textures[$i]))
		{
			int $x3dTF = getX3DTextureFormat($textures[$i]);
			int $x3dTT = getX3DTextureType($textures[$i]);
			int $x3dIM = getX3DImageMode($textures[$i]);
			
			setAttr ($textures[$i]+".fChoice") $x3dTF;
			setAttr ($textures[$i]+".tOption") $x3dTT;
			setAttr ($textures[$i]+".stMode") $x3dIM;
		}
	}
}

global proc int getX3DTextureFormat(string $nodeName)
{
	int $value = 0;
	int $fmt = 0;
	$fmt = `getAttr ($nodeName+".imgfmtcur")`;
	if($fmt == 1) $value = 0;
	else
	{
		$fmt = `getAttr ($nodeName+".imgfmtgif")`;
		if($fmt == 1) $value = 1;
		else
		{
			$fmt = `getAttr ($nodeName+".imgfmtjpg")`;
			if($fmt == 1) $value = 2;
			else
			{
				$fmt = `getAttr ($nodeName+".imgfmtpng")`;
				if($fmt == 1) $value = 3;
			}
		}
	}
	deleteAttr ($nodeName+".imgfmtcur");
	deleteAttr ($nodeName+".imgfmtgif");
	deleteAttr ($nodeName+".imgfmtjpg");
	deleteAttr ($nodeName+".imgfmtpng");
	return $value;
}

global proc int getX3DImageMode(string $nodeName)
{
	int $value = 0;
	int $fmt = 0;
	$fmt = `getAttr ($nodeName+".dns")`;
	if($fmt == 1) $value = 0;
	else
	{
		$fmt = `getAttr ($nodeName+".stmr")`;
		if($fmt == 1) $value = 1;
		else
		{
			$fmt = `getAttr ($nodeName+".stmm")`;
			if($fmt == 1) $value = 2;
			else
			{
				$fmt = `getAttr ($nodeName+".stma")`;
				if($fmt == 1) $value = 3;
			}
		}
	}
	deleteAttr ($nodeName+".dns");
	deleteAttr ($nodeName+".stmr");
	deleteAttr ($nodeName+".stmm");
	deleteAttr ($nodeName+".stma");
	return $value;
}

global proc int getX3DTextureType(string $nodeName)
{
	int $value = `getAttr ($nodeName+".x3dpix")`;
	deleteAttr ($nodeName+".x3dpix");
	return $value;
}

global proc x3dSetAllSingleTextureModes(int $mode)
{
	if($mode>-1 && $mode < 4)
	{
		string $textures[] = `ls -sn -et "bulge" -et "checker" -et "cloth" -et "file" -et "fluidTexture2D" -et "fractal" -et "grid" -et "mountain" -et "noise" -et "ocean" -et "ramp" -et "water"`;
		int $ts = size($textures);
		int $i;
		for($i=0;$i<$ts;$i++)
		{
			setAttr ($textures[$i]+".singleTextureMode") $mode;
		}
	}
}

global proc x3dSetAllTexturesPixel()
{
	string $textures[] = `ls -sn -et "bulge" -et "checker" -et "cloth" -et "file" -et "fluidTexture2D" -et "fractal" -et "grid" -et "mountain" -et "noise" -et "ocean" -et "ramp" -et "water"`;
	int $ts = size($textures);
	int $i;
	for($i=0;$i<$ts;$i++)
	{
		setAttr ($textures[$i]+".textureOption") 1;
	}
}

global proc x3dSetAllTexturesFile()
{
	string $textures[] = `ls -sn -et "bulge" -et "checker" -et "cloth" -et "file" -et "fluidTexture2D" -et "fractal" -et "grid" -et "mountain" -et "noise" -et "ocean" -et "ramp" -et "water"`;
	int $ts = size($textures);
	int $i;
	for($i=0;$i<$ts;$i++)
	{
		setAttr ($textures[$i]+".textureOption") 0;
	}
}

global proc x3dPrep()
{
	x3dPrepareSceneForExport();
}

global proc x3dPrepareSceneForExport()
{
	x3dDeleteEmptyTransforms();
	delete -all -constructionHistory;
	SelectAll;
	FreezeTransformations;
	delete -all -constructionHistory;
	OptimizeScene;
}

global proc x3dDeleteEmptyTransforms()
{
	string $trans[] = `ls -type transform`;
	string $empties[];
	int $i;
	int $j;
	for($i=0;$i<size($trans);$i++)
	{
		if(`objExists $trans[$i]`)
		{
			int $hasNoNT = true;
			string $descends[] = `listRelatives -ad $trans[$i]`;
			for($j=0;$j<size($descends);$j++)
			{
				string $nodeType = `nodeType $descends[$j]`;
				if($nodeType != "transform") $hasNoNT = false;
			}
			if($hasNoNT) delete $trans[$i];
		}
	}
}

global proc	x3dSetRouteDirectly(string $mayaFromNode, string $x3dFType, string $fNode, string $fField, string $mayaToNode, string $x3dTType, string $tNode, string $tField)
{
	
	string $newRoute = `createNode("x3dRoute")`;

	setAttr ($newRoute+".x3dTypeFrom") -type "string" $x3dFType;
	setAttr ($newRoute+".x3dTypeTo") -type "string" $x3dTType;
	setAttr ($newRoute+".chopFrom") -type "string" $fNode;
	setAttr ($newRoute+".chopTo") -type "string" $tNode;
	string $getFromVal = `getAttr ($newRoute+".nameFrom1")`;
	setAttr ($newRoute+".nameFrom1") -type "string" $getFromVal;
	string $getToVal = `getAttr ($newRoute+".nameTo1")`;
	setAttr ($newRoute+".nameTo1") -type "string" $getToVal;

	string $fromName = `getAttr ($newRoute+".fromNode")`;
	string $toName = `getAttr ($newRoute+".toNode")`;
	setAttr ($newRoute+".fromValue") -type "string" $fField;
	setAttr ($newRoute+".toValue") -type "string" $tField;

	connectAttr -l true ($mayaFromNode+".x3dra") ($newRoute+".x3dfr");
	connectAttr -l true ($mayaToNode+".x3dra") ($newRoute+".x3dto");
	
	/*
	int $fromExist = `objExists $getFromVal`;
	int $toExist = `objExists $getToVal`;
			
	if($fromExist == 1 && $toExist == 0) $getToVal = $getFromVal;
	if($fromExist == 0 && $toExist == 1) $getFromVal = $getToVal;
	if($fromExist == 1 || $toExist == 1)
	{
		connectAttr -l true ($getFromVal+".x3dra") ($newRoute+".x3dfr");
		connectAttr -l true ($getToVal+".x3dra") ($newRoute+".x3dto");
	}
	*/
	
}

//////////////////////////////////////////
//X3D Animation Setup Utility
//////////////////////////////////////////
global proc x3dAnimationEditor()
{
global string $x3dAEsn[];
	string $tempString[];
	$x3dAEsn = $tempString;

	string $x3dAE = `window -title "X3D Animation Editor" -s true -width 400 -height 450`;
	$tempString = `ls -sl -et transform -et lodGroup -et x3dSwitch -et x3dCollision -et x3dAnchor -et x3dInline`;
	int $i;
	int $j = 0;
	for($i=0;$i<size($tempString);$i++)
	{
		int $iv = `getAttr ($tempString[$i]+".intermediateObject")`;
		if($iv == false)
		{
			$x3dAEsn[$j] = $tempString[$i];
			$j = $j + 1;
		}
	}

	if(size($x3dAEsn) == 0)
	{
		deleteUI -window $x3dAE;
		warning("Incorrect Grouping Node Selected");
	}
	else
	{
		columnLayout;
			rowLayout -nc 2 -cw2 90 300 -columnAlign  1 "left"
		    	-columnAttach 1 "both" 	2
		    	-columnAttach 2 "both"  2;
				text -label "TimeSensors" -fn "boldLabelFont";
				text -label "Grouping Nodes" -fn "boldLabelFont";
			setParent ..;
	
			rowLayout -nc 2 -cw2 90 300 -columnAlign  1 "left"
		    	-columnAttach 1 "both" 	2
		    	-columnAttach 2 "both"  2;
				string $timerList = `textScrollList -nr 8 -ams false -aas false -sc "x3dAEUpdateTimerSettings" x3dAETimerList`;
				string $groupList = `textScrollList -nr 8 -ams true -aas false x3dAEGroupList`;
			setParent ..;
			rowLayout -nc 2 -cw2 380 10  -columnAlign  1 "left"
		    	-columnAttach 1 "left" 	2
		    	-columnAttach 2 "both"  2;
				string $aeCbg = `checkBoxGrp -numberOfCheckBoxes 3 -width 380 -cw4 95 95 95 95 -label "X3D Fields: " -labelArray3 "Translation" "Rotation" "Scale" x3dAECBG`;
				text -label "          ";
			setParent ..;
			rowLayout -nc 1 -cw1 390;
				text -label "          ";
			setParent ..;
			rowLayout -nc 3 -cw3 140 110 140 -columnAlign  1 "left"
		    	-columnAttach 1 "both" 	2
		    	-columnAttach 2 "both"  2
		    	-columnAttach 3 "both"  2;
				text -label "          ";
				button -label "  Set Interpolators " -c "x3dAESetInterpolators";
				text -label "          ";
			setParent ..;
			rowLayout -nc 1 -cw1 390 -columnAlign  1 "left"
		    	-columnAttach 1 "both" 2;
				text -label "TimeSensor Settings" -fn "boldLabelFont";
			setParent ..;
			rowLayout -nc 1 -cw1 390 -columnAlign  1 "left"
		    	-columnAttach 1 "both" 2;
				columnLayout;
					string $keso = `floatSliderGrp -label "  Key Every So Many Frames" -field true -minValue 1.0 -maxValue 100.0 -fieldMinValue 1.0 -fieldMaxValue 100.0 -value 1 -cc "x3dAEKesoChange" x3dAEKeso`;
					string $str = `floatFieldGrp -label "Start Frame" -cc "x3dAEStartFrameChange" x3dAESTF`;
					string $sto = `floatFieldGrp -label "Stop Frame" -cc "x3dAEStopFrameChange" x3dAESPF`;
					string $fps = `intSliderGrp -label "Frames Per Second" -field true -minValue 1.0 -maxValue 60.0 -fieldMinValue 1.0 -fieldMaxValue 60.0 -value 30 -cc "x3dAEFPSChange" x3dAEFPS`;
					string $cyi = `floatFieldGrp -label "CycleInterval" -en false x3dAECI`;
					string $ena = `checkBoxGrp -numberOfCheckBoxes 1 -label "Enabled" -value1 true -cc "x3dAEEnabledChange" x3dAEEN`;
					string $loo = `checkBoxGrp -numberOfCheckBoxes 1 -label "Loop" -cc "x3dAELoopChange" x3dAELoop`;
				setParent ..;
			setParent ..;
			string $aeTimerMenu = `popupMenu -parent $timerList`;
			string $aetm1 = `menuItem -l "Create New TimeSensor" -p $aeTimerMenu -c "x3dAECreateNewTimeSensor"`;
		x3dAEUpdateTimerList();
		x3dAEUpdateGroupList();
		showWindow $x3dAE;
	}
}

global proc x3dAEUpdateTimerList()
{
	textScrollList -e -ra x3dAETimerList;
	string $timesensors[] = `ls -type "x3dTimeSensor"`;
	int $i;
	for($i=0;$i<size($timesensors);$i++)
	{
		textScrollList -e -append $timesensors[$i] x3dAETimerList;
	}
}

global proc x3dAEUpdateTimerSettings()
{
	string $timers[] = `textScrollList -q -si x3dAETimerList`;
	x3dAEGetTimeSensorValues($timers[0]);
	x3dAEUpdateGroupList();
}

global proc x3dAESetInterpolators()//Pick-up Here!
{
	int $tValues[] = `textScrollList -q -sii x3dAEGroupList`;
	string $tGroups[] = `textScrollList -q -si x3dAEGroupList`;
	if(size($tGroups) > 0)
	{
		string $tSensor[] = `textScrollList -q -si x3dAETimerList`;
		string $groups[];
		int $chBoxes[];
		$chBoxes[0] = `checkBoxGrp -q -value1 x3dAECBG`;
		$chBoxes[1] = `checkBoxGrp -q -value2 x3dAECBG`;
		$chBoxes[2] = `checkBoxGrp -q -value3 x3dAECBG`;
	
		int $i;
		for($i=0;$i<size($tGroups);$i++)
		{
			string $chop1[];
			string $chop2[];
			tokenize($tGroups[$i], " ", $chop1);
			tokenize($chop1[0], ":", $chop2);
			$groups[$i] = $chop2[0];
		}
		for($i=0;$i<size($groups);$i++)
		{
			int $isAvatar = false;
			$isAvatar = x3dCheckGroupingForAvatar($groups[$i]);
			string $nodeType = `nodeType $groups[$i]`;
			string $x3dnt = "Transform";
			switch($nodeType)
			{
				case "transform":
					if($isAvatar == true) $x3dnt = "HAnimHumanoid";
					break;
				case "lodGroup":
					if($isAvatar == true) $x3dnt = "LOD";
					break;
				case "x3dSwitch":
					if($isAvatar == true) $x3dnt = "Switch";
					break;
				case "x3dCollision":
					if($isAvatar == true) $x3dnt = "Collision";
					break;
				case "x3dAnchor":
					if($isAvatar == true) $x3dnt = "Anchor";
					break;
				case "x3dInline":
					if($isAvatar == true) $x3dnt = "Inline";
					break;
				default:
					break;
			}
	
			if(`objExists $groups[$i]` && `objExists $tSensor[0]`)
			{
				string $chop3[];
				tokenize($tGroups[$i], " ", $chop3);
				string $nType = `nodeType $groups[$i]`;
				int $hasT = false;
				int $hasR = false;
				int $hasS = false;
				
				int $j;
				for($j=0;$j<size($chop3);$j++)
				{
					if($chop3[$j] == "T") $hasT = true;
					if($chop3[$j] == "R") $hasR = true;
					if($chop3[$j] == "S") $hasS = true;
				}
				switch($nType)
				{
					case "transform":
						if($isAvatar == false)
						{
							if($hasT == true)
							{
								if($chBoxes[0] == false)
								{
									x3dAEDeletePosInter($groups[$i], $tSensor[0], "translation");
								}
							}
							else if($chBoxes[0] == true) x3dAEConnectTransPosInter($groups[$i], $tSensor[0], "translation", $x3dnt);
							
							if($hasR == true)
							{
								if($chBoxes[1] == false) x3dAEDeleteOriInter($groups[$i], $tSensor[0], "rotation");
							}
							else if($chBoxes[1] == true) x3dAEConnectTransOriInter($groups[$i], $tSensor[0], "rotation", $x3dnt);
						}
						if($hasS == true)
						{
							if($chBoxes[2] == false) x3dAEDeletePosInter($groups[$i], $tSensor[0], "scale");
						}
						else if($chBoxes[2] == true) x3dAEConnectTransPosInter($groups[$i], $tSensor[0], "scale", $x3dnt);
						
						break;
					default:
						if($nodeType == "lodGroup" || $nodeType == "x3dSwitch" || $nodeType == "x3dCollision" || $nodeType == "x3dAnchor" || $nodeType == "x3dInline")
						{
							if($hasT == true)
							{
								if($chBoxes[0] == false) x3dAEDeletePosInter($groups[$i], $tSensor[0], "translation");
							}
							else if($chBoxes[0] == true) x3dAEConnectOtherPosInter($groups[$i], $tSensor[0], "translation", $x3dnt);
							if($hasR == true)
							{
								if($chBoxes[1] == false) x3dAEDeleteOriInter($groups[$i], $tSensor[0], "rotation");
							}
							else if($chBoxes[1] == true) x3dAEConnectOtherOriInter($groups[$i], $tSensor[0], "rotation", $x3dnt);
							
							if($hasS == true)
							{
								if($chBoxes[2] != true) x3dAEDeletePosInter($groups[$i], $tSensor[0], "scale");
							}
							else if($chBoxes[2] == true) x3dAEConnectOtherPosInter($groups[$i], $tSensor[0], "scale", $x3dnt);
						}
						break;
				}
			}
		}
		x3dAEUpdateGroupList();

		for($i=0;$i<size($tValues);$i++)
		{
			textScrollList -e -sii $tValues[$i] x3dAEGroupList;
		}
	}
	else warning("No nodes are selected in the \"Grouping Nodes\" list. Please, select a node(s) before pressing the button.");
}

global proc x3dAEConnectTransPosInter(string $group, string $timer, string $field, string $type)
{
	string $tPar[] = `listRelatives -p $timer`;
	string $interp = "";
	if($field == "translation") $interp = `createNode x3dPositionInterpolator -p $tPar[0]`;
	else $interp = `createNode x3dPositionInterpolator -p $tPar[0]`;
	if($field == "translation") connectAttr ($group+".translate") ($interp+".position");
	else  connectAttr ($group+".scale") ($interp+".position");
	x3dAEConnectTimerToInterp($timer, $interp, $field, "PositionInterpolator", $type, $group, $group);
}

global proc x3dAEDeletePosInter(string $group, string $timer, string $field)
{
	print("Running Delete Pos\n");
	string $cons[];
	if($field == "translation") $cons = `listConnections -source false -destination true -p true ($group+".translate")`;
	else $cons = `listConnections -source false -destination true -p true ($group+".scale")`;
	
	
	print($cons);
	print("\nInterpolator\n");
	int $i;
	for($i=0;$i<size($cons);$i++)
	{
		string $chop[];
		tokenize($cons[$i], ".", $chop);
		if(`nodeType $chop[0]` == "x3dPositionInterpolator")
		{
			string $timeCon[] = `listConnections -source true -destination false -p true ($chop[0]+".secondLength")`;
			print($timeCon[0]);
			print("\nTimeCon\n");
			string $chop1[];
			tokenize($timeCon[0], ".", $chop1);
			if(`nodeType $chop1[0]` == "x3dTimeSensor")
			{
				if($chop1[0] == $timer)	delete $chop[0];
			}
		}
	}
}

global proc x3dAEConnectTransOriInter(string $group, string $timer, string $field, string $type)
{
	string $tPar[] = `listRelatives -p $timer`;
	string $interp = `createNode x3dOrientationInterpolator -p $tPar[0]`;
	connectAttr ($group+".rotate") ($interp+".orientation");
	x3dAEConnectTimerToInterp($timer, $interp, $field, "OrientationInterpolator", $type, $group, $group);
}

global proc x3dAEDeleteOriInter(string $group, string $timer, string $field)
{
	string $cons[];
	$cons = `listConnections -source false -destination true -p true ($group+".rotate")`;
	
	int $i;
	for($i=0;$i<size($cons);$i++)
	{
		string $chop[];
		tokenize($cons[$i], ".", $chop);
		if(`nodeType $chop[0]` == "x3dOrientationInterpolator")
		{
			string $timeCon[] = `listConnections -source true -destination false -p true ($chop[0]+".secondLength")`;
			string $chop1[];
			tokenize($timeCon[0], ".", $chop1);
			if(`nodeType $chop1[0]` == "x3dTimeSensor")
			{
				if($chop1[0] == $timer)	delete $chop[0];
			}
		}
	}
}

global proc x3dAEConnectOtherPosInter(string $group, string $timer, string $field, string $type)
{
	string $tPar[] = `listRelatives -p $timer`;
	string $interp = "";
	if($field == "translation") $interp = `createNode x3dPositionInterpolator -p $tPar[0]`;
	else $interp = `createNode x3dPositionInterpolator -p $tPar[0]`;
	if($field == "translation") connectAttr ($group+".translate") ($interp+".position");
	else  connectAttr ($group+".scale") ($interp+".position");
	x3dAEConnectTimerToInterp($timer, $interp, $field, "PositionInterpolator", "Transform", $group, ($group+"Parent"));
}

global proc x3dAEConnectOtherOriInter(string $group, string $timer, string $field, string $type)
{
	string $tPar[] = `listRelatives -p $timer`;
	string $interp = `createNode x3dOrientationInterpolator -p $tPar[0]`;
	connectAttr ($group+".rotate") ($interp+".orientation");
	x3dAEConnectTimerToInterp($timer, $interp, $field, "OrientationInterpolator", "Transform", $group, ($group+"Parent"));
}

global proc x3dAEConnectTimerToInterp(string $timer, string $interp, string $field, string $intType, string $type, string $group, string $x3dGroup)
{
	connectAttr -force ($timer+".keso") ($interp+".keso");
	connectAttr -force ($timer+".cycleInterval") ($interp+".secondLength");
	connectAttr -force ($timer+".fps") ($interp+".fps");
	connectAttr -force ($timer+".strf") ($interp+".strf");
	connectAttr -force ($timer+".stpf") ($interp+".stpf");
	x3dSetRouteDirectly($timer, "TimeSensor", $timer, "fraction_changed", $interp, "PositionInterpolator", $interp, "set_fraction");
	x3dSetRouteDirectly($interp, $intType, $interp, "value_changed", $group, $type, $x3dGroup, ("set_"+$field));
}

global proc x3dAEKesoChange()
{
	int $index[] = `textScrollList -q -sii x3dAETimerList`;
	if($index[0] > 0)
	{
		int $i = $index[0]-1;
		string $nodeNames[] = `ls -type x3dTimeSensor`;

		float $keso = `floatSliderGrp -q -value x3dAEKeso`;
		setAttr ($nodeNames[$i]+".keso") $keso;

		x3dAEGetTimeSensorValues($nodeNames[$i]);
	}
}

global proc x3dAEStartFrameChange()
{
	int $index[] = `textScrollList -q -sii x3dAETimerList`;
	if($index[0] > 0)
	{
		int $i = $index[0]-1;
		string $nodeNames[] = `ls -type x3dTimeSensor`;

		float $stf[] = `floatFieldGrp -q -value x3dAESTF`;
		setAttr ($nodeNames[$i]+".startFrame") $stf[0];

		x3dAEGetTimeSensorValues($nodeNames[$i]);
	}
}

global proc x3dAEStopFrameChange()
{
	int $index[] = `textScrollList -q -sii x3dAETimerList`;
	if($index[0] > 0)
	{
		int $i = $index[0]-1;
		string $nodeNames[] = `ls -type x3dTimeSensor`;

		float $spf[] = `floatFieldGrp -q -value x3dAESPF`;
		setAttr ($nodeNames[$i]+".stopFrame") $spf[0];

		x3dAEGetTimeSensorValues($nodeNames[$i]);
	}
}

global proc x3dAEFPSChange()
{
	int $index[] = `textScrollList -q -sii x3dAETimerList`;
	if($index[0] > 0)
	{
		int $i = $index[0]-1;
		string $nodeNames[] = `ls -type x3dTimeSensor`;

		int $fps = `intSliderGrp -q -value x3dAEFPS`;
		setAttr ($nodeNames[$i]+".fps") $fps;

		x3dAEGetTimeSensorValues($nodeNames[$i]);
	}
}

global proc x3dAEEnabledChange()
{
	int $index[] = `textScrollList -q -sii x3dAETimerList`;
	if($index[0] > 0)
	{
		int $i = $index[0]-1;
		string $nodeNames[] = `ls -type x3dTimeSensor`;

		int $ena = `checkBoxGrp -q -value1 x3dAEEN`;
		setAttr ($nodeNames[$i]+".enabled") $ena;

		x3dAEGetTimeSensorValues($nodeNames[$i]);
	}
}

global proc x3dAELoopChange()
{
	int $index[] = `textScrollList -q -sii x3dAETimerList`;
	if($index[0] > 0)
	{
		int $i = $index[0]-1;
		string $nodeNames[] = `ls -type x3dTimeSensor`;

		int $loo = `checkBoxGrp -q -value1 x3dAELoop`;
		setAttr ($nodeNames[$i]+".loop") $loo;

		x3dAEGetTimeSensorValues($nodeNames[$i]);
	}
}

global proc x3dAEGetTimeSensorValues(string $ts)
{
	float $keso = `getAttr ($ts+".keso")`;
	float $sta = `getAttr ($ts+".startFrame")`;
	float $sto = `getAttr ($ts+".stopFrame")`;
	int $fps = `getAttr ($ts+".fps")`;
	int $ena = `getAttr ($ts+".enabled")`;
	int $loo = `getAttr ($ts+".loop")`;
	float $cyi = `getAttr ($ts+".cycleInterval")`;
		
	floatSliderGrp -e -value $keso x3dAEKeso;
	floatFieldGrp -e -value1 $sta x3dAESTF;
	floatFieldGrp -e -value1 $sto x3dAESPF;
	floatFieldGrp -e -value1 $cyi x3dAECI;
	intSliderGrp -e -value $fps x3dAEFPS;
	checkBoxGrp -e -value1 $ena x3dAEEN;
	checkBoxGrp -e -value1 $loo x3dAELoop;
}

global proc x3dAEUpdateGroupList()
{
	textScrollList -e -ra x3dAEGroupList;
	global string $x3dAEsn[];
	int $i;
	for($i=0;$i<size($x3dAEsn);$i++)
	{
		x3dAEProcessGroupings($x3dAEsn[$i], 0);
	}
}

global proc x3dAECreateNewTimeSensor()
{
	string $ot[] = `ls -type "x3dTimeSensor"`;
	createX3DTimeSensors();
	x3dAEUpdateTimerList();
	string $nt[] = `ls -type "x3dTimeSensor"`;
	string $newTimer = "empty";
	
	int $searching = true;
	int $i = 0;
	while($searching == true && $i < size($nt))
	{
		int $j;
		int $jFound = false;
		for($j=0;$j<size($ot);$j++)
		{
			if($nt[$i] == $ot[$j]) $jFound = true;
		}
		if($jFound == false)
		{
			$newTimer = $nt[$i];
			$searching = false;
		}
		$i = $i + 1;
	}
	if($newTimer != "empty") textScrollList -e -si $newTimer x3dAETimerList;
	x3dAEUpdateTimerSettings();
}

global proc x3dAEProcessGroupings(string $grouping, int $tabs)
{
	int $hScale = false;
	int $hTrans = false;
	int $hRotate = false;
	string $timeSensor[] = `textScrollList -q -si x3dAETimerList`;
	string $scacon[];
	string $rotcon[];
	string $tracon[];
	int $i;
	int $isAvatar = x3dCheckGroupingForAvatar($grouping);
	$scacon = `listConnections -source false -destination true -p true ($grouping+".scale")`;
	if($isAvatar == false)
	{
		$rotcon = `listConnections -source false -destination true -p true ($grouping+".rotate")`;
		$tracon = `listConnections -source false -destination true -p true ($grouping+".translate")`;
	}
	for($i=0;$i<size($tracon);$i++)
	{
		string $chop[];
		tokenize($tracon[$i], ".", $chop);
		string $ntype = `nodeType $chop[0]`;
		if($ntype == "x3dPositionInterpolator")
		{
			string $timeCon[] = `listConnections -source true -destination false -p true ($chop[0]+".secondLength")`;
			if(size($timeCon) > 0)
			{
				string $tChop[];
				tokenize($timeCon[0], ".", $tChop);
				if($tChop[0] == $timeSensor[0]) $hTrans = true;
			}
		}
	}
	for($i=0;$i<size($rotcon);$i++)
	{
		string $chop[];
		tokenize($rotcon[$i], ".", $chop);
		string $ntype = `nodeType $chop[0]`;
		if($ntype == "x3dOrientationInterpolator")
		{
			string $timeCon[] = `listConnections -source true -destination false -p true ($chop[0]+".secondLength")`;
			if(size($timeCon) > 0)
			{
				string $tChop[];
				tokenize($timeCon[0], ".", $tChop);
				if($tChop[0] == $timeSensor[0]) $hRotate = true;
			}
		}
	}
	for($i=0;$i<size($scacon);$i++)
	{
		string $chop[];
		tokenize($scacon[$i], ".", $chop);
		string $ntype = `nodeType $chop[0]`;
		if($ntype == "x3dPositionInterpolator")
		{
			string $timeCon[] = `listConnections -source true -destination false -p true ($chop[0]+".secondLength")`;
			if(size($timeCon) > 0)
			{
				string $tChop[];
				tokenize($timeCon[0], ".", $tChop);
				if($tChop[0] == $timeSensor[0]) $hScale = true;
			}
		}
	}
	
	string $listString = "";
	for($i=0;$i<$tabs;$i++)
	{
		$listString = $listString + "     ";
	}
	$listString = $listString + $grouping;
	if($hTrans == true || $hRotate == true || $hScale == true)
	{
		$listString = $listString + ":";
		if($hTrans == true) $listString = $listString + " T";
		if($hRotate == true) $listString = $listString + " R";
		if($hScale == true) $listString = $listString + " S";
	}
	int $newTabs = $tabs + 1;
	textScrollList -e -append $listString x3dAEGroupList;
	
	string $tempRels[] = `listRelatives -c -type transform -type lodGroup -type x3dGroup -type x3dSwitch -type x3dCollision -type x3dAnchor -type x3dInline $grouping`;
	string $grRels[];

	int $j = 0;
	for($i=0;$i<size($tempRels);$i++)
	{
		int $iv = `getAttr ($tempRels[$i]+".intermediateObject")`;
		if($iv == false)
		{
			$grRels[$j] = $tempRels[$i];
			$j = $j + 1;
		}
	}
	for($i=0;$i<size($grRels);$i++)
	{
		x3dAEProcessGroupings($grRels[$i], $newTabs);
	}
}

global proc int x3dCheckGroupingForAvatar(string $grouping)
{
	int $isAvatar = false;
	string $rels[] = `listRelatives -c -type "joint" $grouping`;
	int $i;
	for($i=0;$i<size($rels);$i++)
	{
		int $isOI = false;
		$isOI = `getAttr ($rels[$i]+".intermediateObject")`;
		if($isOI == false) $isAvatar = true;
	}
	return $isAvatar;
}

//////////////////////////////////////////
//X3D Character Export Utility Proceedures
//////////////////////////////////////////

global proc x3dCharacterEditor()
{
	string $x3dCE = `window -title "X3D Character Editor" -s true -width 400 -height 450`;
		window -e -mnc ("deleteUI -window " + $x3dCE) $x3dCE;
		columnLayout;
			rowLayout -nc 3 -cw3 90 150 150 -columnAlign  1 "left"
		    	-columnAttach 1 "both" 	2
		    	-columnAttach 2 "both"  2
		    	-columnAttach 3 "both"  2;
				text -label "TimeSensors" -fn "boldLabelFont";
				text -label "Associated Characters" -fn "boldLabelFont";
				text -label "Unassociated Characters" -fn "boldLabelFont";
			setParent ..;
	
			rowLayout -nc 3 -cw3 90 150 150 -columnAlign  1 "left"
		    	-columnAttach 1 "both" 	2
		    	-columnAttach 2 "both"  2
		    	-columnAttach 3 "both"  2;
				string $timerList = `textScrollList -nr 4 -ams false -sc "x3dUpdateCEForTimer" "x3dCETimerList"`;
				string $timerCharList = `textScrollList -nr 4 -ams false -sc "x3dDisplayHumanoid" "x3dCETimerCharList"`;
				string $charList = `textScrollList -nr 4 -ams true "x3dCECharList"`;
			setParent ..;
			rowLayout -nc 1 -cw1 390;
				text -label "          ";
			setParent ..;
			rowLayout -nc 1 -cw1 390 -columnAlign  1 "left"
		    	-columnAttach 1 "both" 2;
				text -label "Character Joints" -fn "boldLabelFont";
			setParent ..;
			rowLayout -nc 1 -cw1 390 -columnAlign  1 "left"
		    	-columnAttach 1 "both" 2;
				string $humanoidList = `textScrollList -nr 8 -ams true "x3dCEHumanList"`;
			setParent ..;
			rowLayout -nc 1 -cw1 390;
				text -label "          ";
			setParent ..;
			rowLayout -nc 1 -cw1 390 -columnAlign  1 "left"
		    	-columnAttach 1 "both" 2;
				text -label "TimeSensor Settings" -fn "boldLabelFont";
			setParent ..;
			rowLayout -nc 1 -cw1 390 -columnAlign  1 "left"
		    	-columnAttach 1 "both" 2;
				columnLayout;
					string $keso = `floatSliderGrp -label "  Key Every So Many Frames" -field true -minValue 1.0 -maxValue 100.0 -fieldMinValue 1.0 -fieldMaxValue 100.0 -value 1 -cc "x3dKesoChange" x3dCEKeso`;
					string $str = `floatFieldGrp -label "Start Frame" -cc "x3dStartFrameChange" x3dCESTF`;
					string $sto = `floatFieldGrp -label "Stop Frame" -cc "x3dStopFrameChange" x3dCESPF`;
					string $fps = `intSliderGrp -label "Frames Per Second" -field true -minValue 1.0 -maxValue 60.0 -fieldMinValue 1.0 -fieldMaxValue 60.0 -value 30 -cc "x3dFPSChange" x3dCEFPS`;
					string $cyi = `floatFieldGrp -label "CycleInterval" -en false x3dCECI`;
					string $ena = `checkBoxGrp -numberOfCheckBoxes 1 -label "Enabled" -value1 true -cc "x3dEnabledChange" x3dCEEN`;
					string $loo = `checkBoxGrp -numberOfCheckBoxes 1 -label "Loop" -cc "x3dLoopChange" x3dCELoop`;
				setParent ..;
			setParent ..;
			rowLayout -nc 1 -cw1 390;
				text -label "          ";
			setParent ..;

////////////
			
			string $ceMenu = `popupMenu -parent $humanoidList`;
			string $cem1 = `menuItem -l "None" -p $ceMenu -c "x3dNoJointAnimation"`;
			string $cem2 = `menuItem -l "Translate" -p $ceMenu -c "x3dTranslateAnimation"`;
			string $cem3 = `menuItem -l "Rotate" -p $ceMenu -c "x3dRotateAnimation"`;
			string $cem4 = `menuItem -l "Both" -p $ceMenu -c "x3dTandRAnimation"`;
		
			string $ceAssMenu = `popupMenu -parent $timerCharList`;
			string $cea1 = `menuItem -l "Unassign Selected Character" -p $ceAssMenu -c "x3dUpdateAssignedChars"`;
			menuItem -d true -p $ceAssMenu;
			menuItem -d true -p $ceAssMenu;
			string $cea2 = `menuItem -l "Mend Selected Character" -p $ceAssMenu -c "x3dCEMendCharacters"`;

			string $ceUnassMenu = `popupMenu -parent $charList`;
			string $ceu1 = `menuItem -l "Assign Selected Character" -p $ceUnassMenu -c "x3dUpdateUnassignedChars"`;

			string $ceCreateTimerMenu = `popupMenu -parent $timerList`;
			string $cec1 = `menuItem -l "Create New TimeSensor" -p $ceCreateTimerMenu -c "x3dCECreateNewTimeSensor"`;

			x3dCEUpdateTimerList();
	showWindow $x3dCE;
}

global proc x3dCECreateNewTimeSensor()
{
	string $ot[] = `ls -type "x3dTimeSensor"`;
	createX3DTimeSensors();
	x3dCEUpdateTimerList();
	string $nt[] = `ls -type "x3dTimeSensor"`;
	string $newTimer = "empty";
	
	int $searching = true;
	int $i = 0;
	while($searching == true && $i < size($nt))
	{
		int $j;
		int $jFound = false;
		for($j=0;$j<size($ot);$j++)
		{
			if($nt[$i] == $ot[$j]) $jFound = true;
		}
		if($jFound == false)
		{
			$newTimer = $nt[$i];
			$searching = false;
		}
		$i = $i + 1;
	}
	if($newTimer != "empty") textScrollList -e -si $newTimer x3dCETimerList;
	x3dUpdateCEForTimer();
}

global proc x3dCEMendCharacters()
{
	string $characters[] = `textScrollList -q -si x3dCETimerCharList`;
	if(size($characters) > 0)
	{
		int $i;
		for($i=0;$i<size($characters);$i++)
		{
			x3dMend($characters[$i]);			
		}
	}
	else warning("You must select both a timer and one or more characters.");
}

global proc x3dCEUpdateTimerList()
{
	textScrollList -e -ra x3dCETimerList;
	string $timesensors[] = `ls -type "x3dTimeSensor"`;
	int $i;
	for($i=0;$i<size($timesensors);$i++)
	{
		textScrollList -e -append $timesensors[$i] x3dCETimerList;
	}
}

global proc x3dSkeletonSetup(string $avatar)
{
	if(!`attributeExists "hasIOJoints" $avatar`)
	{
		addAttr -longName "hasIOJoints" -at bool $avatar;

//		float $cTime = `currentTime -q`;

		//*********************
		//New Code Aug 10, 2007
		//*********************
		//Get all joint nodes that are immediate children of this Transform Node
		string $childJoints[] = `listRelatives -c -type "joint" $avatar`;

		//Array that holds all root joints that are not IntermediateObjects
		string $rootJoints[];

		//Array that holds all root joints that are IntermediateObjects
		string $ghostRootJoints[];

		print "just after ghostrootjoints\n";

		int $i;
		int $cjays = size($childJoints);
		int $j=0;
		int $k=0;

		//Sort immediate joint children into io and non-io arrays
		for($i=0; $i<$cjays; $i++)
		{
			int $isIO = `getAttr ($childJoints[$i]+".intermediateObject")`;
			if($isIO == true)
			{
				$ghostRootJoints[$j] = $childJoints[$i];
				$j = $j+1;
			}
			else
			{
				$rootJoints[$k] = $childJoints[$i];
				$k = $k+1;
			}
		}
		
		print "just before rootJoints\n";//aaron

		$k = size($rootJoints);
		$j = size($ghostRootJoints);
		int $flarp = 1;
		if(size($rootJoints) > 0 && size($ghostRootJoints) == 0 && $flarp==true)
		{
			for($i=0;$i<$k;$i++)
			{
				$ghostRootJoints[$i] = x3dJointSetupDuplicator($rootJoints[$i]);
			}
			$j=size($ghostRootJoints);
			for($i=0;$i<$j;$i++)
			{
				x3dRecursiveGhostMakeIdentity($ghostRootJoints[$i]);
			}
			for($i=0;$i<$j;$i++)
			{
				x3dRecursiveGhostConstraintSetup($ghostRootJoints[$i], $rootJoints[$i]);
			}
			
			string $sClusters[];
			$j=0;

			print "just after sclusters\n";
			for($i=0;$i<$k;$i++)
			{
print "0\n";
				string $tNodes[] = `connectionInfo -destinationFromSource ($rootJoints[$i]+".lockInfluenceWeights")`;
				int $l;
				int $m = size($tNodes);
print "1\n";
				for($l=0;$l<$m;$l++)
				{
print "2\n";
					string $chop[];
					tokenize($tNodes[$l], ".", $chop);
					string $nt = `nodeType $chop[0]`;
					if($nt == "skinCluster")
					{
print "3\n";
						$sClusters[$j] = $chop[0];
						$j = $j+1;
					}
				}
			}
print "4\n";
			string $meshes[];
			$j=0;
			$k=size($sClusters);
print "5\n";
			for($i=0;$i<$k;$i++)
			{
print "6\n";
				string $tMesh[] = `connectionInfo -destinationFromSource ($sClusters[$i]+".outputGeometry[0]")`;
				int $l;
				int $m = size($tMesh);
print "7\n";
				for($l=0;$l<$m;$l++)
				{
print "8\n";
					string $chop[];
					tokenize($tMesh[$l], ".", $chop);
//					$meshes[$j] = $tMesh[$l];
					$meshes[$j] = $chop[0];
					$j=$j+1;
				}
print "9\n";
			}
print "10\n";
			string $nTrans[];
			$k=size($meshes);
print "11\n";
			for($i=0;$i<$k;$i++)
			{
print "12\n";
				string $tmp[] = `duplicate -rr -renameChildren $meshes[$i]`;
print "13\n";
				$nTrans[$i] = $tmp[0];
print "14\n";
print ($meshes[$i]+" --\n");
print ($tmp[0]+" --\n");
print ($nTrans[$i]+" --\n");
				string $nMeshes[] = `listRelatives -c -type "mesh" $nTrans[$i]`;
print "15\n";
				int $n;
print "16\n";
				int $o = size($nMeshes);
print "17\n";
				for($n=0;$n<$o;$n++)
				{
print "18\n";
					if(`getAttr ($nMeshes[$n]+".intermediateObject")`)
					{
print "19\n";
						delete $nMeshes[$n];
					}
				}
print "20\n";
				$nMeshes = `listRelatives -c -type "mesh" $nTrans[$i]`;
print "21\n";
				addAttr -longName "x3dSkinIn" -hidden true -at bool -w true -r false $nMeshes[0];
print "22\n";
				addAttr -longName "x3dSkinOut" -hidden true -at bool -w false -r true $meshes[$i];
print "23\n";
				connectAttr ($meshes[$i]+".x3dSkinOut") ($nMeshes[0]+".x3dSkinIn");
print "24\n";
				setAttr ($nTrans[$i]+".intermediateObject") true;
print "25\n";
			}
print "26\n";
		}
print "27\n";
		//*********************
		//New Code End
		//*********************
/*
		currentTime -e 0;
		string $rootJoint[] = `listRelatives -c -type "joint" $avatar`;
		int $isIO = `getAttr ($rootJoint[0]+".intermediateObject")`;
		if(size($rootJoint) > 0 && $isIO == false)
		{
			addAttr -longName "hasIOJoints" -at bool $avatar;

			string $jInters[] = `duplicate -rr -renameChildren $rootJoint[0]`;//lockInfluenceWeights
			
			makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 -jointOrient $jInters[0];
			setAttr ($jInters[0]+".intermediateObject") true;
			orientConstraint -mo -weight 1 $rootJoint[0] $jInters[0];
			pointConstraint -offset 0 0 0 -weight 1 $rootJoint[0] $jInters[0];
			string $ioRoot = "hanim_"+$rootJoint[0];
			rename $jInters[0] $ioRoot;
			
			float $nhVal[] = {0.0, 0.0, 0.0};
			$nhVal[0] = `getAttr ($ioRoot+".translateX")`;
			$nhVal[1] = `getAttr ($ioRoot+".translateY")`;
			$nhVal[2] = `getAttr ($ioRoot+".translateZ")`;
			
			setAttr ($ioRoot+".htrx") $nhVal[0];
			setAttr ($ioRoot+".htry") $nhVal[1];
			setAttr ($ioRoot+".htrz") $nhVal[2];
			x3dJointConstraintSetup($rootJoint[0], $ioRoot);

		}
		
		currentTime -e $cTime;
*/
	print "through skeleton setup\n";
	}
}

//*********************
//New Code Aug 10, 2007
//*********************
//This procedure creates a duplicate of a root joint for use as a
//ghost root joint
global proc string x3dJointSetupDuplicator(string $rootJoint)
{
	string $ghoster[] = `duplicate -rr -renameChildren $rootJoint`;
	return $ghoster[0];
}
//*********************
//New Code End
//*********************

//*********************
//New Code Aug 10, 2007 - a
//*********************
//This procedure sets all of decendents of this ghost branch to
//the identity for the rotate and JointOrient attributes, and 
//shifts the translate attribute to the appropriate location.
global proc x3dRecursiveGhostMakeIdentity(string $ghostJoint)
{
	makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 -jointOrient $ghostJoint;
	setAttr ($ghostJoint+".intermediateObject") true;
//	string $aType = `getAttr -type ($ghostJoint+".translate")`;
//	print $aType;
	float $tv[] = `getAttr ($ghostJoint+".translate")`;
	addAttr -longName "hanimCenter" -at double3 $ghostJoint;
	addAttr -longName x -at double -parent hanimCenter $ghostJoint;
	addAttr -longName y -at double -parent hanimCenter $ghostJoint;
	addAttr -longName z -at double -parent hanimCenter $ghostJoint;
	setAttr ($ghostJoint+".hanimCenter") -type double3 $tv[0] $tv[1] $tv[2];
	string $childJoints[] = `listRelatives -c -type "joint" $ghostJoint`;
	int $i;
	int $j = size($childJoints);
	for($i=0;$i<$j;$i++) x3dRecursiveGhostMakeIdentity($childJoints[$i]);
}
//*********************
//New Code End
//*********************

//*********************
//New Code Aug 10, 2007 - b
//*********************
//This procedure for renaming and setting the contraints on
//the ghost joints
global proc x3dRecursiveGhostConstraintSetup(string $gJoint, string $rJoint)
{
	//setAttr ($gJoint+".intermediateObject") true;
	string $gRel[] = `listRelatives -type "joint" -c $gJoint`;
	string $rRel[] = `listRelatives -type "joint" -c $rJoint`;
	string $newName = "hanim_"+$rJoint;
	rename $gJoint $newName;
	orientConstraint -mo -weight 1 $rJoint $newName;
	pointConstraint -offset 0 0 0 -weight 1 $rJoint $newName;
	int $i;
	int $j = size($gRel);
	for($i=0;$i<$j;$i++) x3dRecursiveGhostConstraintSetup($gRel[$i], $rRel[$i]);
}
//*********************
//New Code End
//*********************



//global proc x3dJointConstraintSetup(string $pcer, string $pcee, float $hVal[])
global proc x3dJointConstraintSetup(string $pcer, string $pcee)
{
	string $pceeRel[] = `listRelatives -type "joint" -c $pcee`;
	string $pcerRel[] = `listRelatives -type "joint" -c $pcer`;

	int $i;
	for($i=0; $i<size($pceeRel);$i++)
	{
		string $newName = "hanim_"+$pcerRel[$i];
		rename $pceeRel[$i] $newName;
		setAttr ($newName+".intermediateObject") true;
		orientConstraint -mo -weight 1 $pcerRel[$i] $newName;
		pointConstraint -offset 0 0 0 -weight 1 $pcerRel[$i] $newName;

		float $nhVal[] = {0.0, 0.0, 0.0};
		$nhVal[0] = `getAttr ($newName+".translateX")`;
		$nhVal[1] = `getAttr ($newName+".translateY")`;
		$nhVal[2] = `getAttr ($newName+".translateZ")`;
		
		setAttr ($newName+".htrx") $nhVal[0];
		setAttr ($newName+".htry") $nhVal[1];
		setAttr ($newName+".htrz") $nhVal[2];

		x3dJointConstraintSetup($pcerRel[$i], $newName);
	}
}

global proc string[] x3dGetCharacters()
{
	string $characters[];
	string $transforms[] = `ls -et "transform"`;
	int $j;
	for($j=0;$j<size($transforms);$j++)
	{
		string $relatives[] = `listRelatives -c -type "joint" $transforms[$j]`;
		int $hasSkeleton = false;
		int $i;
		for($i=0;$i<size($relatives);$i++)
		{
			int $io = `getAttr ($relatives[$i]+".intermediateObject")`;
			if($io == 0) $hasSkeleton = true;
		}
		int $size = size($characters);
		if($hasSkeleton == true) $characters[$size] = $transforms[$j];
	}
	return $characters;
}

global proc x3dUpdateUnassignedChars()
{
	string $characters[] = x3dGetCharacters();
	string $assChar[];
	string $unassChar[];
	
	int $index[] = `textScrollList -q -sii x3dCETimerList`;
	if($index[0] > 0)
	{
		int $i = $index[0]-1;
		string $nodeNames[] = `ls -type x3dTimeSensor`;
		int $cs = `getAttr ($nodeNames[$i]+".charSize")`;
		int $k;
		int $m = 0;
		for($k=0;$k<size($characters);$k++)
		{
			int $l;
			for($l=0; $l<$cs;$l++)
			{
				if($characters[$k] == `getAttr ($nodeNames[$i]+".character"+$l)`)
				{
					$assChar[$m] = $characters[$k];
					$m=$m+1;
				}
			}
		}
		int $n=0;
		for($k=0;$k<size($characters);$k++)
		{
			int $found=false;
			int $l;
			for($l=0;$l<$m;$l++)
			{
				if($characters[$k] == $assChar[$l]) $found = true;
			}
			if($found == false) $unassChar[$n] = $characters[$k];
			$n=$n+1;
		}
		int $index2[] = `textScrollList -q -sii x3dCECharList`;
		if($index2[0] > 0)
		{
			int $p = $index2[0]-1;
			addAttr -longName ("character"+$cs) -dt "string" $nodeNames[$i];
			setAttr -type "string" ($nodeNames[$i]+".character"+$cs) $unassChar[$p];
			$cs = $cs+1;
			setAttr ($nodeNames[$i]+".charSize") $cs;
		}
		x3dUpdateCEForTimer();
	}
}

global proc x3dUpdateAssignedChars()
{
	textScrollList -e -ra x3dCEHumanList;
	string $characters[] = x3dGetCharacters();
	string $assChar[];
	string $unassChar[];
	string $remChar = "empty";
	
	int $index[] = `textScrollList -q -sii x3dCETimerList`;
	if($index[0] > 0)
	{
		int $i = $index[0]-1;
		string $nodeNames[] = `ls -type x3dTimeSensor`;
		int $cs = `getAttr ($nodeNames[$i]+".charSize")`;
		int $k;
		int $m = 0;
		for($k=0;$k<size($characters);$k++)
		{
			int $l;
			for($l=0; $l<$cs;$l++)
			{
				if($characters[$k] == `getAttr ($nodeNames[$i]+".character"+$l)`)
				{
					$assChar[$m] = $characters[$k];
					$m=$m+1;
				}
			}
		}
		int $index2[] = `textScrollList -q -sii x3dCETimerCharList`;
		if($index2[0] > 0)
		{
			int $p = $index2[0]-1;
			string $tempAssChar[];
			int $q;
			int $r = 0;
			for($q=0;$q<size($assChar);$q++)
			{
				if($assChar[$q] != `getAttr ($nodeNames[$i]+".character"+$p)`)
				{
					$tempAssChar[$r] = $assChar[$r];
					$r = $r+1;
				}
				else $remChar = $assChar[$q];
			}
			$assChar = $tempAssChar;
			$cs = $cs - 1;
			deleteAttr ($nodeNames[$i]+".character"+$cs);
			setAttr ($nodeNames[$i]+".charSize") $cs;
		}

		int $n=0;
		for($k=0;$k<size($characters);$k++)
		{
			int $found=false;
			int $l;
			for($l=0;$l<$m;$l++)
			{
				if($characters[$k] == $assChar[$l]) $found = true;
			}
			if($found == false) $unassChar[$n] = $characters[$k];
			$n=$n+1;
		}
		if($remChar != "empty") x3dRemoveCharTimerSettings($remChar, $nodeNames[$i]);
		x3dUpdateCEForTimer();
	}
}

global proc x3dRemoveCharTimerSettings(string $node, string $timer)
{
	if(`attributeExists ($timer+"_Pos") $node`) deleteAttr ($node+"."+$timer+"_Pos");
	if(`attributeExists ($timer+"_Ori") $node`) deleteAttr ($node+"."+$timer+"_Ori");
	string $posName = "pos_"+$node+"_"+$timer;
	string $oriName = "ori_"+$node+"_"+$timer;
	if(`objExists $posName`) delete $posName;
	if(`objExists $oriName`) delete $oriName;

	string $joints[] = `listRelatives -c -type "joint" $node`;
	int $i;
	for($i=0;$i<size($joints);$i++)
	{
		int $isIO = `getAttr ($joints[$i]+".intermediateObject")`;
		if($isIO == false) x3dRemoveCharTimerSettings($joints[$i], $timer);
	}
}

global proc x3dKesoChange()
{
	int $index[] = `textScrollList -q -sii x3dCETimerList`;
	if($index[0] > 0)
	{
		int $i = $index[0]-1;
		string $nodeNames[] = `ls -type x3dTimeSensor`;

		float $keso = `floatSliderGrp -q -value x3dCEKeso`;
		setAttr ($nodeNames[$i]+".keso") $keso;

		x3dGetTimeSensorValues($nodeNames[$i]);
	}
}

global proc x3dStartFrameChange()
{
	int $index[] = `textScrollList -q -sii x3dCETimerList`;
	if($index[0] > 0)
	{
		int $i = $index[0]-1;
		string $nodeNames[] = `ls -type x3dTimeSensor`;

		float $stf[] = `floatFieldGrp -q -value x3dCESTF`;
		setAttr ($nodeNames[$i]+".startFrame") $stf[0];

		x3dGetTimeSensorValues($nodeNames[$i]);
	}
}

global proc x3dStopFrameChange()
{
	int $index[] = `textScrollList -q -sii x3dCETimerList`;
	if($index[0] > 0)
	{
		int $i = $index[0]-1;
		string $nodeNames[] = `ls -type x3dTimeSensor`;

		float $spf[] = `floatFieldGrp -q -value x3dCESPF`;
		setAttr ($nodeNames[$i]+".stopFrame") $spf[0];

		x3dGetTimeSensorValues($nodeNames[$i]);
	}
}

global proc x3dFPSChange()
{
	int $index[] = `textScrollList -q -sii x3dCETimerList`;
	if($index[0] > 0)
	{
		int $i = $index[0]-1;
		string $nodeNames[] = `ls -type x3dTimeSensor`;

		int $fps = `intSliderGrp -q -value x3dCEFPS`;
		setAttr ($nodeNames[$i]+".fps") $fps;

		x3dGetTimeSensorValues($nodeNames[$i]);
	}
}

global proc x3dEnabledChange()
{
	int $index[] = `textScrollList -q -sii x3dCETimerList`;
	if($index[0] > 0)
	{
		int $i = $index[0]-1;
		string $nodeNames[] = `ls -type x3dTimeSensor`;

		int $ena = `checkBoxGrp -q -value1 x3dCEEN`;
		setAttr ($nodeNames[$i]+".enabled") $ena;

		x3dGetTimeSensorValues($nodeNames[$i]);
	}
}

global proc x3dLoopChange()
{
	int $index[] = `textScrollList -q -sii x3dCETimerList`;
	if($index[0] > 0)
	{
		int $i = $index[0]-1;
		string $nodeNames[] = `ls -type x3dTimeSensor`;

		int $loo = `checkBoxGrp -q -value1 x3dCELoop`;
		setAttr ($nodeNames[$i]+".loop") $loo;

		x3dGetTimeSensorValues($nodeNames[$i]);
	}
}

global proc x3dGetTimeSensorValues(string $ts)
{
	float $keso = `getAttr ($ts+".keso")`;
	float $sta = `getAttr ($ts+".startFrame")`;
	float $sto = `getAttr ($ts+".stopFrame")`;
	int $fps = `getAttr ($ts+".fps")`;
	int $ena = `getAttr ($ts+".enabled")`;
	int $loo = `getAttr ($ts+".loop")`;
	float $cyi = `getAttr ($ts+".cycleInterval")`;
		
	floatSliderGrp -e -value $keso x3dCEKeso;
	floatFieldGrp -e -value1 $sta x3dCESTF;
	floatFieldGrp -e -value1 $sto x3dCESPF;
	floatFieldGrp -e -value1 $cyi x3dCECI;
	intSliderGrp -e -value $fps x3dCEFPS;
	checkBoxGrp -e -value1 $ena x3dCEEN;
	checkBoxGrp -e -value1 $loo x3dCELoop;

}

global proc x3dUpdateCEForTimer()
{
	int $index[] = `textScrollList -q -sii x3dCETimerList`;
	if($index[0] > 0)
	{
		textScrollList -e -ra x3dCETimerCharList;
		textScrollList -e -ra x3dCECharList;
		int $i = $index[0]-1;
		string $nodeNames[] = `ls -type x3dTimeSensor`;
		
		x3dGetTimeSensorValues($nodeNames[$i]);
		
		string $characters[] = x3dGetCharacters();
		string $assChar[];
		string $unassChar[];
			
		if(`attributeExists "charSize" $nodeNames[$i]`)
		{
			int $cs = `getAttr ($nodeNames[$i]+".charSize")`;
			int $k;
			int $m = 0;
			for($k=0;$k<size($characters);$k++)
			{
				int $l;
				for($l=0; $l<$cs;$l++)
				{
					if($characters[$k] == `getAttr ($nodeNames[$i]+".character"+$l)`)
					{
						$assChar[$m] = $characters[$k];
						$m=$m+1;
					}
				}
			}
			int $n=0;
			for($k=0;$k<size($characters);$k++)
			{
				int $found=false;
				int $l;
				for($l=0;$l<$m;$l++)
				{
					if($characters[$k] == $assChar[$l]) $found = true;
				}
				if($found == false) $unassChar[$n] = $characters[$k];
				$n=$n+1;
			}
		}
		else
		{
			addAttr -longName "charSize" -hidden true -at short $nodeNames[$i];
			setAttr ($nodeNames[$i]+".charSize") 0;
			string $characters[] = x3dGetCharacters();
			for($k=0;$k<size($characters);$k++) $unassChar[$k] = $characters[$k];
		}
		int $o;
		for($o=0;$o<size($assChar);$o++) textScrollList -e -append $assChar[$o] x3dCETimerCharList;
		for($o=0;$o<size($unassChar);$o++) textScrollList -e -append $unassChar[$o] x3dCECharList;
	}
}

global proc x3dDisplayHumanoid()
{
	int $index[] = `textScrollList -q -sii x3dCETimerList`;
	if($index[0] > 0)
	{
		string $nodeNames[] = `ls -type x3dTimeSensor`;
		string $characters[] = x3dGetCharacters();
		string $assChar[];
		string $unassChar[];
		
		string $timer;
		string $avatar;

		int $i = $index[0]-1;

		int $cs = `getAttr ($nodeNames[$i]+".charSize")`;
		int $k;
		int $m = 0;

		for($k=0;$k<size($characters);$k++)
		{
			int $l;
			for($l=0; $l<$cs;$l++)
			{
				if($characters[$k] == `getAttr ($nodeNames[$i]+".character"+$l)`)
				{
					$assChar[$m] = $characters[$k];
					$m=$m+1;
				}
			}
		}

		print "After first size\n";
	     	int $index1[] = `textScrollList -q -sii x3dCETimerCharList`;
     		if($index1[0] > 0)
	     	{
			int $j = $index1[0]-1;
			
			string $nodelist = $assChar[$j];
			print "Before skel setup\n";

			if(!`attributeExists "hasIOJoints" $assChar[$j]`) x3dSkeletonSetup($assChar[$j]);

			print "After skel setup\n";

			int $tFound = false;
			int $rFound = false;
			if(`attributeExists ($nodeNames[$i]+"_Pos") $assChar[$j]`) $tFound = true;
			if(`attributeExists ($nodeNames[$i]+"_Ori") $assChar[$j]`) $rFound = true;
			if($tFound == true || $rFound == true)
			{
				$nodelist = $nodelist + " -";
				if($tFound) $nodelist = $nodelist + " T";
				if($rFound) $nodelist = $nodelist + " R"; 
			}

			textScrollList -e -ra x3dCEHumanList;
			textScrollList -e -append $nodelist x3dCEHumanList;

			x3dSkeletonList($assChar[$j], $nodeNames[$i], 0);

			$avatar = $assChar[$j];
			$timer = $nodeNames[$i];
			x3dBuildCharacterInterpolators($timer, $avatar);
			//print("I displayed 1650\n"); return;

		}
	}
}

global proc x3dSkeletonList(string $parent, string $timer, int $tabs)
{
	int $newtabs = $tabs + 1;
	string $children[] = `listRelatives -c -type "joint" $parent`;
	int $i;
	for($i=0;$i<size($children);$i++)
	{
		int $isIO = `getAttr ($children[$i]+".intermediateObject")`;
		if($isIO == false)
		{
			string $nodelist = "";
			int$j;
			for($j=0; $j<$newtabs; $j++) $nodelist = $nodelist + "     ";

			$nodelist = $nodelist + $children[$i];

			int $tFound = false;
			int $rFound = false;
			if(`attributeExists ($timer+"_Pos") $children[$i]`) $tFound = true;
			if(`attributeExists ($timer+"_Ori") $children[$i]`) $rFound = true;
			if($tFound == true || $rFound == true)
			{
				$nodelist = $nodelist + " -";
				if($tFound) $nodelist = $nodelist + " T";
				if($rFound) $nodelist = $nodelist + " R"; 
			}

			textScrollList -e -append $nodelist x3dCEHumanList;
			x3dSkeletonList($children[$i], $timer, $newtabs);
		}
	}
}

global proc x3dBuildCharacterInterpolators(string $timer, string $avatar)
{
	string $tTrans[] = `listRelatives -p $timer`;
	string $pNode = $tTrans[0];
	string $posName = "pos_"+$avatar+"_"+$timer;
//	string $expName = "posexp_"+$avatar+"_"+$timer;
	string $oriName = "ori_"+$avatar+"_"+$timer;

	if(`attributeExists ($timer+"_Pos") $avatar`)
	{
		if(`objExists $posName`) delete $posName;

		string $nPosName = `createNode "x3dPositionInterpolator" -n $posName -p $pNode`;
//		string $expScript = "float $tx = "+$avatar+".translateX;\nfloat $ty = "+$avatar+".translateY;\nfloat $tz = "+$avatar+".translateZ;\n\nfloat $tx1 = "+$avatar+".hTranslateX;\nfloat $ty1 = "+$avatar+".hTranslateY;\nfloat $tz1 = "+$avatar+".hTranslateZ;\n\n$tx = $tx - $tx1;\n$ty = $ty - $ty1;\n$tz = $tz - $tz1;\n\n"+$nPosName+".positionX = $tx;\n"+$nPosName+".positionY = $ty;\n"+$nPosName+".positionZ = $tz;";
//		expression -s $expScript -n $expName -ae true -uc none;
		connectAttr -force ($timer+".keso") ($nPosName+".keso");
		connectAttr -force ($timer+".cycleInterval") ($nPosName+".secondLength");
		connectAttr -force ($timer+".fps") ($nPosName+".fps");
		connectAttr -force ($timer+".strf") ($nPosName+".strf");
		connectAttr -force ($timer+".stpf") ($nPosName+".stpf");
		connectAttr ($avatar+".translate") ($nPosName+".position");
		x3dSetRouteDirectly($timer, "TimeSensor", $timer, "fraction_changed", $nPosName, "PositionInterpolator", $nPosName, "set_fraction");
		x3dSetRouteDirectly($nPosName, "PositionInterpolator", $nPosName, "value_changed", $avatar, "HAnimHumanoid", $avatar, "set_translation");
	}
	else if(`objExists $posName`)
	{
		 delete $posName;
	}

	if(`attributeExists ($timer+"_Ori") $avatar`)
	{
		if(`objExists $oriName`) 
		{

			//print("I displayed 1723\n");
			delete $oriName;
			//print("I displayed 1725\n"); return;

		}

		string $nOriName = `createNode "x3dOrientationInterpolator" -n $oriName -p $pNode`;
		connectAttr -force ($timer+".keso") ($nOriName+".keso");
		connectAttr -force ($timer+".cycleInterval") ($nOriName+".secondLength");
		connectAttr -force ($timer+".fps") ($nOriName+".fps");
		connectAttr -force ($timer+".strf") ($nOriName+".strf");
		connectAttr -force ($timer+".stpf") ($nOriName+".stpf");
		connectAttr ($avatar+".rotate") ($nOriName+".orientation");
		x3dSetRouteDirectly($timer, "TimeSensor", $timer, "fraction_changed", $nOriName, "OrientationInterpolator", $nOriName, "set_fraction");
		x3dSetRouteDirectly($nOriName, "OrientationInterpolator", $nOriName, "value_changed", $avatar, "HAnimHumanoid", $avatar, "set_rotation");
	}
	else if(`objExists $oriName`) delete $oriName;

	string $joints[] = `listRelatives -c -type "joint" $avatar`;
	int $i;
	for($i=0;$i<size($joints);$i++)
	{
		int $isIO = `getAttr ($joints[$i]+".intermediateObject")`;
		if($isIO == false) x3dJointInterpolatorSetup($timer, $joints[$i], $avatar);
	}

}

global proc x3dJointInterpolatorSetup(string $timer, string $joint, string $avatar)
{
	string $tTrans[] = `listRelatives -p $timer`;
	string $pNode = $tTrans[0];
	string $posName = "pos_"+$joint+"_"+$timer;
	string $expName = "posexp_"+$joint+"_"+$timer;
	string $oriName = "ori_"+$joint+"_"+$timer;
	string $x3dJointName = $avatar+"_x_"+$joint;
	string $ghostJoint = "hanim_"+$joint;

	if(`objExists $ghostJoint`)
	{
       	if(`attributeExists ($timer+"_Pos") $joint`)
       	{
			if(`objExists $expName`) delete $expName;
       		if(`objExists $posName`) delete $posName;

       			string $nPosName = `createNode "x3dPositionInterpolator" -n $posName -p $pNode`;
		 		string $expScript = "//*"+$ghostJoint+"*"+$nPosName+"*\nfloat $tx = "+$ghostJoint+".translateX;\nfloat $ty = "+$ghostJoint+".translateY;\nfloat $tz = "+$ghostJoint+".translateZ;\n\nfloat $tx1 = "+$ghostJoint+".hTranslateX;\nfloat $ty1 = "+$ghostJoint+".hTranslateY;\nfloat $tz1 = "+$ghostJoint+".hTranslateZ;\n\n$tx = $tx - $tx1;\n$ty = $ty - $ty1;\n$tz = $tz - $tz1;\n\n"+$nPosName+".positionX = $tx;\n"+$nPosName+".positionY = $ty;\n"+$nPosName+".positionZ = $tz;";
				expression -s $expScript -n $expName -ae true -uc none;
     				connectAttr -force ($timer+".keso") ($nPosName+".keso");
       			connectAttr -force ($timer+".cycleInterval") ($nPosName+".secondLength");
       			connectAttr -force ($timer+".fps") ($nPosName+".fps");
       			connectAttr -force ($timer+".strf") ($nPosName+".strf");
       			connectAttr -force ($timer+".stpf") ($nPosName+".stpf");
//       			connectAttr ($ghostJoint+".translate") ($nPosName+".position");
       			x3dSetRouteDirectly($timer, "TimeSensor", $timer, "fraction_changed", $nPosName, "PositionInterpolator", $nPosName, "set_fraction");
       			x3dSetRouteDirectly($nPosName, "PositionInterpolator", $nPosName, "value_changed", $joint, "HAnimJoint", $x3dJointName, "set_translation");
       	}else if(`objExists $posName`)
		{
			if(`objExists $expName`) delete $expName;
			delete $posName;
		}

       	if(`attributeExists ($timer+"_Ori") $joint`)
       	{
       		if(`objExists $oriName`) delete $oriName;

       			string $nOriName = `createNode "x3dOrientationInterpolator" -n $oriName -p $pNode`;
       			connectAttr -force ($timer+".keso") ($nOriName+".keso");
       			connectAttr -force ($timer+".cycleInterval") ($nOriName+".secondLength");
       			connectAttr -force ($timer+".fps") ($nOriName+".fps");
       			connectAttr -force ($timer+".strf") ($nOriName+".strf");
       			connectAttr -force ($timer+".stpf") ($nOriName+".stpf");
       			connectAttr ($ghostJoint+".rotate") ($nOriName+".orientation");
       			x3dSetRouteDirectly($timer, "TimeSensor", $timer, "fraction_changed", $nOriName, "OrientationInterpolator", $nOriName, "set_fraction");
       			x3dSetRouteDirectly($nOriName, "OrientationInterpolator", $nOriName, "value_changed", $joint, "HAnimJoint", $x3dJointName, "set_rotation");
       	}else if(`objExists $oriName`) delete $oriName;

       	string $joints[] = `listRelatives -c -type "joint" $joint`;
       	int $i;
       	for($i=0;$i<size($joints);$i++)
       	{
       		int $isIO = `getAttr ($joints[$i]+".intermediateObject")`;
       		if($isIO == false) x3dJointInterpolatorSetup($timer, $joints[$i], $avatar);
       	}
	} else warning("REQUIRED 'ghost' Joint node appears to be missing - Please \"Mend\" this character.");
}

global proc x3dGetSelectedCEHNodes(string $parent, string $list[])
{
	string $un[];
	x3dCEListUsableNodes($parent, $un);
	int $index[] = `textScrollList -q -sii x3dCEHumanList`;
	if($index[0] > 0)
	{
		int $i;
		for($i=0;$i<size($index);$i++)
		{
			int $j = $index[$i]-1;
			$list[$i] = $un[$j];
		}
	}	
}

global proc x3dCEListUsableNodes(string $parent, string $un[])
{
	int $i = size($un);
	$un[$i] = $parent;

	string $nList[] = `listRelatives -c -type "joint" $parent`;

	int $j;
	for($j=0;$j<size($nList);$j++)
	{
		int $tf = `getAttr ($nList[$j]+".intermediateObject")`;
		if($tf == false) x3dCEListUsableNodes($nList[$j], $un);
	}
}

global proc string x3dGetSelectedCETimer()
{
	int $index[] = `textScrollList -q -sii x3dCETimerList`;
	if($index[0] > 0)
	{
		string $nodeNames[] = `ls -type x3dTimeSensor`;
		int $i = $index[0]-1;
		
		return $nodeNames[$i];
	}
	else return "empty";
	
}

global proc string x3dGetSelectedCEChar(string $timer)
{
	string $characters[] = x3dGetCharacters();
	string $assChar[];
	int $cs = `getAttr ($timer+".charSize")`;
	int $k;
	int $m = 0;
	for($k=0;$k<size($characters);$k++)
	{
		int $l;
		for($l=0; $l<$cs;$l++)
		{
			if($characters[$k] == `getAttr ($timer+".character"+$l)`)
			{
				$assChar[$m] = $characters[$k];
				$m=$m+1;
			}
		}
	}

     	int $index1[] = `textScrollList -q -sii x3dCETimerCharList`;
	if($index1[0] > 0)
     	{
		int $j = $index1[0]-1;
		return $assChar[$j];
	}
	else return "empty";
}

global proc x3dNoJointAnimation()
{
	string $timerName = "empty";
	string $charName = "empty";
	string $nodeNames[];
	$timerName = x3dGetSelectedCETimer();
	if($timerName != "empty")
	{
		$charName = x3dGetSelectedCEChar($timerName);
		if($charName != "empty")
		{
			x3dGetSelectedCEHNodes($charName, $nodeNames);
			int $i;
			for($i=0;$i<size($nodeNames);$i++)
			{
				if(`attributeExists ($timerName+"_Pos") $nodeNames[$i]`) deleteAttr ($nodeNames[$i]+"."+$timerName+"_Pos");
				if(`attributeExists ($timerName+"_Ori") $nodeNames[$i]`) deleteAttr ($nodeNames[$i]+"."+$timerName+"_Ori");
			}
		}
	}
	x3dDisplayHumanoid();
}
global proc x3dTranslateAnimation()
{
	string $timerName = "empty";
	string $charName = "empty";
	string $nodeNames[];
	$timerName = x3dGetSelectedCETimer();
	if($timerName != "empty")
	{
		$charName = x3dGetSelectedCEChar($timerName);
		if($charName != "empty")
		{
			x3dGetSelectedCEHNodes($charName, $nodeNames);
			int $i;
			for($i=0;$i<size($nodeNames);$i++)
			{
				if(!`attributeExists ($timerName+"_Pos") $nodeNames[$i]`) addAttr -longName ($timerName+"_Pos") -at bool $nodeNames[$i];
				if(`attributeExists ($timerName+"_Ori") $nodeNames[$i]`) deleteAttr ($nodeNames[$i]+"."+$timerName+"_Ori");
			}
		}
	}
	x3dDisplayHumanoid();
}
global proc x3dRotateAnimation()
{
	string $timerName = "empty";
	string $charName = "empty";
	string $nodeNames[];
	$timerName = x3dGetSelectedCETimer();
	if($timerName != "empty")
	{
		$charName = x3dGetSelectedCEChar($timerName);
		if($charName != "empty")
		{
			x3dGetSelectedCEHNodes($charName, $nodeNames);
			int $i;
			for($i=0;$i<size($nodeNames);$i++)
			{
				if(!`attributeExists ($timerName+"_Ori") $nodeNames[$i]`) addAttr -longName ($timerName+"_Ori") -at bool $nodeNames[$i];
				if(`attributeExists ($timerName+"_Pos") $nodeNames[$i]`) deleteAttr ($nodeNames[$i]+"."+$timerName+"_Pos");
			}
		}
	}
	x3dDisplayHumanoid();
}
global proc x3dTandRAnimation()
{
	string $timerName = "empty";
	string $charName = "empty";
	string $nodeNames[];
	$timerName = x3dGetSelectedCETimer();
	if($timerName != "empty")
	{
		$charName = x3dGetSelectedCEChar($timerName);
		if($charName != "empty")
		{
			x3dGetSelectedCEHNodes($charName, $nodeNames);
			int $i;
			for($i=0;$i<size($nodeNames);$i++)
			{
				if(!`attributeExists ($timerName+"_Pos") $nodeNames[$i]`) addAttr -longName ($timerName+"_Pos") -at bool $nodeNames[$i];
				if(!`attributeExists ($timerName+"_Ori") $nodeNames[$i]`) addAttr -longName ($timerName+"_Ori") -at bool $nodeNames[$i];
			}
		}
	}
	x3dDisplayHumanoid();
}

global proc x3dMend(string $name)
{
	int $isAvatar = x3dCheckGroupingForAvatar($name);
	if($isAvatar == true)
	{
		////////////////////////////////////////////////////
		//Remove character reference from all x3dTimeSensors
		////////////////////////////////////////////////////
		string $timers[] = `ls -et x3dTimeSensor`;
		int $i;
		for($i=0;$i<size($timers);$i++)
		{
			int $cs = `getAttr ($timers[$i]+".charSize")`;
			
			string $retchars[];
			int $k = 0;
			int $j;
			for($j=0;$j<$cs;$j++)
			{
				string $attVal = `getAttr ($timers[$i]+".character"+$j)`;
				deleteAttr ($timers[$i]+".character"+$j);
				if($attVal != $name)
				{
					$retchars[$k] = $attVal;
					$k=$k+1;
				}
			}

			for($j=0;$j<size($retchars);$j++)
			{
				addAttr -longName ("character"+$j) -dt "string" $timers[$i];
				setAttr -type "string" ($timers[$i]+".character"+$j) $retchars[$j];
			}
			$cs = size($retchars);
			setAttr ($timers[$i]+".charSize") $cs;
		}
		x3dMendRemoveTimerRefs($name,$timers);
		x3dMendRemovePosInterps($name);
		x3dMendRemoveOriInterps($name);

		string $children[] = `listRelatives -c -type "joint" $name`;
		string $ioChildren[];
		
		int $j = 0;
		for($i=0;$i<size($children);$i++)
		{
			int $isIO = `getAttr ($children[$i]+".intermediateObject")`;
			if($isIO == true)
			{
				$ioChildren[$j] = $children[$i];
				$j = $j+1;
			}
		}

		for($i=0;$i<size($ioChildren);$i++)
		{
			delete $ioChildren[$i];
		}
	}
	else warning("The node you attempted to mend is not an X3D character node");
	if(`textScrollList -ex x3dCETimerList`)
	{
		textScrollList -e -ra x3dCEHumanList;
		x3dUpdateUnassignedChars();
	}
}

/////////////////////////////////////////////////////
//Remove Timer References from Humanoid and Joints
/////////////////////////////////////////////////////
global proc x3dMendRemoveTimerRefs(string $name, string $timers[])
{
		if(`attributeExists "hasIOJoints" $name`) deleteAttr ($name+".hasIOJoints");
		int $i;
		for($i=0;$i<size($timers);$i++)
		{
			if(`attributeExists ($timers[$i]+"_Pos") $name`) deleteAttr ($name+"."+$timers[$i]+"_Pos");
			if(`attributeExists ($timers[$i]+"_Ori") $name`) deleteAttr ($name+"."+$timers[$i]+"_Ori");
		}
		string $children[] = `listRelatives -c -type "joint" $name`;
		string $nioChildren[];
		int $j=0;
		for($i=0;$i<size($children);$i++)
		{
			int $isIO = `getAttr ($children[$i]+".intermediateObject")`;
			if($isIO != true)
			{
				$nioChildren[$j] = $children[$i];
				$j = $j+1;
			}
		}
		for($i=0;$i<size($nioChildren);$i++) x3dMendRemoveTimerRefs($nioChildren[$i], $timers);
}

global proc x3dMendRemovePosInterps(string $name)//999000999
{
	string $cons[] = `listConnections -source false -destination true -p true ($name+".translate")`;
	int $i;
	if(`nodeType $name` == "transform") 
	{
		for($i=0;$i<size($cons);$i++)
		{
			string $chop[];
			tokenize($cons[$i], ".", $chop);
			string $nt = `nodeType $chop[0]`;
			if($nt == "x3dPositionInterpolator") delete $chop[0];
		}
	}
	else
	{
		for($i=0;$i<size($cons);$i++)
		{
			string $chop[];
			tokenize($cons[$i], ".", $chop);
			string $nt = `nodeType $chop[0]`;
			if($nt == "expression")
			{
				string $script = `expression -q -s $chop[0]`;
				string $nodes[];
				tokenize($script, "*", $nodes);
				if(`objExists $nodes[2]`) delete $nodes[2];
				delete $chop[0];
			}
		}
	}

	string $children[] = `listRelatives -c -type "joint" $name`;
	string $ioChildren[];
	int $j=0;
	for($i=0;$i<size($children);$i++)
	{
		int $isIO = `getAttr ($children[$i]+".intermediateObject")`;
		if($isIO == true)
		{
			$ioChildren[$j] = $children[$i];
			$j = $j+1;
		}
	}
	for($i=0;$i<size($ioChildren);$i++) x3dMendRemovePosInterps($ioChildren[$i]);
}

global proc x3dMendRemoveOriInterps(string $name)
{
	string $cons[] = `listConnections -source false -destination true -p true ($name+".rotate")`;
	int $i;
	for($i=0;$i<size($cons);$i++)
	{
		string $chop[];
		tokenize($cons[$i], ".", $chop);
		string $nt = `nodeType $chop[0]`;
		if($nt == "x3dOrientationInterpolator") delete $chop[0];
	}

	string $children[] = `listRelatives -c -type "joint" $name`;
	string $ioChildren[];
	int $j=0;
	for($i=0;$i<size($children);$i++)
	{
		int $isIO = `getAttr ($children[$i]+".intermediateObject")`;
		if($isIO == true)
		{
			$ioChildren[$j] = $children[$i];
			$j = $j+1;
		}
	}
	for($i=0;$i<size($ioChildren);$i++) x3dMendRemoveOriInterps($ioChildren[$i]);
}

