###############################################

# x3d.py X3D Package for Python

# generator:  X3duomToX3dPythonPackage.xslt
# X3DUOM:     X3dUnifiedObjectModel-4.0.xml
# Python X3D: https://www.web3d.org/x3d/stylesheets/python/python.html
"""
The x3d.py Python X3D Package supports programmers with Python interfaces and objects for standards-based X3D programming, all as open source.

This work is part of the X3D Python Scene Access Interface Library (X3DPSAIL).
"""

# Include regular expression (regex) library: re is built into Python
# https://docs.python.org/3/library/re.html
# https://docs.python.org/3/howto/regex.html#regex-howto
# https://www.web3d.org/specifications/X3dRegularExpressions.html

import re

_DEBUG = False       # options True False

###############################################

# SimpleType Enumerations

ACCESSTYPECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'initializeOnly',  # A field with accessType initializeOnly can be initialized, but cannot send or receive events.
    'inputOnly',  # A field with accessType inputOnly cannot be initialized or included in a scene file, but can receive input event values via a ROUTE.
    'outputOnly',  # A field with accessType outputOnly cannot be initialized or included in a scene file, but can send output event values via a ROUTE.
    'inputOutput'  # A field with accessType inputOutput can be initialized, and can also send or receive events.
)
def assertValidAccessType(fieldName, value):
    """
    Utility function to assert type validity of accessTypeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in ACCESSTYPECHOICES:
        # print('*** assertValidAccessType ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in ACCESSTYPECHOICES:
        # print('*** assertValidAccessType ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in ACCESSTYPECHOICES=' + str(ACCESSTYPECHOICES))

ACRONYMCHOICES = (
    # strict set of allowed values follow, no other values are valid
    'CAD',  # Computer-Assisted Design
    'HSV',  # Hue, Saturation, and Value colour model
    'JPEG',  # Joint Photographic Experts Group
    'MIDI',  # Musical Instrument Digital Interface. A standard for digital music representation.
    'MIME',  # Multipurpose Internet Mail Extension
    'MF',  # Multiple-valued field
    'MPEG',  # Moving Picture Experts Group
    'PNG',  # Portable Network Graphics. A specification for representing two-dimensional images in files.
    'RGB',  # Red, Green, and Blue colour model
    'RURL',  # Relative Uniform Resource Locator
    'SAI',  # Scene Access Interface
    'SF',  # Single-valued field
    'UCS',  # Universal multiple-octet coded Character Set
    'URI',  # Universal Resource Identifier
    'URL',  # Uniform Resource Locator
    'URN',  # Universal Resource Name
    'UTF-8'  # variable-length 8-bit Universal multiple-octet coded character set Transformation Format
)
def assertValidAcronym(fieldName, value):
    """
    Utility function to assert type validity of acronymChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in ACRONYMCHOICES:
        # print('*** assertValidAcronym ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in ACRONYMCHOICES:
        # print('*** assertValidAcronym ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in ACRONYMCHOICES=' + str(ACRONYMCHOICES))

ALPHAMODECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'AUTO',  # Material transparency is applied to texture transparency
    'OPAQUE',  # Ignore alpha channel texture transparency, opaque
    'MASK',  # Alpha-testing mode for transparent when alpha value less than 0.5 and opaque when greater than or equal to 0.5
    'BLEND'  # Blend combines partial transparency of textures and materials
)
def assertValidAlphaMode(fieldName, value):
    """
    Utility function to assert type validity of alphaModeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in ALPHAMODECHOICES:
        # print('*** assertValidAlphaMode ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in ALPHAMODECHOICES:
        # print('*** assertValidAlphaMode ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in ALPHAMODECHOICES=' + str(ALPHAMODECHOICES))

APPLIEDPARAMETERSCHOICES = (
    # note these MFString values use XML syntax
    # strict set of allowed values follow, no other values are valid
    '"BOUNCE"',  # The bounce field value is used.
    '"USER_FRICTION"',  # The system will normally calculate the friction direction vector that is perpendicular to the contact normal. This setting indicates that the user-supplied value in this contact should be used.
    '"FRICTION_COEFFICIENT-2"',  # Apply frictionCoefficients values
    '"ERROR_REDUCTION"',  # Apply softnessErrorCorrection value
    '"CONSTANT_FORCE"',  # Apply softnessConstantForceMix value
    '"SPEED-1"',  # Apply first component of surfaceSpeed array
    '"SPEED-2"',  # Apply second component of surfaceSpeed array
    '"SLIP-1"',  # Apply first component of slipFactors array
    '"SLIP-2"'  # Apply second component of slipFactors array
)
def assertValidAppliedParameters(fieldName, value):
    """
    Utility function to assert type validity of appliedParametersChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in APPLIEDPARAMETERSCHOICES:
        # print('*** assertValidAppliedParameters ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in APPLIEDPARAMETERSCHOICES:
        # print('*** assertValidAppliedParameters ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in APPLIEDPARAMETERSCHOICES=' + str(APPLIEDPARAMETERSCHOICES))

BIQUADTYPEFILTERCHOICES = (
    # strict set of allowed values follow, no other values are valid
    'LOWPASS',  # X3D version of "lowpass" in Web Audio API.
    'HIGHPASS',  # X3D version of "highpass" in Web Audio API.
    'BANDPASS',  # X3D version of "bandpass" in Web Audio API.
    'LOWSHELF',  # X3D version of "lowshelf" in Web Audio API.
    'HIGHSHELF',  # X3D version of "highshelf" in Web Audio API.
    'PEAKING',  # X3D version of "peaking" in Web Audio API.
    'NOTCH',  # X3D version of "notch" in Web Audio API.
    'ALLPASS'  # X3D version of "allpass" in Web Audio API.
)
def assertValidBiquadTypeFilter(fieldName, value):
    """
    Utility function to assert type validity of biquadTypeFilterChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in BIQUADTYPEFILTERCHOICES:
        # print('*** assertValidBiquadTypeFilter ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in BIQUADTYPEFILTERCHOICES:
        # print('*** assertValidBiquadTypeFilter ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in BIQUADTYPEFILTERCHOICES=' + str(BIQUADTYPEFILTERCHOICES))

CHANNELCOUNTMODECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'MAX',  # X3D version of "max" in Web Audio API.
    'CLAMPED_MAX',  # X3D version of "clamped-max" in Web Audio API.
    'EXPLICIT'  # X3D version of "explicit" in Web Audio API.
)
def assertValidChannelCountMode(fieldName, value):
    """
    Utility function to assert type validity of channelCountModeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in CHANNELCOUNTMODECHOICES:
        # print('*** assertValidChannelCountMode ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in CHANNELCOUNTMODECHOICES:
        # print('*** assertValidChannelCountMode ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in CHANNELCOUNTMODECHOICES=' + str(CHANNELCOUNTMODECHOICES))

CHANNELINTERPRETATIONCHOICES = (
    # strict set of allowed values follow, no other values are valid
    'SPEAKERS',  # X3D version of "speakers" in Web Audio API.
    'DISCRETE'  # X3D version of "discrete" in Web Audio API.
)
def assertValidChannelInterpretation(fieldName, value):
    """
    Utility function to assert type validity of channelInterpretationChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in CHANNELINTERPRETATIONCHOICES:
        # print('*** assertValidChannelInterpretation ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in CHANNELINTERPRETATIONCHOICES:
        # print('*** assertValidChannelInterpretation ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in CHANNELINTERPRETATIONCHOICES=' + str(CHANNELINTERPRETATIONCHOICES))

CLOSURETYPECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'PIE',  # Connects arc endpoints to center, forming a pie wedge
    'CHORD'  # Connects arc endpoints directly to each other, as in chord on a circle
)
def assertValidClosureType(fieldName, value):
    """
    Utility function to assert type validity of closureTypeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in CLOSURETYPECHOICES:
        # print('*** assertValidClosureType ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in CLOSURETYPECHOICES:
        # print('*** assertValidClosureType ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in CLOSURETYPECHOICES=' + str(CLOSURETYPECHOICES))

COMPONENTNAMECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'Core',  # The Core component supplies the base functionality for the X3D run-time system, including the abstract base node type, field types, the event model, and routing.
    'CADGeometry',  # The CADGeometry component is provided for Computer-Aided Design (CAD) nodes.
    'CubeMapTexturing',  # The Cube Map Environmental Texturing component describes how additional texturing effects are defined to produce environmental effects such as reflections from objects.
    'DIS',  # The Distributed Interactive Simulation (DIS) component provides networked interoperability with the IEEE DIS protocol for sharing state and conducting real-time platform-level simulations across multiple host computers.
    'EnvironmentalEffects',  # Nodes in the Environmental effects component support the creation of realistic environmental effects such as panoramic backgrounds and fog.
    'EnvironmentalSensor',  # The Environment Sensor nodes emit events indicating activity in the scene environment, usually based on interactions between the viewer and the world.
    'EventUtilities',  # The Event Utility nodes provide the capability to filter, trigger, convert, or sequence numerous event-types for common interactive applications without the use of a Script node.
    'Followers',  # The Follower nodes (Chasers and Dampers) support dynamic creation of smooth parameter transitions at run time.
    'Geometry2D',  # The Geometry2D component defines how two-dimensional geometry is specified and what shapes are available.
    'Geometry3D',  # The Geometry3D component describes how three-dimensional geometry is specified and defines ElevationGrid, Extrusion, IndexedFaceSet, and most primitive geometry nodes (Box, Cone, Cylinder, Sphere).
    'Geospatial',  # The Geospatial component defines how to associate real-world locations in an X3D scene and specifies nodes particularly tuned for geospatial applications.
    'Grouping',  # The Grouping component describes how nodes are organized into groups to establish a transformation hierarchy for the X3D scene graph.
    'HAnim',  # The Humanoid Animation (HAnim) component for X3D defines node bindings and other details for implementing ISO/IEC 19774, the HAnim International Specification. Original name was H-Anim for X3D versions 3.0 through 3.3, both enumeration values HAnim and H-Anim are allowed to pass validation.
    'H-Anim',  # Legacy enumeration H-Anim for X3D versions 3.0-3.3 provides backwards compatibility with Humanoid Animation (HAnim) version 1, preferred form of enumeration value is HAnim.
    'Interpolation',  # Interpolator nodes provide keyframe-based animation capability.
    'KeyDeviceSensor',  # The Key Device Sensor defines how keyboard keystrokes are inserted into an X3D world.
    'Layering',  # The Layering component describes how to layer a set of subscene layers into a composite scene.
    'Layout',  # The Layout component defines how to precisely position content in a scene in relation to the rendered results, especially for integrating 2D content with 3D content.
    'Lighting',  # The Lighting component specifies how light sources are defined and positioned, as well as how lights effect the rendered image.
    'Navigation',  # The Navigation component specifies how a user can effectively and intuitively move through and around a 3D scene.
    'Networking',  # The Networking component defines node types and other features used to access file-based and streaming resources on the World Wide Web.
    'NURBS',  # The NURBS component describes Non-uniform Rational B-Spline (NURBS) geometry and interpolation nodes.
    'ParticleSystems',  # The Particle Systems component specifies how to model particles and their interactions through the application of basic physics principles to affect motion.
    'Picking',  # The Picking component provides the ability to test for arbitrary object collision and provide basic capabilities to detecting object intersections and interactions.
    'PointingDeviceSensor',  # Pointing device sensor nodes detect pointing events from user-interface devices, defining activities such as a user selecting a piece of geometry.
    'TextureProjection',  # TextureProjection nodes project texture images onto geometry in a scene.
    'Rendering',  # The Rendering component includes fundamental rendering primitives such as TriangleSet and PointSet nodes, as well as geometric properties nodes that define how coordinate indices, colors, normals and texture coordinates are specified.
    'RigidBodyPhysics',  # The Rigid Body Physics component describes how to model rigid bodies and their interactions through the application of basic physics principles to effect motion.
    'Scripting',  # The Scripting component describes how Script nodes are used to effect changes in X3D worlds.
    'Shaders',  # The Programmable Shaders component describes how programmable shaders are specified and how they affect the visual appearance of geometry.
    'Shape',  # The Shape component defines nodes for associating geometry with their visible properties and the scene environment.
    'Sound',  # The Sound component defines how sound is delivered to an X3D world as well as how sounds are accessed.
    'Text',  # The Text component defines how text strings are rendered in an X3D scene.
    'Texturing',  # The Texturing component specifies how 2D texture images are defined and then positioned on associated geometry.
    'Texturing3D',  # The Texturing3D component specifies how 3D volumetric textures describe surface properties as data points in a volume of space, rather than a flat surface.
    'Time',  # The Time component defines how time is sensed, computed and associated with events in an X3D scene.
    'VolumeRendering'  # The Volume Rendering component provides the ability to specify and render volumetric data sets.
)
def assertValidComponentName(fieldName, value):
    """
    Utility function to assert type validity of componentNameChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in COMPONENTNAMECHOICES:
        # print('*** assertValidComponentName ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in COMPONENTNAMECHOICES:
        # print('*** assertValidComponentName ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in COMPONENTNAMECHOICES=' + str(COMPONENTNAMECHOICES))

DISTANCEMODELCHOICES = (
    # strict set of allowed values follow, no other values are valid
    'LINEAR',  # X3D version of "linear" in Web Audio API.
    'INVERSE',  # X3D version of "inverse" in Web Audio API.
    'EXPONENTIAL'  # X3D version of "exponential" in Web Audio API.
)
def assertValidDistanceModel(fieldName, value):
    """
    Utility function to assert type validity of distanceModelChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in DISTANCEMODELCHOICES:
        # print('*** assertValidDistanceModel ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in DISTANCEMODELCHOICES:
        # print('*** assertValidDistanceModel ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in DISTANCEMODELCHOICES=' + str(DISTANCEMODELCHOICES))

FIELDTYPECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'SFBool',  # Single Field (singleton) Boolean
    'MFBool',  # Multiple Field (list) Boolean
    'SFColor',  # Single Field (singleton) color value, red-green-blue
    'MFColor',  # Multiple Field (list) color value, red-green-blue
    'SFColorRGBA',  # Single Field (singleton) color value, red-green-blue alpha (opacity)
    'MFColorRGBA',  # Multiple Field (list) color value, red-green-blue alpha (opacity)
    'SFDouble',  # Single Field (singleton) double-precision (64-bit) float
    'MFDouble',  # Multiple Field (list) 2-tuple double-precision (64-bit) float vector
    'SFFloat',  # Single Field (singleton) single-precision (32-bit) float
    'MFFloat',  # Multiple Field (list) single-precision (32-bit) float vector
    'SFImage',  # Single Field (singleton) image value
    'MFImage',  # Multiple Field (list) image values
    'SFInt32',  # Single Field (singleton) 32-bit integer
    'MFInt32',  # Multiple Field (list) 32-bit integer
    'SFNode',  # Single Field (singleton) node
    'MFNode',  # Multiple Field (list) nodes
    'SFRotation',  # Single Field (singleton) rotation value using 3-tuple axis, radian angle
    'MFRotation',  # Multiple Field (list) rotation values using 3-tuple axis, radian angle
    'SFString',  # Single Field (singleton) string value
    'MFString',  # Multiple Field (list) SFString array
    'SFTime',  # Single Field (singleton) time value in seconds
    'MFTime',  # Multiple Field (list) time array in seconds
    'SFVec2d',  # Single Field (singleton) 2-tuple double-precision float vector
    'MFVec2d',  # Multiple Field (list) 2-tuple double-precision float vectors
    'SFVec2f',  # Single Field (singleton) 2-tuple single-precision float vector
    'MFVec2f',  # Multiple Field (list) 2-tuple single-precision float vectors
    'SFVec3d',  # Single Field (singleton) 3-tuple double-precision float vector
    'MFVec3d',  # Multiple Field (list) 3-tuple double-precision float vectors
    'SFVec3f',  # Single Field (singleton) 3-tuple single-precision float vector
    'MFVec3f',  # Multiple Field (list) 3-tuple single-precision float vectors
    'SFVec4d',  # Single Field (singleton) 4-tuple double-precision float vector
    'MFVec4d',  # Multiple Field (list) 4-tuple double-precision float vectors
    'SFVec4f',  # Single Field (singleton) 4-tuple single-precision float vector
    'MFVec4f',  # Multiple Field (list) 4-tuple single-precision float vectors
    'SFMatrix3d',  # Single Field (singleton) 3×3 matrix of double-precision floating point numbers
    'MFMatrix3d',  # Multiple Field (list) 3×3 matrices of double-precision floating point numbers
    'SFMatrix3f',  # Single Field (singleton) 3×3 matrix of single-precision floating point numbers
    'MFMatrix3f',  # Multiple Field (list) 3×3 matrices of double-precision floating point numbers
    'SFMatrix4d',  # Single Field (singleton) 4×4 matrix of double-precision floating point numbers
    'MFMatrix4d',  # Multiple Field (list) 4×4 matric3w of double-precision floating point numbers
    'SFMatrix4f',  # Single Field (singleton) 4×4 matrix of single-precision floating point numbers
    'MFMatrix4f'  # Multiple Field (list) 4×4 matrices of single-precision floating point numbers
)
def assertValidFieldType(fieldName, value):
    """
    Utility function to assert type validity of fieldTypeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in FIELDTYPECHOICES:
        # print('*** assertValidFieldType ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in FIELDTYPECHOICES:
        # print('*** assertValidFieldType ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in FIELDTYPECHOICES=' + str(FIELDTYPECHOICES))

FOGTYPECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'LINEAR',  # linear blending as a function of distance
    'EXPONENTIAL'  # exponential blending as a function of distance
)
def assertValidFogType(fieldName, value):
    """
    Utility function to assert type validity of fogTypeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in FOGTYPECHOICES:
        # print('*** assertValidFogType ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in FOGTYPECHOICES:
        # print('*** assertValidFogType ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in FOGTYPECHOICES=' + str(FOGTYPECHOICES))

FONTFAMILYVALUES = (
    # specification-defined values follow, other values are also allowed
    '"SANS"',  # default font family for sans-serif font such as Helvetica
    '"SERIF"',  # default font family for serif font such as Times-Roman
    '"TYPEWRITER"'  # default font family for a fixed-pitch font such as Courier
)

FONTSTYLECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'PLAIN',  # default plain type
    'BOLD',  # boldface type
    'ITALIC',  # italic type
    'BOLDITALIC'  # bold and italic type
)
def assertValidFontStyle(fieldName, value):
    """
    Utility function to assert type validity of fontStyleChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in FONTSTYLECHOICES:
        # print('*** assertValidFontStyle ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in FONTSTYLECHOICES:
        # print('*** assertValidFontStyle ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in FONTSTYLECHOICES=' + str(FONTSTYLECHOICES))

FORCEOUTPUTVALUES = (
    # specification-defined values follow, other values are also allowed
    '"ALL"',  # all forceOutput fields computed
    '"NONE"'  # no forceOutput fields computed
)

GENERATEDCUBEMAPTEXTUREUPDATECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'NONE',  # no further texture updates are rendered
    'NEXT_FRAME_ONLY',  # render texture once at end of frame
    'ALWAYS'  # texture to be rendered every frame
)
def assertValidGeneratedCubeMapTextureUpdate(fieldName, value):
    """
    Utility function to assert type validity of generatedCubeMapTextureUpdateChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in GENERATEDCUBEMAPTEXTUREUPDATECHOICES:
        # print('*** assertValidGeneratedCubeMapTextureUpdate ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in GENERATEDCUBEMAPTEXTUREUPDATECHOICES:
        # print('*** assertValidGeneratedCubeMapTextureUpdate ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in GENERATEDCUBEMAPTEXTUREUPDATECHOICES=' + str(GENERATEDCUBEMAPTEXTUREUPDATECHOICES))

GEOMETADATASUMMARYKEYVALUES = (
    # specification-defined values follow, other values are also allowed
    'title',  # A name to succinctly identify the dataset to user. For example, "San Francisco, California".
    'description',  # A brief textual description or summary of the content of the dataset. For example, "LANDSAT 7 satellite imagery taken over northern Scotland".
    'coordinateSystem',  # The spatial reference frame used to represent the data (e.g., GD, UTM, or LCC). The list of valid codes that can be used in this field are defined in ISO/IEC 18026. In the case of UTM, the zone number should also be specified in the format "UTM Zx", where the zone number is in the range [1,60]. For example, "UTM Z11".
    'horizontalDatum',  # The name of the geodetic datum. The list of valid codes that can be used in this field are defined in ISO/IEC 18026. For example, "W84".
    'verticalDatum',  # The name of the vertical datum (geoid). The list of valid codes that can be used in this field are defined in ISO/IEC 18026. For example, "W84".
    'ellipsoid',  # The name of the geodetic ellipsoid. The list of valid codes that can be used in this field are defined in ISO/IEC 18026. For example, "WE".
    'extent',  # The bounding coordinates for the dataset given in spatial reference frame specified by the coordinateSystem keyword. These are provided in the order eastmost, southmost, westmost, northmost. An example for GD is: "-180.0 -90.0 180.0 90.0".
    'resolution',  # SFFloat resolution, or ground sample distance, given in units of length base units. For example, "30".
    'originator',  # A string defining the originator of the data, for example the author, agency, organization, publisher, etc. For example, "John Doe, Any Corporation, Some Town, Some Country"
    'copyright',  # Any appropriate copyright declaration that pertains to the data. For example, "(c) Copyright 2000, Any Corporation. All rights reserved. Freely distributable."
    'date',  # A single date/time, or a date/time range, defining the valid time period to which the data pertains. Dates are specified in the format "YYYY MM DD [HH:MM]". Years in the current time period should be specified using four digits (EXAMPLE "1999" or "2001"). Years can have other than four digits and can be negative. A date range is specified by supplying two values separated by a "-" (hyphen) character. An optional time can be supplied should this level of accuracy be required. Times are to be specified in 24-hour format with respect to GMT. For example, "1999 01 01 00:00 - 1999 12 31 23:59".
    'metadataFormat',  # A string that specifies the format of the external metadata description specified by the url field of the GeoMetadata node. For example, "FGDC", "ISO TC211", "CEN TC287", or "OGC".
    'dataUrl',  # A hypertext link to the source data used to create the X3D node(s) to which this metadata pertains. Multiple dataUrl keyword/value pairs can be specified in order to provide alternative locations for the same source data. For example, "https://www.foo.bar/data/sf1".
    'dataFormat'  # A free-text string that describes the format of the source data used to create the X3D node(s) to which this metadata pertains. This refers to the source data specified by the dataUrl keyword (if present). For example, "USGS 5.5-min DEM".
)

GEOSYSTEMEARTHELLIPSOIDVALUES = (
    # specification-defined values follow, other values are also allowed
    'AM',  # Modified Airy
    'AN',  # Australian National
    'BN',  # Bessel 1841 (Namibia)
    'BR',  # Bessel 1841 (Ethiopia Indonesia ...)
    'CC',  # Clarke 1866
    'CD',  # Clarke 1880
    'EA',  # Everest (India 1830)
    'EB',  # Everest (Sabah & Sarawak)
    'EC',  # Everest (India 1956)
    'ED',  # Everest (W. Malaysia 1969)
    'EE',  # Everest (W. Malaysia & Singapore 1948)
    'EF',  # Everest (Pakistan)
    'FA',  # Modified Fischer 1960
    'HE',  # Helmert 1906
    'HO',  # Hough 1960
    'ID',  # Indonesia 1974
    'IN',  # International 1924
    'KA',  # Krassovsky 1940
    'RF',  # Geodetic Reference System 1980 (GRS 80)
    'SA',  # South American 1969
    'WD',  # WGS 72
    'WE',  # WGS 84
    'WGS84',  # WGS84 geoid
    'Zn',  # Zone number (1..60) (only used with UTM)
    'S'  # Southern hemisphere (only used with UTM)
)

GEOSYSTEMSPATIALREFERENCEFRAMEVALUES = (
    # specification-defined values follow, other values are also allowed
    'GD',  # Geodetic spatial reference frame (latitude/longitude), to be followed by ellipsoid
    'UTM',  # Universal Transverse Mercator. One further required argument must be supplied for UTM in order to specify the zone number (1..60) with optional suffix of "S" may be appended in order to specify that the coordinates are in the southern hemisphere. Optional arguments can follow.
    'GC',  # Earth-fixed Geocentric with respect to the WGS84 ellipsoid. No additional arguments are supported.
    'GDC',  # Synonymous to GD, but may be subject to future deprecation
    'GCC'  # Synonymous to GC, but may be subject to future deprecation
)

GLOSSARYCHOICES = (
    # strict set of allowed values follow, no other values are valid
    'activate',  # cause a #sensorNode to generate an isActive #event
    'ancestor',  # #node which is an antecedent of another node in the #transformationHierarchy
    'AudioGraph',  # structured collection of nodes that process audio inputs and outputs
    'author',  # person or agent that creates an #X3DFile
    'AuthoringTool',  # see #generator
    'avatar',  # abstract representation of the #user in an X3D #world
    'bearing',  # straight line passing through the #pointer location in the direction of the pointer
    'BindableNode',  # #node that may have many #instances in a #sceneGraph but only one instance may be active at any instant of #time
    'browser',  # computer program that interprets 3X3DFiles, presents their content to a user on a #displayDevice, and allows the user to interact with #worlds defined by X3D files by means of a user interface
    'BrowserExtension',  # #nodes defined using the prototyping mechanism that are understood only by certain #browsers
    'BuiltInNode',  # #node of a #type explicitly defined in this document
    'callback',  # function defined in a #scriptingLanguage to which #events are passed
    'child',  # instance of a #ChildrenNode
    'ChildrenNode',  # one of a set of #nodeTypes, instances of which can be collected in a group to share specific properties dependent on the type of the #GroupingNode
    'ClientSystem',  # computer system, attached to a #network, that relies on another computer (the server) for essential processing functions
    'CollisionProxy',  # #node used as a substitute for all of a Collision node's children during collision detection
    'ColourModel',  # characterization of a colour space in terms of explicit parameters
    'culling',  # process of identifying #objects or parts of objects which do not need to be processed further by the #browser in order to produce the desired view of a #world
    'descendant',  # #node which descends from another node in the #transformationHierarchy (a #ChildrenNode)
    'DisplayDevice',  # graphics device on which X3D #worlds may be rendered
    'DragSensor',  # #pointingDeviceSensor that causes #events to be generated in response to sensor-dependent pointer motions
    'EnvironmentalSensor',  # sensor #node that generates #events based on the location of the viewpoint in the #world or in relation to #objects in the world
    'event',  # message sent from one #node to another as defined by a #ROUTE
    'EventCascade',  # sequence of @events initiated by a script or sensor event and propagated from #node to node along one or more #routes all of which are considered to have occurred simultaneously
    'ExecutionModel',  # rules governing how #events are processed by #browsers and scripts
    'ExternaPrototype',  # #prototype defined in an external file and referenced by a #URL
    'field',  # property or attribute of a #node
    'FieldName',  # identifier of a #field
    'frame',  # single rendering of a #world on a #displayDevice or a single time-step in a simulation
    'generator',  # computer program which creates #X3DFiles
    'GeometricPropertyNode',  # #node defining the properties of a specific geometry node
    'GeometryNode',  # #node containing mathematical descriptions of points, lines, surfaces, text strings and solids
    'grab',  # receive #events from activated #pointingDevices
    'GroupingNode',  # one of a set of #nodeTypes which include a list of nodes, referred to as its #ChildrenNodes
    'HostApplication',  # client application with which the #browser communicates using the SAI
    'image',  # two-dimensional (2D) rectangular array of pixel values
    'immersive',  # creating the illusion of being inside a computer-generated scene
    'Inlining',  # mechanism by which one #X3DFile is hierarchically included in another
    'instance',  # the #node created by an #instantiation
    'instantiation',  # the creation of a #node based on its #nodeType
    'InterpolatorNode',  # #node that defines a piece-wise or smoothly continuous interpolation
    'intranet',  # private #network that uses the same protocols and standards as the Internet
    'LevelOfDetail',  # amount of detail or complexity which is displayed at any particular #time for any particular #object
    'LineTerminator',  # linefeed character (0x0A) and/or carriage return character (0x0D)
    'loop',  # sequence of #events which would result in a specific event generator sending more than one event with the same #timestamp
    'multimedia',  # integrated presentation, typically on a computer, of content of various types, such as computer graphics, audio, and videon
    'network',  # set of interconnected computers
    'node',  # fundamental component of a #sceneGraph that defines model information, such as graph structure, geometry, animation, interaction, object metadata, rendering, or display
    'nodeType',  # characteristic of each node that describes, in general, its particular semantics
    'object',  # collection of data and procedures, packaged according to the rules and syntax defined in this document. NOTE This term is usually synonymous with #node.
    'orderOfPreference',  # order (specified by the user) in which a list of #field values is processed by the #browser
    'panorama',  # background texture that is placed behind all geometry in the scene and in front of the ground and sky
    'parent',  # #node which is an instance of a #GroupingNode
    'pixel',  # one element of an #image specified as a matrix of colour elements
    'pointer',  # location and direction in the #virtualWorld defined by the #pointingDevice with which the #user is currently interacting with the virtual world
    'pointingDevice',  # hardware device connected to the #user's computer by which the user directly controls the location and direction of the #pointer
    'pointingDeviceSensor',  # sensor #node that generates #events based on #user actions, such as #pointingDevice motions or button activations
    'polyline',  # piecewise linear curve
    'profile',  # named collection of criteria for functionality and conformance that defines an implementable subset of a standard
    'prototype',  # definition of a new #nodeType in terms of the nodes defined in this document
    'prototyping',  # mechanism for extending the set of #nodeTypes from within a #X3DFile
    'ROUTE',  # connection between a #node generating an #event and a node receiving the event
    'sceneGraph',  # ordered set of #nodes and #statements
    'script',  # set of procedural functions normally executed as part of an #eventCascade
    'scripting',  # process of creating or referring to a #script
    'sensorNode',  # #node that enables the #user to interact with the #world in the scene graph hierarchy
    'separatorCharacter',  # #UTF-8 character used to separate syntactical entities in an #X3DFile
    'sibling',  # #node which shares a #parent with other nodes
    'simulationTick',  # smallest time unit capable of being identified in a digital simulation of analog time
    'slerp',  # spherical linear interpolation for animating 3D rotation values
    'specialGroupNode',  # grouping node that exhibits special behaviour ( e.g., Switch or LOD)
    'statement',  # A statement specifies fundamental scene-related information
    'texel',  # #pixel in an #image used as a #texture
    'texture',  # image used to create visual appearance effects when applied to geometry nodes
    'textureCoordinates',  # set of coordinates used to map a #texture to geometry
    'time',  # monotonically increasing value generated by a node
    'timestamp',  # that part of an #event that describes the #time the event occurred and that caused the message to be sent
    'transformationHierarchy',  # subset of the #sceneGraph consisting of #nodes that have well-defined coordinate systems
    'transparencyChunk',  # section of a PNG file containing transparency information (derived from ISO/IEC 15948)
    'traverse',  # process the nodes in a scene graph in the correct order
    'user',  # person or agent who uses and interacts with #X3DFiles by means of a #browser
    'viewer',  # location, direction, and viewing angle in a #virtualWorld that determines the portion of the virtual world presented by the #browser to the #user
    'virtualWorld',  # See #world.
    'whiteSpace',  # one or more consecutive occurrences of a #separatorCharacter
    'world',  # collection of one or more #X3DFiles (potentially including other multimedia content) that is interpreted by an X3D #browser to present an interactive experience to the #user that is consistent with the intent of the #author
    'worldCoordinateSpace',  # coordinate system in which each X3D #world is defined
    'X3DBrowser',  # see #browser
    'X3DDocumentServer',  # computer program that locates and transmits #X3DFiles and supporting files in response to requests from #browsers
    'X3DFile',  # set of X3D nodes and statements as defined in this document
    'XYPlane',  # plane perpendicular to the Z-axis that passes through the point Z = 0.0
    'YZPlane',  # plane perpendicular to the X-axis that passes through the point X = 0.0
    'ZXPlane'  # plane perpendicular to the Y-axis that passes through the point Y = 0.0
)
def assertValidGlossary(fieldName, value):
    """
    Utility function to assert type validity of glossaryChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in GLOSSARYCHOICES:
        # print('*** assertValidGlossary ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in GLOSSARYCHOICES:
        # print('*** assertValidGlossary ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in GLOSSARYCHOICES=' + str(GLOSSARYCHOICES))

HANIMFEATUREPOINTNAMEVALUES = (
    # specification-defined values follow, other values are also allowed
    'skull_vertex',  # CAESAR 2003 skull_vertex matches ISO 7250-1 part 5.22 Vertex (top of head). No corresponding landmark provided in CAESAR 2018.
    'glabella',  # glabella is between the eyebrows and above the nose
    'sellion',  # osseocartilaginous junction of the nasal dorsum
    'l_infraorbitale',  # Left Infraorbitale foramen is opening in maxillary bone of skull located below the infraorbital margin of the orbit.
    'l_tragion',  # notch just above the tragus of the ear
    'l_gonion',  # Left Gonion is midpoint of mandibular angle of the jaw.
    'r_infraorbitale',  # Right Infraorbitale foramen is opening in maxillary bone of skull located below the infraorbital margin of the orbit.
    'r_tragion',  # notch just above the tragus of the ear
    'r_gonion',  # Right Gonion is midpoint of the mandibular angle of the jaw.
    'supramenton',  # center point above tip of chin
    'cervicale',
    'adams_apple',
    'suprasternale',  # Suprasternale
    'substernale',
    'l_clavicle',
    'l_acromion',
    'l_axilla_proximal',  # Left Axilla Proximal (Anterior)
    'l_axilla_distal',  # Left Axilla Distal (Posterior)
    'l_axilla_posterior_folds',
    'r_clavicle',
    'r_acromion',
    'r_axilla_proximal',  # Right Axilla Proximal (Anterior)
    'r_axilla_distal',  # Right Axilla Distal (Posterior)
    'r_axilla_posterior_folds',  # Right Posterior Axillary Folds
    'spine_1_middle_back',
    'spine_2_lower_back',
    'waist_preferred_anterior',
    'waist_preferred_posterior',
    'l_rib10',
    'l_thelion',
    'r_rib10',
    'r_thelion',
    'l_asis',
    'l_iliocristale',
    'l_psis',
    'r_asis',
    'r_iliocristale',
    'r_psis',
    'crotch',
    'l_femoral_lateral_epicondyle',
    'l_femoral_medial_epicondyle',
    'l_suprapatella',
    'l_trochanterion',
    'r_femoral_lateral_epicondyle',
    'r_femoral_medial_epicondyle',
    'r_suprapatella',
    'r_trochanterion',
    'l_tibiale',
    'l_medial_malleolus',
    'l_lateral_malleolus',
    'l_sphyrion',
    'r_tibiale',
    'r_medial_malleolus',
    'r_lateral_malleolus',
    'r_sphyrion',
    'l_metatarsal_phalanx_1',
    'l_metatarsal_phalanx_5',
    'l_dactylion',
    'l_calcaneus_posterior',
    'r_metatarsal_phalanx_1',
    'r_metatarsal_phalanx_5',
    'r_dactylion',
    'r_calcaneus_posterior',
    'l_humeral_lateral_epicondyle',
    'l_humeral_medial_epicondyle',
    'l_olecranon',
    'r_humeral_lateral_epicondyle',
    'r_humeral_medial_epicondyle',
    'r_olecranon',
    'l_radiale',
    'l_ulnar_styloid',
    'l_radial_styloid',
    'r_radiale',
    'r_ulnar_styloid',
    'r_radial_styloid',
    'l_metacarpal_phalanx_2',
    'l_metacarpal_phalanx_3',
    'l_metacarpal_phalanx_5',
    'r_metacarpal_phalanx_2',
    'r_metacarpal_phalanx_3',
    'r_metacarpal_phalanx_5',
    'nuchale',
    'l_neck_base',
    'r_neck_base',
    'navel',
    'l_ectocanthus',
    'r_ectocanthus',
    'menton',
    'mesosternale',
    'opisthocranion',
    'l_knee_crease',
    'r_knee_crease',
    'rear_center_midsagittal_plane',
    'buttocks_standing_wall_contact_point',
    'l_chest_midsagittal_plane',
    'r_chest_midsagittal_plane',
    'l_bideltoid',
    'r_bideltoid',
    'l_carpal_distal_phalanx_1',
    'l_carpal_distal_phalanx_2',
    'l_carpal_distal_phalanx_3',
    'l_carpal_distal_phalanx_4',
    'l_carpal_distal_phalanx_5',
    'r_carpal_distal_phalanx_1',
    'r_carpal_distal_phalanx_2',
    'r_carpal_distal_phalanx_3',
    'r_carpal_distal_phalanx_4',
    'r_carpal_distal_phalanx_5',
    'l_tarsal_distal_phalanx_1',
    'l_tarsal_distal_phalanx_2',
    'l_tarsal_distal_phalanx_3',
    'l_tarsal_distal_phalanx_4',
    'l_tarsal_distal_phalanx_5',
    'r_tarsal_distal_phalanx_1',
    'r_tarsal_distal_phalanx_2',
    'r_tarsal_distal_phalanx_3',
    'r_tarsal_distal_phalanx_4',
    'r_tarsal_distal_phalanx_5'
)

HANIMHUMANOIDINFOKEYVALUES = (
    # specification-defined values follow, other values are also allowed
    'authorName',  # Name of Humanoid author.
    'authorEmail',  # Email address of Humanoid author.
    'copyright',  # Copyright information for this Humanoid model (if any).
    'creationDate',  # Creation data for this for this Humanoid model.
    'usageRestrictions',  # Usage restrictions for this Humanoid model (if any).
    'humanoidVersion',  # The humanoidVersion term refers to the version of the humanoid being used, in order to track revisions to the data. It is not the same as the version field of the Humanoid object, which refers to the version of the HAnim specification that was used when building the humanoid.
    'age',  # Description of Humanoid age (not necessarily numeric).
    'gender',  # The gender term typically has a value of female, male or neuter.
    'height',  # SFFloat Humanoid height in base units (typically meters).
    'weight'  # SFFloat Humanoid weight in base units (typically kilograms).
)

HANIMJOINTNAMEVALUES = (
    # specification-defined values follow, other values are also allowed
    'humanoid_root',
    'sacroiliac',
    'l_hip',
    'l_knee',
    'l_talocrural',
    'l_talocalcaneonavicular',
    'l_cuneonavicular_1',
    'l_tarsometatarsal_1',
    'l_metatarsophalangeal_1',
    'l_tarsal_interphalangeal_1',
    'l_cuneonavicular_2',
    'l_tarsometatarsal_2',
    'l_metatarsophalangeal_2',
    'l_tarsal_proximal_interphalangeal_2',
    'l_tarsal_distal_interphalangeal_2',
    'l_cuneonavicular_3',
    'l_tarsometatarsal_3',
    'l_metatarsophalangeal_3',
    'l_tarsal_proximal_interphalangeal_3',
    'l_tarsal_distal_interphalangeal_3',
    'l_calcaneocuboid',
    'l_transversetarsal',
    'l_tarsometatarsal_4',
    'l_metatarsophalangeal_4',
    'l_tarsal_proximal_interphalangeal_4',
    'l_tarsal_distal_interphalangeal_4',
    'l_tarsometatarsal_5',
    'l_metatarsophalangeal_5',
    'l_tarsal_proximal_interphalangeal_5',
    'l_tarsal_distal_interphalangeal_5',
    'r_hip',
    'r_knee',
    'r_talocrural',
    'r_talocalcaneonavicular',
    'r_cuneonavicular_1',
    'r_tarsometatarsal_1',
    'r_metatarsophalangeal_1',
    'r_tarsal_interphalangeal_1',
    'r_cuneonavicular_2',
    'r_tarsometatarsal_2',
    'r_metatarsophalangeal_2',
    'r_tarsal_proximal_interphalangeal_2',
    'r_tarsal_distal_interphalangeal_2',
    'r_cuneonavicular_3',
    'r_tarsometatarsal_3',
    'r_metatarsophalangeal_3',
    'r_tarsal_proximal_interphalangeal_3',
    'r_tarsal_distal_interphalangeal_3',
    'r_calcaneocuboid',
    'r_transversetarsal',
    'r_tarsometatarsal_4',
    'r_metatarsophalangeal_4',
    'r_tarsal_proximal_interphalangeal_4',
    'r_tarsal_distal_interphalangeal_4',
    'r_tarsometatarsal_5',
    'r_metatarsophalangeal_5',
    'r_tarsal_proximal_interphalangeal_5',
    'r_tarsal_distal_interphalangeal_5',
    'vl5',
    'vl4',
    'vl3',
    'vl2',
    'vl1',
    'vt12',
    'vt11',
    'vt10',
    'vt9',
    'vt8',
    'vt7',
    'vt6',
    'vt5',
    'vt4',
    'vt3',
    'vt2',
    'vt1',
    'vc7',
    'vc6',
    'vc5',
    'vc4',
    'vc3',
    'vc2',
    'vc1',
    'skullbase',
    'l_eyelid_joint',
    'r_eyelid_joint',
    'l_eyeball_joint',
    'r_eyeball_joint',
    'l_eyebrow_joint',
    'r_eyebrow_joint',
    'temporomandibular',
    'l_sternoclavicular',
    'l_acromioclavicular',
    'l_shoulder',
    'l_elbow',
    'l_radiocarpal',
    'l_midcarpal_1',
    'l_carpometacarpal_1',
    'l_metacarpophalangeal_1',
    'l_carpal_interphalangeal_1',
    'l_midcarpal_2',
    'l_carpometacarpal_2',
    'l_metacarpophalangeal_2',
    'l_carpal_proximal_interphalangeal_2',
    'l_carpal_distal_interphalangeal_2',
    'l_midcarpal_3',
    'l_carpometacarpal_3',
    'l_metacarpophalangeal_3',
    'l_carpal_proximal_interphalangeal_3',
    'l_carpal_distal_interphalangeal_3',
    'l_midcarpal_4_5',
    'l_carpometacarpal_4',
    'l_metacarpophalangeal_4',
    'l_carpal_proximal_interphalangeal_4',
    'l_carpal_distal_interphalangeal_4',
    'l_carpometacarpal_5',
    'l_metacarpophalangeal_5',
    'l_carpal_proximal_interphalangeal_5',
    'l_carpal_distal_interphalangeal_5',
    'r_sternoclavicular',
    'r_acromioclavicular',
    'r_shoulder',
    'r_elbow',
    'r_radiocarpal',
    'r_midcarpal_1',
    'r_carpometacarpal_1',
    'r_metacarpophalangeal_1',
    'r_carpal_interphalangeal_1',
    'r_midcarpal_2',
    'r_carpometacarpal_2',
    'r_metacarpophalangeal_2',
    'r_carpal_proximal_interphalangeal_2',
    'r_carpal_distal_interphalangeal_2',
    'r_midcarpal_3',
    'r_carpometacarpal_3',
    'r_metacarpophalangeal_3',
    'r_carpal_proximal_interphalangeal_3',
    'r_carpal_distal_interphalangeal_3',
    'r_midcarpal_4_5',
    'r_carpometacarpal_4',
    'r_metacarpophalangeal_4',
    'r_carpal_proximal_interphalangeal_4',
    'r_carpal_distal_interphalangeal_4',
    'r_carpometacarpal_5',
    'r_metacarpophalangeal_5',
    'r_carpal_proximal_interphalangeal_5',
    'r_carpal_distal_interphalangeal_5'
)

HANIMSEGMENTNAMEVALUES = (
    # specification-defined values follow, other values are also allowed
    'sacrum',
    'pelvis',
    'l_thigh',
    'l_calf',
    'l_talus',
    'l_navicular',
    'l_cuneiform_1',
    'l_metatarsal_1',
    'l_tarsal_proximal_phalanx_1',
    'l_tarsal_distal_phalanx_1',
    'l_cuneiform_2',
    'l_metatarsal_2',
    'l_tarsal_proximal_phalanx_2',
    'l_tarsal_middle_phalanx_2',
    'l_tarsal_distal_phalanx_2',
    'l_cuneiform_3',
    'l_metatarsal_3',
    'l_tarsal_proximal_phalanx_3',
    'l_tarsal_middle_phalanx_3',
    'l_tarsal_distal_phalanx_3',
    'l_calcaneus',
    'l_cuboid',
    'l_metatarsal_4',
    'l_tarsal_proximal_phalanx_4',
    'l_tarsal_middle_phalanx_4',
    'l_tarsal_distal_phalanx_4',
    'l_metatarsal_5',
    'l_tarsal_proximal_phalanx_5',
    'l_tarsal_middle_phalanx_5',
    'l_tarsal_distal_phalanx_5',
    'r_thigh',
    'r_calf',
    'r_talus',
    'r_navicular',
    'r_cuneiform_1',
    'r_metatarsal_1',
    'r_tarsal_proximal_phalanx_1',
    'r_tarsal_distal_phalanx_1',
    'r_cuneiform_2',
    'r_metatarsal_2',
    'r_tarsal_proximal_phalanx_2',
    'r_tarsal_middle_phalanx_2',
    'r_tarsal_distal_phalanx_2',
    'r_cuneiform_3',
    'r_metatarsal_3',
    'r_tarsal_proximal_phalanx_3',
    'r_tarsal_middle_phalanx_3',
    'r_tarsal_distal_phalanx_3',
    'r_calcaneus',
    'r_cuboid',
    'r_metatarsal_4',
    'r_tarsal_proximal_phalanx_4',
    'r_tarsal_middle_phalanx_4',
    'r_tarsal_distal_phalanx_4',
    'r_metatarsal_5',
    'r_tarsal_proximal_phalanx_5',
    'r_tarsal_middle_phalanx_5',
    'r_tarsal_distal_phalanx_5',
    'l5',
    'l4',
    'l3',
    'l2',
    'l1',
    't12',
    't11',
    't10',
    't9',
    't8',
    't7',
    't6',
    't5',
    't4',
    't3',
    't2',
    't1',
    'c7',
    'c6',
    'c5',
    'c4',
    'c3',
    'c2',
    'c1',
    'skull',
    'l_eyelid',
    'r_eyelid',
    'l_eyeball',
    'r_eyeball',
    'l_eyebrow',
    'r_eyebrow',
    'jaw',
    'l_clavicle',
    'l_scapula',
    'l_upperarm',
    'l_forearm',
    'l_carpal',
    'l_trapezium',
    'l_metacarpal_1',
    'l_carpal_proximal_phalanx_1',
    'l_carpal_distal_phalanx_1',
    'l_trapezoid',
    'l_metacarpal_2',
    'l_carpal_proximal_phalanx_2',
    'l_carpal_middle_phalanx_2',
    'l_carpal_distal_phalanx_2',
    'l_capitate',
    'l_metacarpal_3',
    'l_carpal_proximal_phalanx_3',
    'l_carpal_middle_phalanx_3',
    'l_carpal_distal_phalanx_3',
    'l_hamate',
    'l_metacarpal_4',
    'l_carpal_proximal_phalanx_4',
    'l_carpal_middle_phalanx_4',
    'l_carpal_distal_phalanx_4',
    'l_metacarpal_5',
    'l_carpal_proximal_phalanx_5',
    'l_carpal_middle_phalanx_5',
    'l_carpal_distal_phalanx_5',
    'r_clavicle',
    'r_scapula',
    'r_upperarm',
    'r_forearm',
    'r_carpal',
    'r_trapezium',
    'r_metacarpal_1',
    'r_carpal_proximal_phalanx_1',
    'r_carpal_distal_phalanx_1',
    'r_trapezoid',
    'r_metacarpal_2',
    'r_carpal_proximal_phalanx_2',
    'r_carpal_middle_phalanx_2',
    'r_carpal_distal_phalanx_2',
    'r_capitate',
    'r_metacarpal_3',
    'r_carpal_proximal_phalanx_3',
    'r_carpal_middle_phalanx_3',
    'r_carpal_distal_phalanx_3',
    'r_hamate',
    'r_metacarpal_4',
    'r_carpal_proximal_phalanx_4',
    'r_carpal_middle_phalanx_4',
    'r_carpal_distal_phalanx_4',
    'r_metacarpal_5',
    'r_carpal_proximal_phalanx_5',
    'r_carpal_middle_phalanx_5',
    'r_carpal_distal_phalanx_5'
)

HANIMVERSIONCHOICES = (
    # strict set of allowed values follow, no other values are valid
    '2.0'  # Revised standard HAnim 19774 version 2 (parts 1 and 2) were approved by ISO in November 2019, published by Web3D Consortium May 2020.
)
def assertValidHanimVersion(fieldName, value):
    """
    Utility function to assert type validity of hanimVersionChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in HANIMVERSIONCHOICES:
        # print('*** assertValidHanimVersion ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in HANIMVERSIONCHOICES:
        # print('*** assertValidHanimVersion ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in HANIMVERSIONCHOICES=' + str(HANIMVERSIONCHOICES))

HATCHSTYLEVALUES = (
    # specification-defined values follow, other values are also allowed
    '1',  # Horizontal equally spaced parallel lines
    '2',  # Vertical equally spaced parallel lines
    '3',  # Positive slope equally spaced parallel lines
    '4',  # Negative slope equally spaced parallel lines
    '5',  # Horizontal/vertical crosshatch
    '6',  # Positive slope/negative slope crosshatch
    '7',  # (cast iron or malleable iron and general use for all materials)
    '8',  # (steel)
    '9',  # (bronze, brass, copper, and compositions)
    '10',  # (white metal, zinc, lead, babbit, and alloys)
    '11',  # (magnesium, aluminum, and aluminum alloys)
    '12',  # (rubber, plastic, and electrical insulation)

    '13',  # (cork, felt, fabric, leather, and fibre/fiber)
    '14',  # (thermal insulation)
    '15',  # (titanium and refi-actory material)
    '16',  # (marble, slate, porcelain, glass, etc.)
    '17',  # (earth)
    '18',  # (sand)
    '19'  # (repeating dot)
)

# Enumeration alias values
HATCHSTYLEVALUES_HORIZONTAL = 1
HATCHSTYLEVALUES_VERTICAL = 2
HATCHSTYLEVALUES_POSITIVE_SLOPE = 3
HATCHSTYLEVALUES_NEGATIVE_SLOPE = 4
HATCHSTYLEVALUES_HORIZONTAL_VERTICAL_CROSSHATCH = 5
HATCHSTYLEVALUES_POSITIVE_NEGATIVE_SLOPE_CROSSHATCH = 6
HATCHSTYLEVALUES_CAST_IRON = 7
HATCHSTYLEVALUES_STEEL = 8
HATCHSTYLEVALUES_BRONZE_BRASS_COPPER_COMPOSITIONS = 9
HATCHSTYLEVALUES_WHITE_METAL_ZINC_LEAD_BABBIT_ALLOYS = 10
HATCHSTYLEVALUES_MAGNESIUM_ALUMINUM_ALLOYS = 11
HATCHSTYLEVALUES_RUBBER_PLASTIC_ELECTRICAL_INSULATION = 12
HATCHSTYLEVALUES_CORK_FELT_FABRIC_LEATHER_FIBRE = 13
HATCHSTYLEVALUES_THERMAL_INSULATION = 14
HATCHSTYLEVALUES_TITANIUM = 15
HATCHSTYLEVALUES_MARBLE_SLATE_PORCELAIN_GLASS = 16
HATCHSTYLEVALUES_EARTH = 17
HATCHSTYLEVALUES_SAND = 18
HATCHSTYLEVALUES_REPEATING_DOT = 19

INTERSECTIONTYPEVALUES = (
    # specification-defined values follow, other values are also allowed
    'BOUNDS',  # TODO undefined in X3D specification
    'GEOMETRY'  # TODO undefined in X3D specification
)

JUSTIFYCHOICES = (
    # note these MFString values use XML syntax
    # strict set of allowed values follow, no other values are valid
    '"MIDDLE"',
    '"MIDDLE" "BEGIN"',
    '"MIDDLE" "END"',
    '"MIDDLE" "FIRST"',
    '"MIDDLE" "MIDDLE"',
    '"BEGIN"',
    '"BEGIN" "BEGIN"',
    '"BEGIN" "END"',
    '"BEGIN" "FIRST"',
    '"BEGIN" "MIDDLE"',
    '"END"',
    '"END" "BEGIN"',
    '"END" "END"',
    '"END" "FIRST"',
    '"END" "MIDDLE"',
    '"FIRST"',
    '"FIRST" "BEGIN"',
    '"FIRST" "END"',
    '"FIRST" "FIRST"',
    '"FIRST" "MIDDLE"'
)
def assertValidJustify(fieldName, value):
    """
    Utility function to assert type validity of justifyChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in JUSTIFYCHOICES:
        # print('*** assertValidJustify ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in JUSTIFYCHOICES:
        # print('*** assertValidJustify ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in JUSTIFYCHOICES=' + str(JUSTIFYCHOICES))

LAYOUTALIGNCHOICES = (
    # note these MFString values use XML syntax
    # strict set of allowed values follow, no other values are valid
    '"LEFT" "BOTTOM"',
    '"LEFT" "CENTER"',
    '"LEFT" "TOP"',
    '"CENTER" "BOTTOM"',
    '"CENTER" "CENTER"',
    '"CENTER" "TOP"',
    '"RIGHT" "BOTTOM"',
    '"RIGHT" "CENTER"',
    '"RIGHT" "TOP"'
)
def assertValidLayoutAlign(fieldName, value):
    """
    Utility function to assert type validity of layoutAlignChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in LAYOUTALIGNCHOICES:
        # print('*** assertValidLayoutAlign ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in LAYOUTALIGNCHOICES:
        # print('*** assertValidLayoutAlign ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in LAYOUTALIGNCHOICES=' + str(LAYOUTALIGNCHOICES))

LAYOUTSCALEMODECHOICES = (
    # note these MFString values use XML syntax
    # strict set of allowed values follow, no other values are valid
    '"NONE" "NONE"',
    '"NONE" "FRACTION"',
    '"NONE" "STRETCH"',
    '"NONE" "PIXEL"',
    '"FRACTION" "NONE"',
    '"FRACTION" "FRACTION"',
    '"FRACTION" "STRETCH"',
    '"FRACTION" "PIXEL"',
    '"STRETCH" "NONE"',
    '"STRETCH" "FRACTION"',
    '"STRETCH" "STRETCH"',
    '"STRETCH" "PIXEL"',
    '"PIXEL" "NONE"',
    '"PIXEL" "FRACTION"',
    '"PIXEL" "STRETCH"',
    '"PIXEL" "PIXEL"'
)
def assertValidLayoutScaleMode(fieldName, value):
    """
    Utility function to assert type validity of layoutScaleModeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in LAYOUTSCALEMODECHOICES:
        # print('*** assertValidLayoutScaleMode ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in LAYOUTSCALEMODECHOICES:
        # print('*** assertValidLayoutScaleMode ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in LAYOUTSCALEMODECHOICES=' + str(LAYOUTSCALEMODECHOICES))

LAYOUTUNITSCHOICES = (
    # note these MFString values use XML syntax
    # strict set of allowed values follow, no other values are valid
    '"WORLD" "WORLD"',
    '"WORLD" "FRACTION"',
    '"WORLD" "PIXEL"',
    '"FRACTION" "WORLD"',
    '"FRACTION" "FRACTION"',
    '"FRACTION" "PIXEL"',
    '"PIXEL" "WORLD"',
    '"PIXEL" "FRACTION"',
    '"PIXEL" "PIXEL"'
)
def assertValidLayoutUnits(fieldName, value):
    """
    Utility function to assert type validity of layoutUnitsChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in LAYOUTUNITSCHOICES:
        # print('*** assertValidLayoutUnits ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in LAYOUTUNITSCHOICES:
        # print('*** assertValidLayoutUnits ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in LAYOUTUNITSCHOICES=' + str(LAYOUTUNITSCHOICES))

LINETYPEVALUES = (
    # specification-defined values follow, other values are also allowed
    '1',  # Solid
    '2',  # Dashed
    '3',  # Dotted
    '4',  # Dashed-dotted
    '5',  # Dash-dot-dot
    '6',  # (single arrow)
    '7',  # (single dot)
    '8',  # (double arrow)
    '9',  # (stitch line)
    '10',  # (chain line)
    '11',  # (center line)
    '12',  # (hidden line)
    '13',  # (phantom line)
    '14',  # (break line - style 1)
    '15',  # (break line - style 2)
    '16'  # User-specified dash pattern
)

# Enumeration alias values
LINETYPEVALUES_SOLID = 1
LINETYPEVALUES_DASHED = 2
LINETYPEVALUES_DOTTED = 3
LINETYPEVALUES_DASHED_DOTTED = 4
LINETYPEVALUES_DASHED_DOT_DOT = 5
LINETYPEVALUES_SINGLE_ARROW = 6
LINETYPEVALUES_SINGLE_DOT = 7
LINETYPEVALUES_DOUBLE_ARROW = 8
LINETYPEVALUES_STITCH_LINE = 9
LINETYPEVALUES_CHAIN_LINE = 10
LINETYPEVALUES_CENTER_LINE = 11
LINETYPEVALUES_HIDDEN_LINE = 12
LINETYPEVALUES_PHANTOM_LINE = 13
LINETYPEVALUES_BREAK_LINE_STYLE_1 = 14
LINETYPEVALUES_BREAK_LINE_STYLE_2 = 15
LINETYPEVALUES_USER_SPECIFIED_DASH_PATTERN = 16

METADIRECTIONCHOICES = (
    # strict set of allowed values follow, no other values are valid
    'rtl',  # right-to-left
    'ltr'  # left-to-right
)
def assertValidMetaDirection(fieldName, value):
    """
    Utility function to assert type validity of metaDirectionChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in METADIRECTIONCHOICES:
        # print('*** assertValidMetaDirection ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in METADIRECTIONCHOICES:
        # print('*** assertValidMetaDirection ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in METADIRECTIONCHOICES=' + str(METADIRECTIONCHOICES))

METANAMEVALUES = (
    # specification-defined values follow, other values are also allowed
    'accessRights',  # permission required to access resource or security status
    'author',  # name of individual author
    'CML-version',  # Chemistry Markup Language (CML) version used
    'contributor',  # name of individual contributing to this resource
    'created',  # date of initial version
    'creator',  # name of original author
    'description',  # summary overview describing this resource
    'disclaimer',  # statement of denial or disavowal regarding potential claims or responsiblity
    'drawing',  # name or reference link to a supporting drawing or sketch file
    'error',  # information about an error (or known problem) that can prevent proper operation
    'generator',  # authoring tool or translation tool
    'hint',  # user hint about resource features or operation
    'identifier',  # url address or unique Uniform Resource Identifier (URI) for resource
    'Image',  # name or reference link to supporting image file
    'info',  # additional info of interest
    'information',  # additional information of interest
    'isVersionOf',  # Related resource of which the described resource is a version, edition, or adaptation.
    'keywords',  # comma-separated tokens, each of which is a keyword of interest
    'license',  # content or software license
    'mediator',  # entity that mediates access to resource and for whom resource is intended or useful
    'modified',  # date of modified version
    'movie',  # name or reference link to supporting movie file (note that Dublin Core term is MovingImage)
    'MovingImage',  # name or reference link to supporting movie
    'original',  # name or reference link to original file or resource
    'photo',  # name or reference link to supporting photo file (note that Dublin Core term is Image)
    'photograph',  # name or reference link to supporting photograph file (note that Dublin Core term is Image)
    'publisher',  # entity responsible for making the resource available
    'reference',  # name or reference link to supporting reference
    'requires',  # prerequisites for operation or viewing
    'rights',  # intellectual property rights (IPR)
    'robots',  # search engine and web-spider guidance value: noindex to block page indexing, nofollow to block following links
    'Sound',  # name or reference link to supporting sound file
    'source',  # related resource from which the described resource is derived
    'specificationSection',  # title of relevant specification section
    'specificationUrl',  # url for relevant specification section
    'subject',  # search-index subject keywords, key phrases, or classification codes
    'Text',  # resource consisting primarily of words for reading
    'title',  # file name for this resource
    'TODO',  # action item "to do" that still needs to be performed
    'translator',  # name of person performing translation from another format or language
    'translated',  # date of translation from another format or language
    'version',  # current version number or ID of this resource
    'warning'  # warning information about a known problem that impedes proper operation
)

MULTITEXTUREFUNCTIONVALUES = (
    # specification-defined values follow, other values are also allowed
    '"COMPLEMENT"',  # Invert argument x as (1 - x)
    '"ALPHAREPLICATE"',  # Replicate alpha information to all color channels before operation completes.
    '""'  # No function is applied - empty SFString is allowed value within MFString array
)

MULTITEXTUREMODEVALUES = (
    # specification-defined values follow, other values are also allowed
    '"ADD"',
    '"ADDSIGNED"',
    '"ADDSIGNED2X"',
    '"ADDSMOOTH"',
    '"BLENDCURRENTALPHA"',
    '"BLENDDIFFUSEALPHA"',
    '"BLENDFACTORALPHA"',
    '"BLENDTEXTUREALPHA"',
    '"DOTPRODUCT3"',
    '"MODULATE"',
    '"MODULATE2X"',
    '"MODULATE4X"',
    '"MODULATEALPHA_ADDCOLOR"',
    '"MODULATEINVALPHA_ADDCOLOR"',
    '"MODULATEINVCOLOR_ADDALPHA"',
    '"OFF"',
    '"REPLACE"',
    '"SELECTARG1"',
    '"SELECTARG2"',
    '"SUBTRACT"'
)

MULTITEXTURESOURCEVALUES = (
    # specification-defined values follow, other values are also allowed
    '"DIFFUSE"',
    '"FACTOR"',
    '"SPECULAR"',
    '""'
)

NAVIGATIONTRANSITIONTYPEVALUES = (
    # specification-defined values follow, other values are also allowed
    '"TELEPORT"',  # immediate transition
    '"LINEAR"',  # transition may proceed directly through intervening objects
    '"ANIMATE"'  # rowser-specific transition
)

NAVIGATIONTYPEVALUES = (
    # specification-defined values follow, other values are also allowed
    '"ANY"',  # browser can offer any type for user to choose
    '"WALK"',  # free navigation, avatar remains on ground, collision detection
    '"EXAMINE"',  # view an individual object by rotating view about center
    '"FLY"',  # free navigation, collision detection
    '"LOOKAT"',  # navigate to particular object
    '"NONE"',  # disables all navigation interfaces
    '"EXPLORE"'  # consistent keystroke navigation for both geospatial and Cartesian modes
)

NETWORKMODECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'standAlone',  # ignore network but still respond to events in local scene
    'networkReader',  # listen to network and read PDU packets at readInterval, act as remotely linked copy of entity
    'networkWriter'  # send PDU packets to network at writeInterval, act as master entity
)
def assertValidNetworkMode(fieldName, value):
    """
    Utility function to assert type validity of networkModeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in NETWORKMODECHOICES:
        # print('*** assertValidNetworkMode ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in NETWORKMODECHOICES:
        # print('*** assertValidNetworkMode ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in NETWORKMODECHOICES=' + str(NETWORKMODECHOICES))

PARTICLESYSTEMGEOMETRYTYPEVALUES = (
    # specification-defined values follow, other values are also allowed
    'LINE',  # line is drawn along current velocity vector of particle
    'POINT',  # point geometry is rendered at particle position
    'QUAD',  # quad geometry is rendered at particle position facing direction traveled
    'SPRITE',  # quad geometry is rendered at particle position facing screen
    'TRIANGLE',  # pair of triangles creating quad geometry is rendered at particle position facing direction traveled
    'GEOMETRY'  # geometry field is used for rendering each particle
)

PERIODICWAVETYPECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'SINE',  # X3D version of "sine" in Web Audio API.
    'SQUARE',  # X3D version of "square" in Web Audio API.
    'SAWTOOTH',  # X3D version of "sawtooth" in Web Audio API.
    'TRIANGLE',  # X3D version of "triangle" in Web Audio API.
    'CUSTOM'  # X3D version of "custom" in Web Audio API.
)
def assertValidPeriodicWaveType(fieldName, value):
    """
    Utility function to assert type validity of periodicWaveTypeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in PERIODICWAVETYPECHOICES:
        # print('*** assertValidPeriodicWaveType ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in PERIODICWAVETYPECHOICES:
        # print('*** assertValidPeriodicWaveType ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in PERIODICWAVETYPECHOICES=' + str(PERIODICWAVETYPECHOICES))

PHASEFUNCTIONVALUES = (
    # specification-defined values follow, other values are also allowed
    'Henyey-Greenstein',  # Henyey-Greenstein phase function for scattering model
    'NONE'  # no scattering
)

PICKABLEOBJECTTYPEVALUES = (
    # specification-defined values follow, other values are also allowed
    '"ALL"',  # each node is available for picking
    '"NONE"',  # no node is available for picking
    '"TERRAIN"'  # TERRAIN is an example value
)

PICKSENSORMATCHCRITERIONCHOICES = (
    # strict set of allowed values follow, no other values are valid
    'MATCH_ANY',  # any match of objectType values is acceptable
    'MATCH_EVERY',  # every objectType value in X3DPickSensorNode and X3DPickableObject shall match
    'MATCH_ONLY_ONE'  # one and only one objectType value can match
)
def assertValidPickSensorMatchCriterion(fieldName, value):
    """
    Utility function to assert type validity of pickSensorMatchCriterionChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in PICKSENSORMATCHCRITERIONCHOICES:
        # print('*** assertValidPickSensorMatchCriterion ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in PICKSENSORMATCHCRITERIONCHOICES:
        # print('*** assertValidPickSensorMatchCriterion ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in PICKSENSORMATCHCRITERIONCHOICES=' + str(PICKSENSORMATCHCRITERIONCHOICES))

PICKSENSORSORTORDERVALUES = (
    # specification-defined values follow, other values are also allowed
    'ANY',  # any single object that can satisfy picking conditions
    'CLOSEST',  # return closest object by distance that satisfies conditions of this pick sensor
    'ALL',  # every object that satisfies picking conditions for this pick sensor is returned
    'ALL_SORTED'  # every object that satisfies picking conditions for this pick sensor is returned, in sorted order
)

PROFILENAMECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'Core',  # Core Profile includes no nodes and is provided as the basis for custom componentization. Allowed X3D statements for all profiles are: connect ExternProtoDeclare EXPORT field fieldValue IMPORT IS ProtoBody ProtoDeclare ProtoInterface ProtoInstance ROUTE X3D. Allowed X3D nodes for this profile are: MetadataBoolean MetadataDouble MetadataFloat MetadataInteger MetadataSet MetadataString.
    'Interchange',  # Interchange Profile equals the minimum subset of nodes needed to display lightweight compelling content. Allowed X3D nodes for this profile are: Appearance Background Box Color ColorInterpolator ColorRGBA Cone Coordinate CoordinateInterpolator Cylinder DirectionalLight Group ImageTexture IndexedFaceSet IndexedLineSet IndexedTriangleFanSet IndexedTriangleSet IndexedTriangleStripSet LineSet Material MetadataBoolean MetadataDouble MetadataFloat MetadataInteger MetadataSet MetadataString MultiTexture MultiTextureCoordinate MultiTextureTransform NavigationInfo Normal NormalInterpolator OrientationInterpolator PixelTexture PointSet PositionInterpolator ScalarInterpolator Shape Sphere TextureCoordinate TextureCoordinateGenerator TextureTransform TimeSensor Transform TriangleFanSet TriangleSet TriangleStripSet Viewpoint WorldInfo.
    'CADInterchange',  # CADInterchange Profile adds support for CADGeometry component nodes to Interchange Profile. Allowed X3D nodes for this profile are: Anchor Appearance CADAssembly CADFace CADLayer CADPart Billboard Collision Color ColorRGBA Coordinate DirectionalLight FragmentShader Group ImageTexture IndexedLineSet IndexedQuadSet IndexedTriangleFanSet IndexedTriangleSet IndexedTriangleStripSet Inline LineProperties LineSet LOD Material MetadataBoolean MetadataDouble MetadataFloat MetadataInteger MetadataSet MetadataString MultiShader MultiTexture MultiTextureCoordinate MultiTextureTransform NavigationInfo Normal PixelTexture PointSet QuadSet Shader ShaderAppearance Shape TextureCoordinate TextureCoordinateGenerator TextureTransform Transform TriangleFanSet TriangleSet TriangleStripSet Viewpoint VertexShader WorldInfo.
    'Interactive',  # Interactive Profile adds interaction nodes (Anchor, KeySensor) to the minimum subset of nodes needed to display lightweight compelling content. Allowed X3D nodes for this profile are: Anchor Appearance Background BooleanFilter BooleanSequencer BooleanToggle BooleanTrigger Box Color ColorInterpolator ColorRGBA Cone Coordinate CoordinateInterpolator Cylinder CylinderSensor DirectionalLight ElevationGrid Group ImageTexture IndexedFaceSet IndexedLineSet IndexedTriangleFanSet IndexedTriangleSet IndexedTriangleStripSet Inline IntegerSequencer IntegerTrigger KeySensor LineSet Material MetadataBoolean MetadataDouble MetadataFloat MetadataInteger MetadataSet MetadataString MultiTexture MultiTextureCoordinate MultiTextureTransform NavigationInfo Normal NormalInterpolator OrientationInterpolator IndexedTriangleStripSet Inline IntegerSequencer IntegerTrigger KeySensor LineSet Material MetadataBoolean MetadataDouble MetadataFloat MetadataInteger MetadataSet MetadataString MultiTexture MultiTextureCoordinate MultiTextureTransform NavigationInfo Normal NormalInterpolator OrientationInterpolator PixelTexture PlaneSensor PointLight PointSet PositionInterpolator ProximitySensor ScalarInterpolator Shape Sphere SphereSensor SpotLight StringSensor Switch TextureCoordinate TextureCoordinateGenerator TextureTransform TimeSensor TimeTrigger TouchSensor Transform TriangleFanSet TriangleSet TriangleStripSet Viewpoint VisibilitySensor WorldInfo.
    'Immersive',  # Immersive Profile equals all of the nodes in the VRML97 Specification, plus various X3D node additions including KeySensor, StringSensor and Scene. Allowed X3D nodes for this profile are: Anchor Appearance AudioClip Background Billboard BooleanFilter BooleanSequencer BooleanToggle BooleanTrigger Box Collision Color ColorInterpolator ColorRGBA Cone Coordinate CoordinateInterpolator Cylinder CylinderSensor DirectionalLight ElevationGrid Extrusion Fog FontStyle Group ImageTexture IndexedFaceSet IndexedLineSet IndexedTriangleFan IndexedTriangleSet IndexedTriangleStripSet Inline IntegerSequencer IntegerTrigger KeySensor LineProperties LineSet LoadSensor LOD Material MetadataBoolean MetadataDouble MetadataFloat MetadataInteger MetadataSet MetadataString MovieTexture MultiTexture MultiTextureCoordinate MultiTextureTransform NavigationInfo Normal NormalInterpolator OrientationInterpolator PixelTexture PlaneSensor PointLight PointSet Polyline2D Polypoint2D PositionInterpolator ProximitySensor Rectangle2D ScalarInterpolator Script Shape Sound Sphere SphereSensor SpotLight StringSensor Switch Text TextureCoordinate TextureCoordinateGenerator TextureTransform TimeSensor TimeTrigger TouchSensor TriangleFanSet TriangleSet TriangleSet2D TriangleStripSet Transform Viewpoint VisibilitySensor WorldInfo.
    'MedicalInterchange',  # The MedicalInterchange profile adds support for VolumeRendering component to Interchange profile. Allowed X3D nodes for this profile are: Anchor Arc2D ArcClose2D Appearance Background Billboard BlendedVolumeStyle BooleanFilter BooleanSequencer BooleanToggle BooleanTrigger BoundaryEnhancementVolumeStyle Box CartoonVolumeStyle Circle2D ClipPlane Collision Color ColorInterpolator ColorRGBA ComposedVolumeStyle CompositeTexture3D Cone Coordinate CoordinateDouble CoordinateInterpolator Cylinder DirectionalLight Disk2D EdgeEnhancementVolumeStyle FillProperties FontStyle Group ImageTexture ImageTexture3D IndexedFaceSet IndexedLineSet IndexedTriangleFanSet IndexedTriangleSet IndexedTriangleStripSet Inline IntegerSequencer IntegerTrigger IsoSurfaceVolumeData LineProperties LineSet LOD Material MetadataBoolean MetadataDouble MetadataFloat MetadataInteger MetadataSet MetadataString MultiTexture MultiTextureCoordinate MultiTextureTransform NavigationInfo Normal NormalInterpolator OctTree OpacityMapVolumeStyle OrientationInterpolator OrthoViewpoint PixelTexture PixelTexture3D PointSet Polyline2D Polypoint2D PositionInterpolator ProjectionVolumeStyle Rectangle2D ScalarInterpolator SegmentedVolumeData ShadedVolumeStyle Shape SilhouetteEnhancementVolumeStyle Sphere StaticGroup Switch Text TextureCoordinate TextureCoordinate3D TextureCoordinate4D TextureCoordinateGenerator TextureMatrixTransform TextureProperties TextureTransform TextureTransform3D TimeSensor TimeTrigger ToneMappedVolumeStyle Transform TriangleFanSet TriangleSet TriangleStripSet Viewpoint ViewpointGroup VolumeData WorldInfo.
    'MPEG4Interactive',  # MPEGInteractive Profile defines base interoperability with MPEG4 standards to a small subset of nodes needed to display lightweight compelling content. Allowed X3D nodes for this profile are: Anchor Appearance Background Box Color ColorInterpolator ColorRGBA Cone Coordinate CoordinateInterpolator Cylinder CylinderSensor DirectionalLight ElevationGrid Group ImageTexture IndexedFaceSet IndexedLineSet Inline LineSet Material MetadataBoolean MetadataDouble MetadataFloat MetadataInteger MetadataSet MetadataString NavigationInfo NormalInterpolator OrientationInterpolator PixelTexture PlaneSensor PointLight PointSet PositionInterpolator ProximitySensor ScalarInterpolator Shape Sphere SphereSensor SpotLight Switch TextureCoordinate TextureTransform TimeSensor TouchSensor Transform Viewpoint WorldInfo.
    'Full'  # The Full Profile corresponds to all Immersive X3D nodes plus all approved/implemented extensions. All X3D nodes and statements are allowed in this profile.
)
def assertValidProfileName(fieldName, value):
    """
    Utility function to assert type validity of profileNameChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in PROFILENAMECHOICES:
        # print('*** assertValidProfileName ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in PROFILENAMECHOICES:
        # print('*** assertValidProfileName ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in PROFILENAMECHOICES=' + str(PROFILENAMECHOICES))

PROJECTIONVOLUMESTYLETYPECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'MAX',  # Maximum Intensity Projection (MIP) or Least MIP (LMIP) algorithm is used to generate output color
    'MIN',  # Minimum Intensity Projection algorithm is used to generate output color
    'AVERAGE'  # All voxels along ray are averaged to generate output color
)
def assertValidProjectionVolumeStyleType(fieldName, value):
    """
    Utility function to assert type validity of projectionVolumeStyleTypeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in PROJECTIONVOLUMESTYLETYPECHOICES:
        # print('*** assertValidProjectionVolumeStyleType ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in PROJECTIONVOLUMESTYLETYPECHOICES:
        # print('*** assertValidProjectionVolumeStyleType ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in PROJECTIONVOLUMESTYLETYPECHOICES=' + str(PROJECTIONVOLUMESTYLETYPECHOICES))

SHADERLANGUAGEVALUES = (
    # specification-defined values follow, other values are also allowed
    'Cg',  # nVidia Cg shading language
    'GLSL',  # OpenGL shading language (GLSL)
    'HLSL'  # Microsoft High Level Shading Language (HLSL)
)

SHADERPARTTYPEVALUES = (
    # specification-defined values follow, other values are also allowed
    'VERTEX',  # vertex shader
    'FRAGMENT'  # fragment shader
)

TEXTUREBOUNDARYMODECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'CLAMP',  # Clamp texture coordinates to range [0,1]
    'CLAMP_TO_EDGE',  # Clamp texture coordinates such that a border texel is never sampled
    'CLAMP_TO_BOUNDARY',  # Clamp texture coordinates such that texture samples are border texels for fragments
    'MIRRORED_REPEAT',  # Texture coordinates are mirrored and then clamped as in CLAMP_TO_EDGE
    'REPEAT'  # Repeat a texture across the fragment
)
def assertValidTextureBoundaryMode(fieldName, value):
    """
    Utility function to assert type validity of textureBoundaryModeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in TEXTUREBOUNDARYMODECHOICES:
        # print('*** assertValidTextureBoundaryMode ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in TEXTUREBOUNDARYMODECHOICES:
        # print('*** assertValidTextureBoundaryMode ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in TEXTUREBOUNDARYMODECHOICES=' + str(TEXTUREBOUNDARYMODECHOICES))

TEXTURECOMPRESSIONMODECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'DEFAULT',  # browser-specified default compression mode
    'FASTEST',  # fastest method available
    'HIGH',  # greatest amount of compression
    'LOW',  # least amount of compression
    'MEDIUM',  # moderate amount of compressions
    'NICEST'  # highest quality method available
)
def assertValidTextureCompressionMode(fieldName, value):
    """
    Utility function to assert type validity of textureCompressionModeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in TEXTURECOMPRESSIONMODECHOICES:
        # print('*** assertValidTextureCompressionMode ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in TEXTURECOMPRESSIONMODECHOICES:
        # print('*** assertValidTextureCompressionMode ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in TEXTURECOMPRESSIONMODECHOICES=' + str(TEXTURECOMPRESSIONMODECHOICES))

TEXTURECOORDINATEGENERATORMODECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'SPHERE',  # Creates texture coordinates for a spherical environment
    'CAMERASPACENORMAL',  # Use vertex normal, transformed to camera space, as input texture coordinates
    'CAMERASPACEPOSITION',  # Use vertex position, transformed to camera space, as input texture coordinates
    'CAMERASPACEREFLECTIONVECTOR',  # Use reflection vector, transformed to camera space, as input texture coordinates
    'SPHERE-LOCAL',  # Sphere mapping but in local coordinates
    'COORD',  # Use vertex coordinates
    'COORD-EYE',  # Use vertex coordinates transformed to camera space
    'NOISE',  # Apply Perlin solid noise function on vertex coordinates
    'NOISE-EYE',  # Apply Perlin solid noise function on vertex coordinates transformed to camera space
    'SPHERE-REFLECT',  # similar to CAMERASPACEREFLECTIONVECTOR with optional index of refraction
    'SPHERE-REFLECT-LOCAL'  # Similar to SPHERE-REFLECT transformed to camera space
)
def assertValidTextureCoordinateGeneratorMode(fieldName, value):
    """
    Utility function to assert type validity of textureCoordinateGeneratorModeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in TEXTURECOORDINATEGENERATORMODECHOICES:
        # print('*** assertValidTextureCoordinateGeneratorMode ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in TEXTURECOORDINATEGENERATORMODECHOICES:
        # print('*** assertValidTextureCoordinateGeneratorMode ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in TEXTURECOORDINATEGENERATORMODECHOICES=' + str(TEXTURECOORDINATEGENERATORMODECHOICES))

TEXTUREMAGNIFICATIONMODECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'AVG_PIXEL',  # weighted average of four texture elements closest to center of pixel being textured
    'DEFAULT',  # browser-specified default magnification mode
    'FASTEST',  # fastest method available
    'NEAREST_PIXEL',  # texture element nearest to the center of pixel being textured
    'NICEST'  # highest quality method available
)
def assertValidTextureMagnificationMode(fieldName, value):
    """
    Utility function to assert type validity of textureMagnificationModeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in TEXTUREMAGNIFICATIONMODECHOICES:
        # print('*** assertValidTextureMagnificationMode ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in TEXTUREMAGNIFICATIONMODECHOICES:
        # print('*** assertValidTextureMagnificationMode ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in TEXTUREMAGNIFICATIONMODECHOICES=' + str(TEXTUREMAGNIFICATIONMODECHOICES))

TEXTUREMINIFICATIONMODECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'AVG_PIXEL',  # weighted average of four texture elements closest to center of pixel being textured
    'AVG_PIXEL_AVG_MIPMAP',  # tri-linear mipmap filtering
    'AVG_PIXEL_NEAREST_MIPMAP',  # choose mipmap that most closely matches size of pixel being textured, use weighted average of four texture elements closest to center of pixel
    'DEFAULT',  # browser-specified default minification mode
    'FASTEST',  # fastest method available, use mipmaps if possible
    'NEAREST_PIXEL',  # texture element nearest to center of pixel being textured
    'NEAREST_PIXEL_AVG_MIPMAP',  # texture element nearest to center of pixel being textured, use average of two nearest mipmaps
    'NEAREST_PIXEL_NEAREST_MIPMAP',  # texture element nearest to center of pixel being textured, use nearest mipmap
    'NICEST'  # highest quality method available
)
def assertValidTextureMinificationMode(fieldName, value):
    """
    Utility function to assert type validity of textureMinificationModeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in TEXTUREMINIFICATIONMODECHOICES:
        # print('*** assertValidTextureMinificationMode ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in TEXTUREMINIFICATIONMODECHOICES:
        # print('*** assertValidTextureMinificationMode ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in TEXTUREMINIFICATIONMODECHOICES=' + str(TEXTUREMINIFICATIONMODECHOICES))

UNITCATEGORYCHOICES = (
    # strict set of allowed values follow, no other values are valid
    'angle',  # angle default is radians
    'force',  # force default is newtons
    'length',  # length default is meters
    'mass'  # mass default is kilograms
)
def assertValidUnitCategory(fieldName, value):
    """
    Utility function to assert type validity of unitCategoryChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in UNITCATEGORYCHOICES:
        # print('*** assertValidUnitCategory ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in UNITCATEGORYCHOICES:
        # print('*** assertValidUnitCategory ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in UNITCATEGORYCHOICES=' + str(UNITCATEGORYCHOICES))

VOLUMERENDERINGWEIGHTFUNCTIONCHOICES = (
    # strict set of allowed values follow, no other values are valid
    'CONSTANT',  # Use weightConstant1
    'ALPHA1',  # Use O_v
    'ALPHA2',  # Use O_blend
    'ONE_MINUS_ALPHA1',  # Use 1 - O_v
    'ONE_MINUS_ALPHA2',  # Use 1 - O_blend
    'TABLE'  # Use table lookup value
)
def assertValidVolumeRenderingWeightFunction(fieldName, value):
    """
    Utility function to assert type validity of volumeRenderingWeightFunctionChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in VOLUMERENDERINGWEIGHTFUNCTIONCHOICES:
        # print('*** assertValidVolumeRenderingWeightFunction ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in VOLUMERENDERINGWEIGHTFUNCTIONCHOICES:
        # print('*** assertValidVolumeRenderingWeightFunction ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in VOLUMERENDERINGWEIGHTFUNCTIONCHOICES=' + str(VOLUMERENDERINGWEIGHTFUNCTIONCHOICES))

WAVESHAPEROVERSAMPLECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'NONE',  # No oversampling. X3D version of "none" in Web Audio API.
    '2X',  # Double sampling rate. X3D version of "2x" in Web Audio API.
    '4X'  # Quadruple sampling rate. X3D version of "4x" in Web Audio API.
)
def assertValidWaveShaperOversample(fieldName, value):
    """
    Utility function to assert type validity of waveShaperOversampleChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in WAVESHAPEROVERSAMPLECHOICES:
        # print('*** assertValidWaveShaperOversample ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in WAVESHAPEROVERSAMPLECHOICES:
        # print('*** assertValidWaveShaperOversample ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in WAVESHAPEROVERSAMPLECHOICES=' + str(WAVESHAPEROVERSAMPLECHOICES))

X3DVERSIONCHOICES = (
    # strict set of allowed values follow, no other values are valid
    '3.0',  # X3D version 3.0 approved by ISO in 2004.
    '3.1',  # X3D version 3.1 Amendment 1 approved by ISO in 2005. Backwards compatibility maintained with version 3.0.
    '3.2',  # X3D version 3.2 Amendment 2 approved by ISO in 2007. Backwards compatibility maintained with versions 3.0 and 3.1.
    '3.3',  # X3D version 3.3 approved by ISO in 2013 as International Standard (IS). Backwards compatibility maintained with versions 3.0, 3.1 and 3.2.
    '4.0'  # X3D version 4.0 under final development by Web3D Consortium. Backwards compatibility maintained with versions 3.0, 3.1, 3.2 and 3.3.
)
def assertValidX3dVersion(fieldName, value):
    """
    Utility function to assert type validity of x3dVersionChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in X3DVERSIONCHOICES:
        # print('*** assertValidX3dVersion ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in X3DVERSIONCHOICES:
        # print('*** assertValidX3dVersion ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in X3DVERSIONCHOICES=' + str(X3DVERSIONCHOICES))

###############################################

# Utility Functions

def metaDiagnostics(self, headElement=None):
    """
    Utility function to return any meta info, hint, warning, error, TODO values in this model.
    """
    if  headElement is None:
        headElement = self
    if  isinstance(headElement, X3D):
        headElement = headElement.head
    # print('type(headElement)=' + str(type(headElement)), flush=True) # diagnostic
    if  isinstance(headElement, head):
        result = "meta information, "
        for each in headElement.children:
            if isinstance(each, meta) and each.name in ('info', 'hint', 'warning', 'error', 'TODO'):
                result += each.name.strip() + ': ' + each.content.strip()
                if  result.endswith('.') or result.endswith(','):
                    result += ' '
                else:
                    result += ', '
        if  result.strip() != "meta information,":
            return result.rstrip(', ').strip()
    return ''

def prependLineNumbers(someText="", lineNumber=0, blockInterval = 3):
    """
    Utility function to prepend line numbers to block of text, can optionally define lineNumber and blockInterval.
    """
    # https://stackoverflow.com/questions/64621076/how-to-add-line-numbers-to-multiline-string
    result = ''
    count = 1
    splitLines = someText.splitlines()
    if not lineNumber:
        lineNumber = 0
    if lineNumber == 0:
        first = 0
        last  = len(splitLines)
    else:
        first = max(lineNumber - blockInterval - 1, 0)
        last  = min(lineNumber + blockInterval,     len(splitLines))
        print("*** issue in line", str(lineNumber), "of", str(len(splitLines)), "***") # "first=" + str(first), "last=" + str(last) +
    for line in splitLines[first:last]:
        result += ("{}{:2d}{}{}".format("[",first + count,"] ",line)) + '\n'
        count += 1
    return result

###############################################

# Field Validation Functions

# Type-specific functions to check for valid values, throw exception if illegal value is found

def fixBoolean(value, default=None):
    """
    Utility function to convert boolean to corresponding Python value.
    """
    # if _DEBUG: print('fixBoolean(value=' + str(value) + ', type=' + str(type(value)) + ', default=' + str(default) + ')', flush=True)
    if  value is None:
        # if _DEBUG: print('...DEBUG... fixBoolean set value to default=' + str(default))
        return default
#   print('fixBoolean #0a')
#    if isinstance(value, MFBool):
#        value = value.value # dereference
#       print('fixBoolean #0a dereferenced')
#   print('fixBoolean #0b')
    if isinstance(value, list) and len(value) == 0:
        return value
#   print('fixBoolean #1') # debug
    if isinstance(value, list) and len(value) == 1:
        # if _DEBUG: print('fixBoolean downcasting by resetting singleton list value=' + str(value) + ' as value=' + str(value[0]), flush=True)
        return value[0] # dereference
    if isinstance(value, SFBool):
        return value.value # dereference
    if isinstance(value, MFBool) and len(value) == 1:
        return value.value[0] # dereference
#   print('fixBoolean #2') # debug
    if value in ('true', 'True'):
        return True
    if value in ('false', 'False'):
        return False
#   print('fixBoolean #3') # debug
    if isinstance(value, bool):
        return value
#   print('fixBoolean #4') # debug
    if isinstance(value, MFBool):
        value = value.value # dereference value from base type
#       print('fixBoolean #4a, dereference MFBool') # debug
    if isinstance(value, list):
#       print('fixBoolean #4b found list, value=' + str(value), ' length=' + str(len(value))) # debug
        index = 0
        result = value
        for each in value:
            if  each in ('true', 'True'):
                result[index] = True
            elif each in ('false', 'False'):
                result[index] = False
            while isinstance(each, list) and len(each) == 1:
                # if _DEBUG: print('fixBoolean downcasting by extracting singleton list value[' + str(index) + ']=' + str(each) + ' as each[0]=' + str(each[0]), flush=True)
                result[index] = each[0]
#           print('fixBoolean #4c found each=' + str(each), 'result=' + str(result), flush=True) # debug
            if not isinstance(result[index], bool):
                # print(flush=True)
                raise X3DTypeError('fixBoolean(value=' + str(value) + ') MFBool value[' + str(index) + ']=' + str(each) + ', result[' + str(index) + ']=' + str(result[index]) + ' with type=' + str(type(value)) + ' is not a valid Python bool expression')
            index += 1
        # if _DEBUG: print('...DEBUG...fixBoolean result=' + str(result), flush=True)
        return result
#   print('fixBoolean #5, unhandled case: value=' + str(value), ' length=' + str(len(value))) # debug
    print(flush=True)
    raise X3DTypeError('fixBoolean(value=' + str(value) + ') with type=' + str(type(value)) + ') is not a valid Python bool')

def isPositive(value):
    """
    Utility function to confirm positive value(s) greater than or equal to zero.
    """
    if  value is None:
        return None
    if isinstance(value, list) and any(isinstance(x, tuple) for x in value):
        for each in value:
            for element in each:
                if element <= 0:
                    return False
        return True
    if isinstance(value, (list, tuple)):
        for each in value:
            if each <= 0:
                return False
        return True
    if isinstance(value, (int, float)):
        return value > 0
    raise X3DTypeError('isPositive(value=' + str(value) + ') with type=' + str(type(value)) + ') is not a valid Python number')

def assertPositive(fieldName, value):
    """
    Utility function to raise X3DTypeError if not isPositive(value).
    """
    # if _DEBUG: print('...DEBUG... assertPositive(' + str(fieldName) + ', ' + str(value) + ')', flush=True)
    assert isPositive(value), str(fieldName) + '=' + str(value) + ' fails assertPositive requirements: value(s) must be greater than or equal to zero'

def isNonNegative(value):
    """
    Utility function to confirm nonnegative value(s) greater than or equal to zero.
    """
    if  value is None:
        return None
    if isinstance(value, list) and any(isinstance(x, tuple) for x in value):
        for each in value:
            for element in each:
                if element < 0:
                    return False
        return True
    if isinstance(value, (list, tuple)):
        # if _DEBUG: print('isNonNegative: ', value, flush=True)
        for each in value:
            if each < 0:
                return False
        return True
    if isinstance(value, (int, float)):
        return value >= 0
    raise X3DTypeError('isNonNegative(value=' + str(value) + ') with type=' + str(type(value)) + ') is not a valid Python number')

def assertNonNegative(fieldName, value):
    """
    Utility function to raise X3DTypeError if not isNonNegative(value).
    """
    # if _DEBUG: print('...DEBUG... assertNonNegative(' + str(fieldName) + ', ' + str(value) + ')', flush=True)
    assert isNonNegative(value), str(fieldName) + '=' + str(value) + ' fails assertNonNegative requirements: value(s) must be greater than or equal to zero'

def isZeroToOne(value):
    """
    Utility function to confirm value(s) in range [0..1]
    """
    # if _DEBUG: print('...DEBUG... isZeroToOne(' + str(value) + ')', flush=True)
    if  value is None:
        return None
    if isinstance(value,_X3DField):
        value = value.value # dereference
    if isinstance(value, (list, tuple)):
        for each in value:
            if isinstance(each, (list, tuple)):
                for another in each:
                    if not 0 <= another <= 1:
                        return False
            elif not 0 <= each <= 1:
                return False
        return True
    if isinstance(value, (int, float)):
        return 0 <= value <= 1
    raise X3DTypeError('isZeroToOne(value=' + str(value) + ') with type=' + str(type(value)) + ') is not a valid Python number')

def assertZeroToOne(fieldName, value):
    """
    Utility function to raise X3DTypeError if not isZeroToOne(value)
    """
    # if _DEBUG: print('...DEBUG... assertZeroToOne(' + str(fieldName) + ', ' + str(value) + ')', flush=True)
    assert isZeroToOne(value), str(fieldName) + '=' + str(value) + ' fails assertZeroToOne requirements: value(s) must be in range [0..1]'

def isLessThanEquals(value, maximum):
    """
    Utility function to confirm value(s) less than or equal to maximum.
    """
    # if True or _DEBUG: print('* debug: isLessThanEquals(' + str(value) + ')', flush=True)
    if  value is None:
        return None
    if isinstance(value, list) and any(isinstance(x, tuple) for x in value):
        for each in value:
            for element in each:
                if element > maximum:
                    return False
        return True
    if isinstance(value, (list, tuple)):
        for each in value:
            if each > maximum:
                return False
        return True
    if isinstance(value, (int, float)):
        return value <= maximum
    raise X3DTypeError('isLessThanEquals(value=' + str(value) + ') with type=' + str(type(value)) + ') is not a valid Python number')

def assertLessThanEquals(fieldName, value, maximum):
    """
    Utility function to raise X3DTypeError if not isLessThanEquals(value)
    """
    # if _DEBUG: print('...DEBUG... assertLessThanEquals(' + str(fieldName) + ', ' + str(value) + ')', flush=True)
    assert isLessThanEquals(value, maximum), fieldName + '=' + str(value) + ' fails assertLessThanEquals maximum=' + str(maximum)

def isLessThan(value, maximum):
    """
    Utility function to confirm value(s) less than maximum.
    """
    # if True or _DEBUG: print('* debug: isLessThan(' + str(value) + ')', flush=True)
    if  value is None:
        return None
    if isinstance(value, list) and any(isinstance(x, tuple) for x in value):
        for each in value:
            for element in each:
                if element >= maximum:
                    return False
        return True
    if isinstance(value, (list, tuple)):
        for each in value:
            if each >= maximum:
                return False
        return True
    if isinstance(value, (int, float)):
        return value < maximum
    raise X3DTypeError('isLessThan(value=' + str(value) + ') with type=' + str(type(value)) + ') is not a valid Python number')

def assertLessThan(fieldName, value, maximum):
    """
    Utility function to raise X3DTypeError if not isLessThan(value)
    """
    # if _DEBUG: print('...DEBUG... assertLessThan(' + str(fieldName) + ', ' + str(value) + ')', flush=True)
    assert isLessThan(value, maximum), str(fieldName) + '=' + str(value) + ' fails assertLessThan maximum=' + str(maximum)

######
def isGreaterThanEquals(value, minimum):
    """
    Utility function to confirm value(s) less than or equal to minimum.
    """
    # if True or _DEBUG: print('* debug: isGreaterThanEquals(' + str(value) + ')', flush=True)
    if  value is None:
        return None
    if isinstance(value, list) and any(isinstance(x, tuple) for x in value):
        for each in value:
            for element in each:
                if element < minimum:
                    return False
        return True
    if isinstance(value, (list, tuple)):
        for each in value:
            if each < minimum:
                return False
        return True
    if isinstance(value, (int, float)):
        return value >= minimum
    raise X3DTypeError('isGreaterThanEquals(value=' + str(value) + ') with type=' + str(type(value)) + ') is not a valid Python number')

def assertGreaterThanEquals(fieldName, value, minimum):
    """
    Utility function to raise X3DTypeError if not isGreaterThanEquals(value)
    """
    # if _DEBUG: print('...DEBUG... assertGreaterThanEquals(' + str(fieldName) + ', ' + str(value) + ')', flush=True)
    assert isGreaterThanEquals(value, minimum), str(fieldName) + '=' + str(value) + ' fails assertGreaterThanEquals minimum=' + str(minimum)

def isGreaterThan(value, minimum):
    """
    Utility function to confirm value(s) less than minimum.
    """
    # if True or _DEBUG: print('* debug: isGreaterThan(' + str(value) + ')', flush=True)
    if isinstance(value, list) and any(isinstance(x, tuple) for x in value):
        for each in value:
            for element in each:
                if element <= minimum:
                    return False
        return True
    if isinstance(value, (list, tuple)):
        for each in value:
            if each <= minimum:
                return False
        return True
    if isinstance(value, (int, float)):
        return value > minimum
    raise X3DTypeError('isGreaterThan(value=' + str(value) + ') with type=' + str(type(value)) + ') is not a valid Python number')

def assertGreaterThan(fieldName, value, minimum):
    """
    Utility function to raise X3DTypeError if not isGreaterThan(value)
    """
    # if _DEBUG: print('...DEBUG... assertGreaterThan(' + str(fieldName) + ', ' + str(value) + ')', flush=True)
    assert isGreaterThan(value, minimum), str(fieldName) + '=' + str(value) + ' fails assertGreaterThan minimum=' + str(minimum)

def isBoundingBox(value):
    """
    Utility function to confirm legal X3D bounding box value of (-1 -1 -1) or nonnegative triple.
    """
    if value is None:
        return None
    # if True or _DEBUG: print('* debug: isBoundingBox(' + str(value) + ')', 'isinstance(value, tuple)=' + str(isinstance(value, tuple)), 'len(value)=' + str(len(value)), flush=True)
    if isinstance(value, (list, tuple)):
        if len(value) != 3:
            return False
        if value[0] == -1 and value[1] == -1 and value[2] == -1:
            return True
        return isNonNegative(value) # legal bounding box tuple
    raise X3DTypeError('isBoundingBox(value=' + str(value) + ') with type=' + str(type(value)) + ') is not a valid Python numeric triple')

def assertBoundingBox(fieldName, value):
    """
    Utility function to raise X3DTypeError if not isBoundingBox(value)
    """
    # if True or _DEBUG: print('* debug: assertBoundingBox(' + str(fieldName) + ', ' + str(value) + ')', flush=True)
    assert isBoundingBox(value), str(fieldName) + '=' + str(value) + ' fails assertBoundingBox requirements: must be (-1, -1, -1) or non-negative 3-tuple'

def isValidSFBool(value):
    """
    Utility function to determine type validity of a SFBool value.
    """
    if re.fullmatch(SFBool().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch SFBool().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        SFBool(value)
        return True
    except ValueError:
        print('isValidSFBool failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFBool) and not isinstance(value, MFBool):
    ###         # if _DEBUG: print('SFBool type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFBool)=' + str(isinstance(value, SFBool)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, SFBool):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(SFBool().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, MFBool) and (len(value) == 1) and isValidMFBool(value):
    ###     value = value.value[0] # dereference value from this MF type
    ###     return True
    ### if not isinstance(value, bool):
    ###     return False
    ### return True

def assertValidSFBool(value):
    """
    Utility function to assert type validity of a SFBool value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        SFBool(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid SFBool') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFBool) and not isinstance(value, MFBool):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFBool')
    ### if isinstance(value, SFBool):
    ###     value = value.value # dereference value from this base type #2a
    ### elif isinstance(value, MFBool) and len(value) == 1:
    ###     value = value.value[0] # dereference value from this MF type #2b
    ### if not isinstance(value, bool):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid bool value (True or False) for SFBool')
    ### if not isValidSFBool(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python bool value (True or False) for SFBool')
    return True

def isValidMFBool(value):
    """
    Utility function to determine type validity of a MFBool value.
    """
    if re.fullmatch(MFBool().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch MFBool().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        MFBool(value)
        return True
    except ValueError:
        print('isValidMFBool failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFBool) and not isinstance(value, MFBool):
    ###         # if _DEBUG: print('MFBool type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFBool)=' + str(isinstance(value, MFBool)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, MFBool):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(MFBool().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, SFBool):
    ###     value = list(value.value) # dereference value from this SF type, convert to list #1
    ###     return True
    ### if not isinstance(value, list):
    ###     return False
    ### for each in value:
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFBool):
    ###         each = each.value # dereference
    ###     if not isinstance(each, bool):
    ###         return False
    ### return True

def assertValidMFBool(value):
    """
    Utility function to assert type validity of a MFBool value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        MFBool(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid MFBool') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFBool) and not isinstance(value, MFBool):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFBool')
    ### if isinstance(value, MFBool):
    ###     value = value.value # dereference value from this base type #2a
    ### elif (isinstance(value, SFBool)) and not isinstance(value, list):
        ### value = list(SFBool(value).value) # dereference value from this SF type, convert to list #2c
    ### if not isinstance(value, list):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFBool')
    ### # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    ### for each in value:
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFBool):
    ###         each = each.value # dereference
    ###     if not isinstance(each, bool):
    ###         # print(flush=True)
    ###         raise X3DTypeError('MFBool list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid bool')
    ### if not isValidMFBool(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFBool')
    return True

def isValidSFColor(value):
    """
    Utility function to determine type validity of a SFColor value.
    """
    if re.fullmatch(SFColor().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch SFColor().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        SFColor(value)
        return True
    except ValueError:
        print('isValidSFColor failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFColor) and not isinstance(value, MFColor):
    ###         # if _DEBUG: print('SFColor type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFColor)=' + str(isinstance(value, SFColor)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, SFColor):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(SFColor().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, MFColor) and (len(value) == 1) and isValidMFColor(value):
    ###     value = value.value[0] # dereference value from this MF type
    ###     return True
    ### if not isinstance(value, tuple):
    ###     return False
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFColor):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         return False
    ###     if (each < 0) or (each > 1):
    ###         return False
    ### if tupleCount != 3:
    ###     return False
    ### if not isZeroToOne(value):
    ###     return False
    ### return True

def assertValidSFColor(value):
    """
    Utility function to assert type validity of a SFColor value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        SFColor(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid SFColor') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFColor) and not isinstance(value, MFColor):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFColor')
    ### if isinstance(value, SFColor):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = SFColor(value)
    ###     print('found string for SFColor, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif isinstance(value, MFColor) and len(value) == 1:
    ###     value = value.value[0] # dereference value from this MF type #2b
    # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
    ### elif isinstance(value, str):
    ###     try:
    ###         float(value) # checks but does not set value, may throw exception
    ###     except ValueError:
    ###         print('SFColor encountered string with illegal value=' + str(value))
    ###         raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFColor')
    ### if not isinstance(value, tuple):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFColor')
    ### # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFColor):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         # print(flush=True)
    ###         raise X3DTypeError('SFColor list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    ###     if (each < 0) or (each > 1):
    ###         # print(flush=True)
    ###         raise X3DTypeError('SFColor' + str(value)[:100] + ' has value ' + str(each) + ' with type=' + str(type(value)) + ' is  out of range [0..1] and is not a valid SFColor')
    ### if tupleCount != 3:
    ###     # print(flush=True)
    ###     raise X3DTypeError('SFColor ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 3')

        ###                 assertZeroToOne('SFColor', value)
    ### if not isValidSFColor(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFColor')
    return True

def isValidMFColor(value):
    """
    Utility function to determine type validity of a MFColor value.
    """
    if re.fullmatch(MFColor().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch MFColor().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        MFColor(value)
        return True
    except ValueError:
        print('isValidMFColor failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFColor) and not isinstance(value, MFColor):
    ###         # if _DEBUG: print('MFColor type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFColor)=' + str(isinstance(value, MFColor)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, MFColor):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(MFColor().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, SFColor):
    ###     value = list(value.value) # dereference value from this SF type, convert to list #1
    ###     return True
    ### if not isinstance(value, list):
    ###     return False
    ### index = 0
    ### for each in value:
    ###     index += 1
   ###      if len(each) % MFColor().TUPLE_SIZE()  != 0:
    ###         # if _DEBUG:
    ###         print('* isValidMFColor tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFColor().TUPLE_SIZE() =' + str(MFColor().TUPLE_SIZE() ) + ' for value=' + str(value), flush=True)
    ###         return False
    ###     for element in each:
    ###         if not isinstance(element, float) and not isinstance(element, int):
    ###             return False
    ###         if (element < 0) or (element > 1):
    ###             return False
    ### if not isZeroToOne(value):
    ###     return False
    ### return True

def assertValidMFColor(value):
    """
    Utility function to assert type validity of a MFColor value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        MFColor(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid MFColor') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFColor) and not isinstance(value, MFColor):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFColor')
    ### if isinstance(value, MFColor):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = MFColor(value)
    ###     print('found string for MFColor, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif (isinstance(value, SFColor)) and not isinstance(value, list):
        ### value = list(SFColor(value).value) # dereference value from this SF type, convert to list #2c
    ### if not isinstance(value, list):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFColor')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    ### if isinstance(value, list):
    ###     index = 0
    ###     for each in value:
    ###         if len(each) % MFColor().TUPLE_SIZE()  != 0:
                # print(flush=True)
    ###             raise X3DValueError('MFColor tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFColor().TUPLE_SIZE() =' + str(MFColor().TUPLE_SIZE() ) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFColor)):
#                # print(flush=True)
#                raise X3DTypeError('MFColor element #' + str(index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
        ###     index += 1
        ###     if isinstance(each, tuple):
        ###         for element in each:
        ###             if not isinstance(element, float) and not isinstance(element, int):
        ###                 # print(flush=True)
        ###                 raise X3DTypeError('MFColor element #' + str(index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
        ###             if (element < 0) or (element > 1):
        ###                 # print(flush=True)
        ###                 raise X3DTypeError('MFColor' + str(value)[:100] + ' has value ' + str(element) + ' with type=' + str(type(value)) + ' out of range [0..1] and is not a valid MFColor')

        ###                 assertZeroToOne('MFColor', value)
    ### if not isValidMFColor(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFColor')
    return True

def isValidSFColorRGBA(value):
    """
    Utility function to determine type validity of a SFColorRGBA value.
    """
    if re.fullmatch(SFColorRGBA().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch SFColorRGBA().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        SFColorRGBA(value)
        return True
    except ValueError:
        print('isValidSFColorRGBA failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFColorRGBA) and not isinstance(value, MFColorRGBA):
    ###         # if _DEBUG: print('SFColorRGBA type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFColorRGBA)=' + str(isinstance(value, SFColorRGBA)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, SFColorRGBA):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(SFColorRGBA().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, MFColorRGBA) and (len(value) == 1) and isValidMFColorRGBA(value):
    ###     value = value.value[0] # dereference value from this MF type
    ###     return True
    ### if not isinstance(value, tuple):
    ###     return False
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFColorRGBA):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         return False
    ###     if (each < 0) or (each > 1):
    ###         return False
    ### if tupleCount != 4:
    ###     return False
    ### if not isZeroToOne(value):
    ###     return False
    ### return True

def assertValidSFColorRGBA(value):
    """
    Utility function to assert type validity of a SFColorRGBA value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        SFColorRGBA(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid SFColorRGBA') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFColorRGBA) and not isinstance(value, MFColorRGBA):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFColorRGBA')
    ### if isinstance(value, SFColorRGBA):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = SFColorRGBA(value)
    ###     print('found string for SFColorRGBA, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif isinstance(value, MFColorRGBA) and len(value) == 1:
    ###     value = value.value[0] # dereference value from this MF type #2b
    # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
    ### elif isinstance(value, str):
    ###     try:
    ###         float(value) # checks but does not set value, may throw exception
    ###     except ValueError:
    ###         print('SFColorRGBA encountered string with illegal value=' + str(value))
    ###         raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFColorRGBA')
    ### if not isinstance(value, tuple):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFColorRGBA')
    ### # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFColorRGBA):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         # print(flush=True)
    ###         raise X3DTypeError('SFColorRGBA list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    ###     if (each < 0) or (each > 1):
    ###         # print(flush=True)
    ###         raise X3DTypeError('SFColorRGBA' + str(value)[:100] + ' has value ' + str(each) + ' with type=' + str(type(value)) + ' is  out of range [0..1] and is not a valid SFColorRGBA')
    ### if tupleCount != 4:
    ###     # print(flush=True)
    ###     raise X3DTypeError('SFColorRGBA ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 4')

        ###                 assertZeroToOne('SFColorRGBA', value)
    ### if not isValidSFColorRGBA(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFColorRGBA')
    return True

def isValidMFColorRGBA(value):
    """
    Utility function to determine type validity of a MFColorRGBA value.
    """
    if re.fullmatch(MFColorRGBA().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch MFColorRGBA().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        MFColorRGBA(value)
        return True
    except ValueError:
        print('isValidMFColorRGBA failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFColorRGBA) and not isinstance(value, MFColorRGBA):
    ###         # if _DEBUG: print('MFColorRGBA type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFColorRGBA)=' + str(isinstance(value, MFColorRGBA)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, MFColorRGBA):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(MFColorRGBA().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, SFColorRGBA):
    ###     value = list(value.value) # dereference value from this SF type, convert to list #1
    ###     return True
    ### if not isinstance(value, list):
    ###     return False
    ### index = 0
    ### for each in value:
    ###     index += 1
   ###      if len(each) % MFColorRGBA().TUPLE_SIZE()  != 0:
    ###         # if _DEBUG:
    ###         print('* isValidMFColorRGBA tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFColorRGBA().TUPLE_SIZE() =' + str(MFColorRGBA().TUPLE_SIZE() ) + ' for value=' + str(value), flush=True)
    ###         return False
    ###     for element in each:
    ###         if not isinstance(element, float) and not isinstance(element, int):
    ###             return False
    ###         if (element < 0) or (element > 1):
    ###             return False
    ### if not isZeroToOne(value):
    ###     return False
    ### return True

def assertValidMFColorRGBA(value):
    """
    Utility function to assert type validity of a MFColorRGBA value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        MFColorRGBA(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid MFColorRGBA') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFColorRGBA) and not isinstance(value, MFColorRGBA):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFColorRGBA')
    ### if isinstance(value, MFColorRGBA):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = MFColorRGBA(value)
    ###     print('found string for MFColorRGBA, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif (isinstance(value, SFColorRGBA)) and not isinstance(value, list):
        ### value = list(SFColorRGBA(value).value) # dereference value from this SF type, convert to list #2c
    ### if not isinstance(value, list):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFColorRGBA')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    ### if isinstance(value, list):
    ###     index = 0
    ###     for each in value:
    ###         if len(each) % MFColorRGBA().TUPLE_SIZE()  != 0:
                # print(flush=True)
    ###             raise X3DValueError('MFColorRGBA tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFColorRGBA().TUPLE_SIZE() =' + str(MFColorRGBA().TUPLE_SIZE() ) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFColorRGBA)):
#                # print(flush=True)
#                raise X3DTypeError('MFColorRGBA element #' + str(index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
        ###     index += 1
        ###     if isinstance(each, tuple):
        ###         for element in each:
        ###             if not isinstance(element, float) and not isinstance(element, int):
        ###                 # print(flush=True)
        ###                 raise X3DTypeError('MFColorRGBA element #' + str(index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
        ###             if (element < 0) or (element > 1):
        ###                 # print(flush=True)
        ###                 raise X3DTypeError('MFColorRGBA' + str(value)[:100] + ' has value ' + str(element) + ' with type=' + str(type(value)) + ' out of range [0..1] and is not a valid MFColorRGBA')

        ###                 assertZeroToOne('MFColorRGBA', value)
    ### if not isValidMFColorRGBA(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFColorRGBA')
    return True

def isValidSFDouble(value):
    """
    Utility function to determine type validity of a SFDouble value.
    """
    if re.fullmatch(SFDouble().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch SFDouble().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        SFDouble(value)
        return True
    except ValueError:
        print('isValidSFDouble failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFDouble) and not isinstance(value, MFDouble):
    ###         # if _DEBUG: print('SFDouble type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFDouble)=' + str(isinstance(value, SFDouble)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, SFDouble):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(SFDouble().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, MFDouble) and (len(value) == 1) and isValidMFDouble(value):
    ###     value = value.value[0] # dereference value from this MF type
    ###     return True
    ### if not isinstance(value, float) and not isinstance(value, int):
    ###     return False
    ### return True

def assertValidSFDouble(value):
    """
    Utility function to assert type validity of a SFDouble value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        SFDouble(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid SFDouble') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFDouble) and not isinstance(value, MFDouble):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFDouble')
    ### if isinstance(value, SFDouble):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = SFDouble(value)
    ###     print('found string for SFDouble, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif isinstance(value, MFDouble) and len(value) == 1:
    ###     value = value.value[0] # dereference value from this MF type #2b
    # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
    ### elif isinstance(value, str):
    ###     try:
    ###         float(value) # checks but does not set value, may throw exception
    ###     except ValueError:
    ###         print('SFDouble encountered string with illegal value=' + str(value))
    ###         raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFDouble')
    ### if not isinstance(value, float) and not isinstance(value, int):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFDouble')
    ### if not isValidSFDouble(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python float value for SFDouble')
    return True

def isValidMFDouble(value):
    """
    Utility function to determine type validity of a MFDouble value.
    """
    if re.fullmatch(MFDouble().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch MFDouble().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        MFDouble(value)
        return True
    except ValueError:
        print('isValidMFDouble failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFDouble) and not isinstance(value, MFDouble):
    ###         # if _DEBUG: print('MFDouble type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFDouble)=' + str(isinstance(value, MFDouble)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, MFDouble):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(MFDouble().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, SFDouble):
    ###     value = list(value.value) # dereference value from this SF type, convert to list #1
    ###     return True
    ### if not isinstance(value, list):
    ###     return False
    ### for each in value:
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFDouble):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         return False
    ### return True

def assertValidMFDouble(value):
    """
    Utility function to assert type validity of a MFDouble value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        MFDouble(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid MFDouble') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFDouble) and not isinstance(value, MFDouble):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFDouble')
    ### if isinstance(value, MFDouble):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = MFDouble(value)
    ###     print('found string for MFDouble, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif (isinstance(value, SFDouble)) and not isinstance(value, list):
        ### value = list(SFDouble(value).value) # dereference value from this SF type, convert to list #2c
    ### if not isinstance(value, list):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFDouble')
    ### # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    ### for each in value:
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFDouble):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         # print(flush=True)
    ###         raise X3DTypeError('MFDouble list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    ### if not isValidMFDouble(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFDouble')
    return True

def isValidSFFloat(value):
    """
    Utility function to determine type validity of a SFFloat value.
    """
    if re.fullmatch(SFFloat().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch SFFloat().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        SFFloat(value)
        return True
    except ValueError:
        print('isValidSFFloat failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFFloat) and not isinstance(value, MFFloat):
    ###         # if _DEBUG: print('SFFloat type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFFloat)=' + str(isinstance(value, SFFloat)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, SFFloat):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(SFFloat().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, MFFloat) and (len(value) == 1) and isValidMFFloat(value):
    ###     value = value.value[0] # dereference value from this MF type
    ###     return True
    ### if not isinstance(value, float) and not isinstance(value, int):
    ###     return False
    ### return True

def assertValidSFFloat(value):
    """
    Utility function to assert type validity of a SFFloat value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        SFFloat(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid SFFloat') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFFloat) and not isinstance(value, MFFloat):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFFloat')
    ### if isinstance(value, SFFloat):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = SFFloat(value)
    ###     print('found string for SFFloat, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif isinstance(value, MFFloat) and len(value) == 1:
    ###     value = value.value[0] # dereference value from this MF type #2b
    # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
    ### elif isinstance(value, str):
    ###     try:
    ###         float(value) # checks but does not set value, may throw exception
    ###     except ValueError:
    ###         print('SFFloat encountered string with illegal value=' + str(value))
    ###         raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFFloat')
    ### if not isinstance(value, float) and not isinstance(value, int):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFFloat')
    ### if not isValidSFFloat(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python float value for SFFloat')
    return True

def isValidMFFloat(value):
    """
    Utility function to determine type validity of a MFFloat value.
    """
    if re.fullmatch(MFFloat().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch MFFloat().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        MFFloat(value)
        return True
    except ValueError:
        print('isValidMFFloat failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFFloat) and not isinstance(value, MFFloat):
    ###         # if _DEBUG: print('MFFloat type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFFloat)=' + str(isinstance(value, MFFloat)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, MFFloat):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(MFFloat().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, SFFloat):
    ###     value = list(value.value) # dereference value from this SF type, convert to list #1
    ###     return True
    ### if not isinstance(value, list):
    ###     return False
    ### for each in value:
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFFloat):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         return False
    ### return True

def assertValidMFFloat(value):
    """
    Utility function to assert type validity of a MFFloat value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        MFFloat(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid MFFloat') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFFloat) and not isinstance(value, MFFloat):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFFloat')
    ### if isinstance(value, MFFloat):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = MFFloat(value)
    ###     print('found string for MFFloat, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif (isinstance(value, SFFloat)) and not isinstance(value, list):
        ### value = list(SFFloat(value).value) # dereference value from this SF type, convert to list #2c
    ### if not isinstance(value, list):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFFloat')
    ### # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    ### for each in value:
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFFloat):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         # print(flush=True)
    ###         raise X3DTypeError('MFFloat list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    ### if not isValidMFFloat(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFFloat')
    return True

def isValidSFImage(value):
    """
    Utility function to determine type validity of a SFImage value.
    """
    if re.fullmatch(SFImage().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch SFImage().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        SFImage(value)
        return True
    except ValueError:
        print('isValidSFImage failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFImage) and not isinstance(value, MFImage):
    ###         # if _DEBUG: print('SFImage type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFImage)=' + str(isinstance(value, SFImage)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, SFImage):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(SFImage().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, MFImage) and (len(value) == 1) and isValidMFImage(value):
    ###     value = value.value[0] # dereference value from this MF type
    ###     return True
    ### if not isinstance(value, list):
    ###     return False
    ### for each in value:
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFImage):
    ###         each = each.value # dereference
    ###     if not isinstance(each, int):
    ###         return False
    ### if len(value) > 0: # SFImage list length checks
    ###     if 0 < len(value) < 3:
    ###         return False # SFImage list must start with width, height and number of components (0..4)
    ###     width = value[0]
    ###     height = value[1]
    ###     # numberComponents = value[2]
    ###     if  len(value) != (width * height) + 3: # assumes each value in array has all component values in single integer
    ###         print('SFImage array length of ' + str(len(value)) + ' does not equal (width=' + str(width)+ ' * height=' + str(height)+ ') + 3) = ' + str(width * height * numberComponents + 3) + ' (numberComponents=' + numberComponents + ')', flush=True)
    ###         return False # SFImage has invalid list length
    ### return True

def assertValidSFImage(value):
    """
    Utility function to assert type validity of a SFImage value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        SFImage(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid SFImage') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFImage) and not isinstance(value, MFImage):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFImage')
    ### if isinstance(value, SFImage):
    ###     value = value.value # dereference value from this base type #2a
    ### elif isinstance(value, MFImage) and len(value) == 1:
    ###     value = value.value[0] # dereference value from this MF type #2b
    # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
    ### elif isinstance(value, str):
    ###     try:
    ###         float(value) # checks but does not set value, may throw exception
    ###     except ValueError:
    ###         print('SFImage encountered string with illegal value=' + str(value))
    ###         raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFImage')
    ### if not isinstance(value, list):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for SFImage')
    ### # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    ### for each in value:
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFImage):
    ###         each = each.value # dereference
    ###     if not isinstance(each, int):
    ###         # print(flush=True)
    ###         raise X3DTypeError('SFImage list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid int')
    ### if not isValidSFImage(value):
    ###     # print(flush=True)
    ###     diagnostic = ''
    ###     if len(value) > 0: # SFImage list length checks
    ###         if 0 < len(value) < 3:
    ###             diagnostic = 'SFImage list must start with width, height and number of components (0..4)'
    ###         else:
    ###             width = value[0]
    ###             height = value[1]
    ###             numberComponents = value[2]
    ###             diagnostic = ' array length of ' + str(len(value)) + ' does not equal (width=' + str(width)+ ' * height=' + str(height)+ ') + 3) = ' + str(width * height + 3)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for SFImage' + diagnostic)
    return True

def isValidMFImage(value):
    """
    Utility function to determine type validity of a MFImage value.
    """
    if re.fullmatch(MFImage().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch MFImage().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        MFImage(value)
        return True
    except ValueError:
        print('isValidMFImage failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFImage) and not isinstance(value, MFImage):
    ###         # if _DEBUG: print('MFImage type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFImage)=' + str(isinstance(value, MFImage)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, MFImage):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(MFImage().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, SFImage):
    ###     value = list(value.value) # dereference value from this SF type, convert to list #1
    ###     return True
    ### if not isinstance(value, list):
    ###     return False
    ### for each in value:
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFImage):
    ###         each = each.value # dereference
    ###     if not isinstance(each, int):
    ###         return False
    ### return True

def assertValidMFImage(value):
    """
    Utility function to assert type validity of a MFImage value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        MFImage(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid MFImage') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFImage) and not isinstance(value, MFImage):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFImage')
    ### if isinstance(value, MFImage):
    ###     value = value.value # dereference value from this base type #2a
    ### elif (isinstance(value, SFImage)) and not isinstance(value, list):
        ### value = list(SFImage(value).value) # dereference value from this SF type, convert to list #2c
    ### if not isinstance(value, list):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFImage')
    ### # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    ### for each in value:
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFImage):
    ###         each = each.value # dereference
    ###     if not isinstance(each, int):
    ###         # print(flush=True)
    ###         raise X3DTypeError('MFImage list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid int')
    ### if not isValidMFImage(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFImage')
    return True

def isValidSFInt32(value):
    """
    Utility function to determine type validity of a SFInt32 value.
    """
    if re.fullmatch(SFInt32().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch SFInt32().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        SFInt32(value)
        return True
    except ValueError:
        print('isValidSFInt32 failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFInt32) and not isinstance(value, MFInt32):
    ###         # if _DEBUG: print('SFInt32 type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFInt32)=' + str(isinstance(value, SFInt32)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, SFInt32):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(SFInt32().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, MFInt32) and (len(value) == 1) and isValidMFInt32(value):
    ###     value = value.value[0] # dereference value from this MF type
    ###     return True
    ### if not isinstance(value, int):
    ###     return False
    ### return True

def assertValidSFInt32(value):
    """
    Utility function to assert type validity of a SFInt32 value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        SFInt32(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid SFInt32') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFInt32) and not isinstance(value, MFInt32):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFInt32')
    ### if isinstance(value, SFInt32):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     try:
    ###         value = SFInt32(value)
    ###         print('found string for SFInt32, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ###         return True
    ###     except:
    ###         raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid int value for SFInt32')
    ### elif isinstance(value, MFInt32) and len(value) == 1:
    ###     value = value.value[0] # dereference value from this MF type #2b
    # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
    ### elif isinstance(value, str):
    ###     try:
    ###         int(value) # checks but does not set value, may throw exception
    ###     except ValueError:
    ###         print('SFInt32 encountered string with illegal value=' + str(value))
    ###         raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid int value for SFInt32')
    ### if not isinstance(value, int):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid int value for SFInt32')
    ### if not isValidSFInt32(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python int value for SFInt32')
    return True

def isValidMFInt32(value):
    """
    Utility function to determine type validity of a MFInt32 value.
    """
    if re.fullmatch(MFInt32().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch MFInt32().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        MFInt32(value)
        return True
    except ValueError:
        print('isValidMFInt32 failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFInt32) and not isinstance(value, MFInt32):
    ###         # if _DEBUG: print('MFInt32 type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFInt32)=' + str(isinstance(value, MFInt32)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, MFInt32):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(MFInt32().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, SFInt32):
    ###     value = list(value.value) # dereference value from this SF type, convert to list #1
    ###     return True
    ### if not isinstance(value, list):
    ###     return False
    ### for each in value:
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFInt32):
    ###         each = each.value # dereference
    ###     if not isinstance(each, int):
    ###         return False
    ### return True

def assertValidMFInt32(value):
    """
    Utility function to assert type validity of a MFInt32 value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        MFInt32(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid MFInt32') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFInt32) and not isinstance(value, MFInt32):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFInt32')
    ### if isinstance(value, MFInt32):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     try:
    ###         value = SFInt32(value)
    ###         print('found string for MFInt32, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ###         return True
    ###     except:
    ###         raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid int value for SFInt32')
    ### elif (isinstance(value, SFInt32)) and not isinstance(value, list):
        ### value = list(SFInt32(value).value) # dereference value from this SF type, convert to list #2c
    ### if not isinstance(value, list):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFInt32')
    ### # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    ### for each in value:
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFInt32):
    ###         each = each.value # dereference
    ###     if not isinstance(each, int):
    ###         # print(flush=True)
    ###         raise X3DTypeError('MFInt32 list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid int')
    ### if not isValidMFInt32(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFInt32')
    return True

def isValidSFMatrix3d(value):
    """
    Utility function to determine type validity of a SFMatrix3d value.
    """
    if re.fullmatch(SFMatrix3d().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch SFMatrix3d().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        SFMatrix3d(value)
        return True
    except ValueError:
        print('isValidSFMatrix3d failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFMatrix3d) and not isinstance(value, MFMatrix3d):
    ###         # if _DEBUG: print('SFMatrix3d type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFMatrix3d)=' + str(isinstance(value, SFMatrix3d)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, SFMatrix3d):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(SFMatrix3d().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, MFMatrix3d) and (len(value) == 1) and isValidMFMatrix3d(value):
    ###     value = value.value[0] # dereference value from this MF type
    ###     return True
    ### if not isinstance(value, tuple):
    ###     return False
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFMatrix3d):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         return False
    ### if tupleCount != 9:
    ###     return False
    ### return True

def assertValidSFMatrix3d(value):
    """
    Utility function to assert type validity of a SFMatrix3d value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        SFMatrix3d(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid SFMatrix3d') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFMatrix3d) and not isinstance(value, MFMatrix3d):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFMatrix3d')
    ### if isinstance(value, SFMatrix3d):
    ###     value = value.value # dereference value from this base type #2a
    ### elif isinstance(value, MFMatrix3d) and len(value) == 1:
    ###     value = value.value[0] # dereference value from this MF type #2b
    # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
    ### elif isinstance(value, str):
    ###     try:
    ###         float(value) # checks but does not set value, may throw exception
    ###     except ValueError:
    ###         print('SFMatrix3d encountered string with illegal value=' + str(value))
    ###         raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFMatrix3d')
    ### if not isinstance(value, tuple):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFMatrix3d')
    ### # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFMatrix3d):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         # print(flush=True)
    ###         raise X3DTypeError('SFMatrix3d list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    ### if tupleCount != 9:
    ###     # print(flush=True)
    ###     raise X3DTypeError('SFMatrix3d ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 9')
    ### if not isValidSFMatrix3d(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFMatrix3d')
    return True

def isValidMFMatrix3d(value):
    """
    Utility function to determine type validity of a MFMatrix3d value.
    """
    if re.fullmatch(MFMatrix3d().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch MFMatrix3d().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        MFMatrix3d(value)
        return True
    except ValueError:
        print('isValidMFMatrix3d failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFMatrix3d) and not isinstance(value, MFMatrix3d):
    ###         # if _DEBUG: print('MFMatrix3d type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFMatrix3d)=' + str(isinstance(value, MFMatrix3d)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, MFMatrix3d):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(MFMatrix3d().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, SFMatrix3d):
    ###     value = list(value.value) # dereference value from this SF type, convert to list #1
    ###     return True
    ### if not isinstance(value, list):
    ###     return False
    ### index = 0
    ### for each in value:
    ###     index += 1
   ###      if len(each) % MFMatrix3d().TUPLE_SIZE()  != 0:
    ###         # if _DEBUG:
    ###         print('* isValidMFMatrix3d tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFMatrix3d().TUPLE_SIZE() =' + str(MFMatrix3d().TUPLE_SIZE() ) + ' for value=' + str(value), flush=True)
    ###         return False
    ###     for element in each:
    ###         if not isinstance(element, float) and not isinstance(element, int):
    ###             return False
    ### return True

def assertValidMFMatrix3d(value):
    """
    Utility function to assert type validity of a MFMatrix3d value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        MFMatrix3d(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid MFMatrix3d') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFMatrix3d) and not isinstance(value, MFMatrix3d):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFMatrix3d')
    ### if isinstance(value, MFMatrix3d):
    ###     value = value.value # dereference value from this base type #2a
    ### elif (isinstance(value, SFMatrix3d)) and not isinstance(value, list):
        ### value = list(SFMatrix3d(value).value) # dereference value from this SF type, convert to list #2c
    ### if not isinstance(value, list):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFMatrix3d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    ### if isinstance(value, list):
    ###     index = 0
    ###     for each in value:
    ###         if len(each) % MFMatrix3d().TUPLE_SIZE()  != 0:
                # print(flush=True)
    ###             raise X3DValueError('MFMatrix3d tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFMatrix3d().TUPLE_SIZE() =' + str(MFMatrix3d().TUPLE_SIZE() ) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFMatrix3d)):
#                # print(flush=True)
#                raise X3DTypeError('MFMatrix3d element #' + str(index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
        ###     index += 1
        ###     if isinstance(each, tuple):
        ###         for element in each:
        ###             if not isinstance(element, float) and not isinstance(element, int):
        ###                 # print(flush=True)
        ###                 raise X3DTypeError('MFMatrix3d element #' + str(index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    ### if not isValidMFMatrix3d(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFMatrix3d')
    return True

def isValidSFMatrix3f(value):
    """
    Utility function to determine type validity of a SFMatrix3f value.
    """
    if re.fullmatch(SFMatrix3f().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch SFMatrix3f().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        SFMatrix3f(value)
        return True
    except ValueError:
        print('isValidSFMatrix3f failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFMatrix3f) and not isinstance(value, MFMatrix3f):
    ###         # if _DEBUG: print('SFMatrix3f type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFMatrix3f)=' + str(isinstance(value, SFMatrix3f)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, SFMatrix3f):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(SFMatrix3f().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, MFMatrix3f) and (len(value) == 1) and isValidMFMatrix3f(value):
    ###     value = value.value[0] # dereference value from this MF type
    ###     return True
    ### if not isinstance(value, tuple):
    ###     return False
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFMatrix3f):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         return False
    ### if tupleCount != 9:
    ###     return False
    ### return True

def assertValidSFMatrix3f(value):
    """
    Utility function to assert type validity of a SFMatrix3f value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        SFMatrix3f(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid SFMatrix3f') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFMatrix3f) and not isinstance(value, MFMatrix3f):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFMatrix3f')
    ### if isinstance(value, SFMatrix3f):
    ###     value = value.value # dereference value from this base type #2a
    ### elif isinstance(value, MFMatrix3f) and len(value) == 1:
    ###     value = value.value[0] # dereference value from this MF type #2b
    # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
    ### elif isinstance(value, str):
    ###     try:
    ###         float(value) # checks but does not set value, may throw exception
    ###     except ValueError:
    ###         print('SFMatrix3f encountered string with illegal value=' + str(value))
    ###         raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFMatrix3f')
    ### if not isinstance(value, tuple):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFMatrix3f')
    ### # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFMatrix3f):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         # print(flush=True)
    ###         raise X3DTypeError('SFMatrix3f list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    ### if tupleCount != 9:
    ###     # print(flush=True)
    ###     raise X3DTypeError('SFMatrix3f ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 9')
    ### if not isValidSFMatrix3f(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFMatrix3f')
    return True

def isValidMFMatrix3f(value):
    """
    Utility function to determine type validity of a MFMatrix3f value.
    """
    if re.fullmatch(MFMatrix3f().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch MFMatrix3f().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        MFMatrix3f(value)
        return True
    except ValueError:
        print('isValidMFMatrix3f failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFMatrix3f) and not isinstance(value, MFMatrix3f):
    ###         # if _DEBUG: print('MFMatrix3f type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFMatrix3f)=' + str(isinstance(value, MFMatrix3f)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, MFMatrix3f):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(MFMatrix3f().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, SFMatrix3f):
    ###     value = list(value.value) # dereference value from this SF type, convert to list #1
    ###     return True
    ### if not isinstance(value, list):
    ###     return False
    ### index = 0
    ### for each in value:
    ###     index += 1
   ###      if len(each) % MFMatrix3f().TUPLE_SIZE()  != 0:
    ###         # if _DEBUG:
    ###         print('* isValidMFMatrix3f tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFMatrix3f().TUPLE_SIZE() =' + str(MFMatrix3f().TUPLE_SIZE() ) + ' for value=' + str(value), flush=True)
    ###         return False
    ###     for element in each:
    ###         if not isinstance(element, float) and not isinstance(element, int):
    ###             return False
    ### return True

def assertValidMFMatrix3f(value):
    """
    Utility function to assert type validity of a MFMatrix3f value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        MFMatrix3f(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid MFMatrix3f') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFMatrix3f) and not isinstance(value, MFMatrix3f):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFMatrix3f')
    ### if isinstance(value, MFMatrix3f):
    ###     value = value.value # dereference value from this base type #2a
    ### elif (isinstance(value, SFMatrix3f)) and not isinstance(value, list):
        ### value = list(SFMatrix3f(value).value) # dereference value from this SF type, convert to list #2c
    ### if not isinstance(value, list):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFMatrix3f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    ### if isinstance(value, list):
    ###     index = 0
    ###     for each in value:
    ###         if len(each) % MFMatrix3f().TUPLE_SIZE()  != 0:
                # print(flush=True)
    ###             raise X3DValueError('MFMatrix3f tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFMatrix3f().TUPLE_SIZE() =' + str(MFMatrix3f().TUPLE_SIZE() ) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFMatrix3f)):
#                # print(flush=True)
#                raise X3DTypeError('MFMatrix3f element #' + str(index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
        ###     index += 1
        ###     if isinstance(each, tuple):
        ###         for element in each:
        ###             if not isinstance(element, float) and not isinstance(element, int):
        ###                 # print(flush=True)
        ###                 raise X3DTypeError('MFMatrix3f element #' + str(index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    ### if not isValidMFMatrix3f(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFMatrix3f')
    return True

def isValidSFMatrix4d(value):
    """
    Utility function to determine type validity of a SFMatrix4d value.
    """
    if re.fullmatch(SFMatrix4d().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch SFMatrix4d().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        SFMatrix4d(value)
        return True
    except ValueError:
        print('isValidSFMatrix4d failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFMatrix4d) and not isinstance(value, MFMatrix4d):
    ###         # if _DEBUG: print('SFMatrix4d type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFMatrix4d)=' + str(isinstance(value, SFMatrix4d)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, SFMatrix4d):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(SFMatrix4d().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, MFMatrix4d) and (len(value) == 1) and isValidMFMatrix4d(value):
    ###     value = value.value[0] # dereference value from this MF type
    ###     return True
    ### if not isinstance(value, tuple):
    ###     return False
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFMatrix4d):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         return False
    ### if tupleCount != 16:
    ###     return False
    ### return True

def assertValidSFMatrix4d(value):
    """
    Utility function to assert type validity of a SFMatrix4d value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        SFMatrix4d(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid SFMatrix4d') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFMatrix4d) and not isinstance(value, MFMatrix4d):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFMatrix4d')
    ### if isinstance(value, SFMatrix4d):
    ###     value = value.value # dereference value from this base type #2a
    ### elif isinstance(value, MFMatrix4d) and len(value) == 1:
    ###     value = value.value[0] # dereference value from this MF type #2b
    # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
    ### elif isinstance(value, str):
    ###     try:
    ###         float(value) # checks but does not set value, may throw exception
    ###     except ValueError:
    ###         print('SFMatrix4d encountered string with illegal value=' + str(value))
    ###         raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFMatrix4d')
    ### if not isinstance(value, tuple):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFMatrix4d')
    ### # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFMatrix4d):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         # print(flush=True)
    ###         raise X3DTypeError('SFMatrix4d list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    ### if tupleCount != 16:
    ###     # print(flush=True)
    ###     raise X3DTypeError('SFMatrix4d ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 16')
    ### if not isValidSFMatrix4d(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFMatrix4d')
    return True

def isValidMFMatrix4d(value):
    """
    Utility function to determine type validity of a MFMatrix4d value.
    """
    if re.fullmatch(MFMatrix4d().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch MFMatrix4d().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        MFMatrix4d(value)
        return True
    except ValueError:
        print('isValidMFMatrix4d failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFMatrix4d) and not isinstance(value, MFMatrix4d):
    ###         # if _DEBUG: print('MFMatrix4d type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFMatrix4d)=' + str(isinstance(value, MFMatrix4d)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, MFMatrix4d):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(MFMatrix4d().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, SFMatrix4d):
    ###     value = list(value.value) # dereference value from this SF type, convert to list #1
    ###     return True
    ### if not isinstance(value, list):
    ###     return False
    ### index = 0
    ### for each in value:
    ###     index += 1
   ###      if len(each) % MFMatrix4d().TUPLE_SIZE()  != 0:
    ###         # if _DEBUG:
    ###         print('* isValidMFMatrix4d tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFMatrix4d().TUPLE_SIZE() =' + str(MFMatrix4d().TUPLE_SIZE() ) + ' for value=' + str(value), flush=True)
    ###         return False
    ###     for element in each:
    ###         if not isinstance(element, float) and not isinstance(element, int):
    ###             return False
    ### return True

def assertValidMFMatrix4d(value):
    """
    Utility function to assert type validity of a MFMatrix4d value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        MFMatrix4d(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid MFMatrix4d') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFMatrix4d) and not isinstance(value, MFMatrix4d):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFMatrix4d')
    ### if isinstance(value, MFMatrix4d):
    ###     value = value.value # dereference value from this base type #2a
    ### elif (isinstance(value, SFMatrix4d)) and not isinstance(value, list):
        ### value = list(SFMatrix4d(value).value) # dereference value from this SF type, convert to list #2c
    ### if not isinstance(value, list):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFMatrix4d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    ### if isinstance(value, list):
    ###     index = 0
    ###     for each in value:
    ###         if len(each) % MFMatrix4d().TUPLE_SIZE()  != 0:
                # print(flush=True)
    ###             raise X3DValueError('MFMatrix4d tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFMatrix4d().TUPLE_SIZE() =' + str(MFMatrix4d().TUPLE_SIZE() ) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFMatrix4d)):
#                # print(flush=True)
#                raise X3DTypeError('MFMatrix4d element #' + str(index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
        ###     index += 1
        ###     if isinstance(each, tuple):
        ###         for element in each:
        ###             if not isinstance(element, float) and not isinstance(element, int):
        ###                 # print(flush=True)
        ###                 raise X3DTypeError('MFMatrix4d element #' + str(index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    ### if not isValidMFMatrix4d(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFMatrix4d')
    return True

def isValidSFMatrix4f(value):
    """
    Utility function to determine type validity of a SFMatrix4f value.
    """
    if re.fullmatch(SFMatrix4f().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch SFMatrix4f().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        SFMatrix4f(value)
        return True
    except ValueError:
        print('isValidSFMatrix4f failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFMatrix4f) and not isinstance(value, MFMatrix4f):
    ###         # if _DEBUG: print('SFMatrix4f type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFMatrix4f)=' + str(isinstance(value, SFMatrix4f)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, SFMatrix4f):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(SFMatrix4f().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, MFMatrix4f) and (len(value) == 1) and isValidMFMatrix4f(value):
    ###     value = value.value[0] # dereference value from this MF type
    ###     return True
    ### if not isinstance(value, tuple):
    ###     return False
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFMatrix4f):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         return False
    ### if tupleCount != 16:
    ###     return False
    ### return True

def assertValidSFMatrix4f(value):
    """
    Utility function to assert type validity of a SFMatrix4f value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        SFMatrix4f(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid SFMatrix4f') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFMatrix4f) and not isinstance(value, MFMatrix4f):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFMatrix4f')
    ### if isinstance(value, SFMatrix4f):
    ###     value = value.value # dereference value from this base type #2a
    ### elif isinstance(value, MFMatrix4f) and len(value) == 1:
    ###     value = value.value[0] # dereference value from this MF type #2b
    # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
    ### elif isinstance(value, str):
    ###     try:
    ###         float(value) # checks but does not set value, may throw exception
    ###     except ValueError:
    ###         print('SFMatrix4f encountered string with illegal value=' + str(value))
    ###         raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFMatrix4f')
    ### if not isinstance(value, tuple):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFMatrix4f')
    ### # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFMatrix4f):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         # print(flush=True)
    ###         raise X3DTypeError('SFMatrix4f list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    ### if tupleCount != 16:
    ###     # print(flush=True)
    ###     raise X3DTypeError('SFMatrix4f ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 16')
    ### if not isValidSFMatrix4f(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFMatrix4f')
    return True

def isValidMFMatrix4f(value):
    """
    Utility function to determine type validity of a MFMatrix4f value.
    """
    if re.fullmatch(MFMatrix4f().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch MFMatrix4f().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        MFMatrix4f(value)
        return True
    except ValueError:
        print('isValidMFMatrix4f failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFMatrix4f) and not isinstance(value, MFMatrix4f):
    ###         # if _DEBUG: print('MFMatrix4f type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFMatrix4f)=' + str(isinstance(value, MFMatrix4f)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, MFMatrix4f):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(MFMatrix4f().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, SFMatrix4f):
    ###     value = list(value.value) # dereference value from this SF type, convert to list #1
    ###     return True
    ### if not isinstance(value, list):
    ###     return False
    ### index = 0
    ### for each in value:
    ###     index += 1
   ###      if len(each) % MFMatrix4f().TUPLE_SIZE()  != 0:
    ###         # if _DEBUG:
    ###         print('* isValidMFMatrix4f tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFMatrix4f().TUPLE_SIZE() =' + str(MFMatrix4f().TUPLE_SIZE() ) + ' for value=' + str(value), flush=True)
    ###         return False
    ###     for element in each:
    ###         if not isinstance(element, float) and not isinstance(element, int):
    ###             return False
    ### return True

def assertValidMFMatrix4f(value):
    """
    Utility function to assert type validity of a MFMatrix4f value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        MFMatrix4f(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid MFMatrix4f') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFMatrix4f) and not isinstance(value, MFMatrix4f):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFMatrix4f')
    ### if isinstance(value, MFMatrix4f):
    ###     value = value.value # dereference value from this base type #2a
    ### elif (isinstance(value, SFMatrix4f)) and not isinstance(value, list):
        ### value = list(SFMatrix4f(value).value) # dereference value from this SF type, convert to list #2c
    ### if not isinstance(value, list):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFMatrix4f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    ### if isinstance(value, list):
    ###     index = 0
    ###     for each in value:
    ###         if len(each) % MFMatrix4f().TUPLE_SIZE()  != 0:
                # print(flush=True)
    ###             raise X3DValueError('MFMatrix4f tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFMatrix4f().TUPLE_SIZE() =' + str(MFMatrix4f().TUPLE_SIZE() ) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFMatrix4f)):
#                # print(flush=True)
#                raise X3DTypeError('MFMatrix4f element #' + str(index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
        ###     index += 1
        ###     if isinstance(each, tuple):
        ###         for element in each:
        ###             if not isinstance(element, float) and not isinstance(element, int):
        ###                 # print(flush=True)
        ###                 raise X3DTypeError('MFMatrix4f element #' + str(index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    ### if not isValidMFMatrix4f(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFMatrix4f')
    return True

def isValidSFNode(value):
    """
    Utility function to determine type validity of a SFNode value.
    """
    try:
        SFNode(value)
        return True
    except ValueError:
        print('isValidSFNode failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFNode) and not isinstance(value, MFNode):
    ###         # if _DEBUG: print('SFNode type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFNode)=' + str(isinstance(value, SFNode)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, SFNode):
    ###     value = value.value # dereference value from base type
    ###     return True
    ### if isinstance(value, MFNode) and (len(value) == 1) and isValidMFNode(value):
    ###     value = value.value[0] # dereference value from this MF type
    ###     return True
    ### if not isinstance(value, object):
    ###     return False
    ### return True

def assertValidSFNode(value):
    """
    Utility function to assert type validity of a SFNode value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        SFNode(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid SFNode') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFNode) and not isinstance(value, MFNode):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFNode')
    ### if isinstance(value, SFNode):
    ###     value = value.value # dereference value from this base type #2a
    ### elif isinstance(value, MFNode) and len(value) == 1:
    ###     value = value.value[0] # dereference value from this MF type #2b
    ### if not isinstance(value, object):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid object value for SFNode')
    ### if not isValidSFNode(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python object value for SFNode')
    return True

def isValidMFNode(value):
    """
    Utility function to determine type validity of a MFNode value.
    """
    try:
        MFNode(value)
        return True
    except ValueError:
        print('isValidMFNode failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFNode) and not isinstance(value, MFNode):
    ###         # if _DEBUG: print('MFNode type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFNode)=' + str(isinstance(value, MFNode)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, MFNode):
    ###     value = value.value # dereference value from base type
    ###     return True
    ### if isinstance(value, SFNode):
    ###     value = list(value.value) # dereference value from this SF type, convert to list #1
    ###     return True
    ### if value and isinstance(value,list):
    ###     for each in value:
    ###         if not isinstance(each, (_X3DNode, _X3DStatement)):
    ###             return False
    ### return True

def assertValidMFNode(value):
    """
    Utility function to assert type validity of a MFNode value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        MFNode(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid MFNode') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFNode) and not isinstance(value, MFNode):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFNode')
    ### if isinstance(value, MFNode):
    ###     value = value.value # dereference value from this base type #2a
    ### elif (isinstance(value, SFNode)) and not isinstance(value, list):
        ### value = list(SFNode(value).value) # dereference value from this SF type, convert to list #2c
    ### if value and isinstance(value,list):
    ###     for each in value:
    ###         if not isinstance(each, _X3DNode) and not isinstance(each, _X3DStatement):
    ###             print(flush=True)
    ###             raise X3DTypeError(str(value)[:100] + ' element ' + str(each) + ', type=' + str(type(each)) + ' is not a valid _X3DNode or _X3DStatement for MFNode')
    ### if not isValidMFNode(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid _X3DNode or _X3DStatement for MFNode')
    return True

def isValidSFRotation(value):
    """
    Utility function to determine type validity of a SFRotation value.
    """
    if re.fullmatch(SFRotation().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch SFRotation().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        SFRotation(value)
        return True
    except ValueError:
        print('isValidSFRotation failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFRotation) and not isinstance(value, MFRotation):
    ###         # if _DEBUG: print('SFRotation type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFRotation)=' + str(isinstance(value, SFRotation)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, SFRotation):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(SFRotation().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, MFRotation) and (len(value) == 1) and isValidMFRotation(value):
    ###     value = value.value[0] # dereference value from this MF type
    ###     return True
    ### if not isinstance(value, tuple):
    ###     return False
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFRotation):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         return False
    ### if tupleCount != 4:
    ###     return False
    ### return True

def assertValidSFRotation(value):
    """
    Utility function to assert type validity of a SFRotation value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        SFRotation(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid SFRotation') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFRotation) and not isinstance(value, MFRotation):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFRotation')
    ### if isinstance(value, SFRotation):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = SFRotation(value)
    ###     print('found string for SFRotation, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif isinstance(value, MFRotation) and len(value) == 1:
    ###     value = value.value[0] # dereference value from this MF type #2b
    # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
    ### elif isinstance(value, str):
    ###     try:
    ###         float(value) # checks but does not set value, may throw exception
    ###     except ValueError:
    ###         print('SFRotation encountered string with illegal value=' + str(value))
    ###         raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFRotation')
    ### if not isinstance(value, tuple):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFRotation')
    ### # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFRotation):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         # print(flush=True)
    ###         raise X3DTypeError('SFRotation list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    ### if tupleCount != 4:
    ###     # print(flush=True)
    ###     raise X3DTypeError('SFRotation ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 4')
    ### if not isValidSFRotation(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFRotation')
    return True

def isValidMFRotation(value):
    """
    Utility function to determine type validity of a MFRotation value.
    """
    if re.fullmatch(MFRotation().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch MFRotation().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        MFRotation(value)
        return True
    except ValueError:
        print('isValidMFRotation failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFRotation) and not isinstance(value, MFRotation):
    ###         # if _DEBUG: print('MFRotation type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFRotation)=' + str(isinstance(value, MFRotation)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, MFRotation):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(MFRotation().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, SFRotation):
    ###     value = list(value.value) # dereference value from this SF type, convert to list #1
    ###     return True
    ### if not isinstance(value, list):
    ###     return False
    ### index = 0
    ### for each in value:
    ###     index += 1
   ###      if len(each) % MFRotation().TUPLE_SIZE()  != 0:
    ###         # if _DEBUG:
    ###         print('* isValidMFRotation tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFRotation().TUPLE_SIZE() =' + str(MFRotation().TUPLE_SIZE() ) + ' for value=' + str(value), flush=True)
    ###         return False
    ###     for element in each:
    ###         if not isinstance(element, float) and not isinstance(element, int):
    ###             return False
    ### return True

def assertValidMFRotation(value):
    """
    Utility function to assert type validity of a MFRotation value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        MFRotation(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid MFRotation') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFRotation) and not isinstance(value, MFRotation):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFRotation')
    ### if isinstance(value, MFRotation):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = MFRotation(value)
    ###     print('found string for MFRotation, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif (isinstance(value, SFRotation)) and not isinstance(value, list):
        ### value = list(SFRotation(value).value) # dereference value from this SF type, convert to list #2c
    ### if not isinstance(value, list):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFRotation')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    ### if isinstance(value, list):
    ###     index = 0
    ###     for each in value:
    ###         if len(each) % MFRotation().TUPLE_SIZE()  != 0:
                # print(flush=True)
    ###             raise X3DValueError('MFRotation tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFRotation().TUPLE_SIZE() =' + str(MFRotation().TUPLE_SIZE() ) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFRotation)):
#                # print(flush=True)
#                raise X3DTypeError('MFRotation element #' + str(index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
        ###     index += 1
        ###     if isinstance(each, tuple):
        ###         for element in each:
        ###             if not isinstance(element, float) and not isinstance(element, int):
        ###                 # print(flush=True)
        ###                 raise X3DTypeError('MFRotation element #' + str(index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    ### if not isValidMFRotation(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFRotation')
    return True

def isValidSFString(value):
    """
    Utility function to determine type validity of a SFString value.
    """
    if re.fullmatch(SFString().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch SFString().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        SFString(value)
        return True
    except ValueError:
        print('isValidSFString failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFString) and not isinstance(value, MFString):
    ###         # if _DEBUG: print('SFString type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFString)=' + str(isinstance(value, SFString)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, SFString):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(SFString().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, MFString) and (len(value) == 1) and isValidMFString(value):
    ###     value = value.value[0] # dereference value from this MF type
    ###     return True
    ### if not isinstance(value, str):
    ###     return False
    ### return True

def assertValidSFString(value):
    """
    Utility function to assert type validity of a SFString value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        SFString(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid SFString') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFString) and not isinstance(value, MFString):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFString')
    ### if isinstance(value, SFString):
    ###     value = value.value # dereference value from this base type #2a
    ### elif isinstance(value, MFString) and len(value) == 1:
    ###     value = value.value[0] # dereference value from this MF type #2b
    ### if not isinstance(value, str):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid str value for SFString')
    ### if not isValidSFString(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python str value for SFString')
    return True

def isValidMFString(value):
    """
    Utility function to determine type validity of a MFString value.
    """
    if re.fullmatch(MFString().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch MFString().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        MFString(value)
        return True
    except ValueError:
        print('isValidMFString failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFString) and not isinstance(value, MFString):
    ###         # if _DEBUG: print('MFString type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFString)=' + str(isinstance(value, MFString)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, MFString):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(MFString().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, SFString):
    ###     value = list(value.value) # dereference value from this SF type, convert to list #1
    ###     return True
    ### if not isinstance(value, list):
    ###     return False
    ### for each in value:
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFString):
    ###         each = each.value # dereference
    ###     if not isinstance(each, str):
    ###         return False
    ### return True

def assertValidMFString(value):
    """
    Utility function to assert type validity of a MFString value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        MFString(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid MFString') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFString) and not isinstance(value, MFString):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFString')
    ### if isinstance(value, MFString):
    ###     value = value.value # dereference value from this base type #2a
    ### elif (isinstance(value, SFString) or isinstance(value, str)) and not isinstance(value, list):
        ### value = list(SFString(value).value) # dereference value from this SF type, convert to list #2c
    ### if not isinstance(value, list):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFString')
    ### # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    ### for each in value:
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFString):
    ###         each = each.value # dereference
    ###     if not isinstance(each, str):
    ###         # print(flush=True)
    ###         raise X3DTypeError('MFString list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid str')
    ### if not isValidMFString(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFString')
    return True

def isValidSFTime(value):
    """
    Utility function to determine type validity of a SFTime value.
    """
    if re.fullmatch(SFTime().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch SFTime().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        SFTime(value)
        return True
    except ValueError:
        print('isValidSFTime failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFTime) and not isinstance(value, MFTime):
    ###         # if _DEBUG: print('SFTime type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFTime)=' + str(isinstance(value, SFTime)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, SFTime):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(SFTime().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, MFTime) and (len(value) == 1) and isValidMFTime(value):
    ###     value = value.value[0] # dereference value from this MF type
    ###     return True
    ### if not isinstance(value, float) and not isinstance(value, int):
    ###     return False
    ### return True

def assertValidSFTime(value):
    """
    Utility function to assert type validity of a SFTime value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        SFTime(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid SFTime') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFTime) and not isinstance(value, MFTime):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFTime')
    ### if isinstance(value, SFTime):
    ###     value = value.value # dereference value from this base type #2a
    ### elif isinstance(value, MFTime) and len(value) == 1:
    ###     value = value.value[0] # dereference value from this MF type #2b
    # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
    ### elif isinstance(value, str):
    ###     try:
    ###         float(value) # checks but does not set value, may throw exception
    ###     except ValueError:
    ###         print('SFTime encountered string with illegal value=' + str(value))
    ###         raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFTime')
    ### if not isinstance(value, float) and not isinstance(value, int):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFTime')
    ### if not isValidSFTime(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python float value for SFTime')
    return True

def isValidMFTime(value):
    """
    Utility function to determine type validity of a MFTime value.
    """
    if re.fullmatch(MFTime().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch MFTime().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        MFTime(value)
        return True
    except ValueError:
        print('isValidMFTime failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFTime) and not isinstance(value, MFTime):
    ###         # if _DEBUG: print('MFTime type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFTime)=' + str(isinstance(value, MFTime)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, MFTime):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(MFTime().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, SFTime):
    ###     value = list(value.value) # dereference value from this SF type, convert to list #1
    ###     return True
    ### if not isinstance(value, list):
    ###     return False
    ### for each in value:
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFTime):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         return False
    ### return True

def assertValidMFTime(value):
    """
    Utility function to assert type validity of a MFTime value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        MFTime(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid MFTime') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFTime) and not isinstance(value, MFTime):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFTime')
    ### if isinstance(value, MFTime):
    ###     value = value.value # dereference value from this base type #2a
    ### elif (isinstance(value, SFTime)) and not isinstance(value, list):
        ### value = list(SFTime(value).value) # dereference value from this SF type, convert to list #2c
    ### if not isinstance(value, list):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFTime')
    ### # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    ### for each in value:
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFTime):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         # print(flush=True)
    ###         raise X3DTypeError('MFTime list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    ### if not isValidMFTime(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFTime')
    return True

def isValidSFVec2d(value):
    """
    Utility function to determine type validity of a SFVec2d value.
    """
    if re.fullmatch(SFVec2d().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch SFVec2d().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        SFVec2d(value)
        return True
    except ValueError:
        print('isValidSFVec2d failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFVec2d) and not isinstance(value, MFVec2d):
    ###         # if _DEBUG: print('SFVec2d type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFVec2d)=' + str(isinstance(value, SFVec2d)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, SFVec2d):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(SFVec2d().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, MFVec2d) and (len(value) == 1) and isValidMFVec2d(value):
    ###     value = value.value[0] # dereference value from this MF type
    ###     return True
    ### if not isinstance(value, tuple):
    ###     return False
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFVec2d):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         return False
    ### if tupleCount != 2:
    ###     return False
    ### return True

def assertValidSFVec2d(value):
    """
    Utility function to assert type validity of a SFVec2d value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        SFVec2d(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid SFVec2d') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFVec2d) and not isinstance(value, MFVec2d):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFVec2d')
    ### if isinstance(value, SFVec2d):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = SFVec2d(value)
    ###     print('found string for SFVec2d, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif isinstance(value, MFVec2d) and len(value) == 1:
    ###     value = value.value[0] # dereference value from this MF type #2b
    # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
    ### elif isinstance(value, str):
    ###     try:
    ###         float(value) # checks but does not set value, may throw exception
    ###     except ValueError:
    ###         print('SFVec2d encountered string with illegal value=' + str(value))
    ###         raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFVec2d')
    ### if not isinstance(value, tuple):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec2d')
    ### # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFVec2d):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         # print(flush=True)
    ###         raise X3DTypeError('SFVec2d list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    ### if tupleCount != 2:
    ###     # print(flush=True)
    ###     raise X3DTypeError('SFVec2d ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 2')
    ### if not isValidSFVec2d(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec2d')
    return True

def isValidMFVec2d(value):
    """
    Utility function to determine type validity of a MFVec2d value.
    """
    if re.fullmatch(MFVec2d().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch MFVec2d().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        MFVec2d(value)
        return True
    except ValueError:
        print('isValidMFVec2d failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFVec2d) and not isinstance(value, MFVec2d):
    ###         # if _DEBUG: print('MFVec2d type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFVec2d)=' + str(isinstance(value, MFVec2d)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, MFVec2d):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(MFVec2d().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, SFVec2d):
    ###     value = list(value.value) # dereference value from this SF type, convert to list #1
    ###     return True
    ### if not isinstance(value, list):
    ###     return False
    ### index = 0
    ### for each in value:
    ###     index += 1
   ###      if len(each) % MFVec2d().TUPLE_SIZE()  != 0:
    ###         # if _DEBUG:
    ###         print('* isValidMFVec2d tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec2d().TUPLE_SIZE() =' + str(MFVec2d().TUPLE_SIZE() ) + ' for value=' + str(value), flush=True)
    ###         return False
    ###     for element in each:
    ###         if not isinstance(element, float) and not isinstance(element, int):
    ###             return False
    ### return True

def assertValidMFVec2d(value):
    """
    Utility function to assert type validity of a MFVec2d value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        MFVec2d(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid MFVec2d') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFVec2d) and not isinstance(value, MFVec2d):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFVec2d')
    ### if isinstance(value, MFVec2d):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = MFVec2d(value)
    ###     print('found string for MFVec2d, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif (isinstance(value, SFVec2d)) and not isinstance(value, list):
        ### value = list(SFVec2d(value).value) # dereference value from this SF type, convert to list #2c
    ### if not isinstance(value, list):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec2d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    ### if isinstance(value, list):
    ###     index = 0
    ###     for each in value:
    ###         if len(each) % MFVec2d().TUPLE_SIZE()  != 0:
                # print(flush=True)
    ###             raise X3DValueError('MFVec2d tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec2d().TUPLE_SIZE() =' + str(MFVec2d().TUPLE_SIZE() ) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFVec2d)):
#                # print(flush=True)
#                raise X3DTypeError('MFVec2d element #' + str(index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
        ###     index += 1
        ###     if isinstance(each, tuple):
        ###         for element in each:
        ###             if not isinstance(element, float) and not isinstance(element, int):
        ###                 # print(flush=True)
        ###                 raise X3DTypeError('MFVec2d element #' + str(index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    ### if not isValidMFVec2d(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec2d')
    return True

def isValidSFVec2f(value):
    """
    Utility function to determine type validity of a SFVec2f value.
    """
    if re.fullmatch(SFVec2f().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch SFVec2f().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        SFVec2f(value)
        return True
    except ValueError:
        print('isValidSFVec2f failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFVec2f) and not isinstance(value, MFVec2f):
    ###         # if _DEBUG: print('SFVec2f type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFVec2f)=' + str(isinstance(value, SFVec2f)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, SFVec2f):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(SFVec2f().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, MFVec2f) and (len(value) == 1) and isValidMFVec2f(value):
    ###     value = value.value[0] # dereference value from this MF type
    ###     return True
    ### if not isinstance(value, tuple):
    ###     return False
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFVec2f):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         return False
    ### if tupleCount != 2:
    ###     return False
    ### return True

def assertValidSFVec2f(value):
    """
    Utility function to assert type validity of a SFVec2f value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        SFVec2f(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid SFVec2f') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFVec2f) and not isinstance(value, MFVec2f):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFVec2f')
    ### if isinstance(value, SFVec2f):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = SFVec2f(value)
    ###     print('found string for SFVec2f, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif isinstance(value, MFVec2f) and len(value) == 1:
    ###     value = value.value[0] # dereference value from this MF type #2b
    # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
    ### elif isinstance(value, str):
    ###     try:
    ###         float(value) # checks but does not set value, may throw exception
    ###     except ValueError:
    ###         print('SFVec2f encountered string with illegal value=' + str(value))
    ###         raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFVec2f')
    ### if not isinstance(value, tuple):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec2f')
    ### # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFVec2f):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         # print(flush=True)
    ###         raise X3DTypeError('SFVec2f list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    ### if tupleCount != 2:
    ###     # print(flush=True)
    ###     raise X3DTypeError('SFVec2f ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 2')
    ### if not isValidSFVec2f(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec2f')
    return True

def isValidMFVec2f(value):
    """
    Utility function to determine type validity of a MFVec2f value.
    """
    if re.fullmatch(MFVec2f().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch MFVec2f().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        MFVec2f(value)
        return True
    except ValueError:
        print('isValidMFVec2f failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFVec2f) and not isinstance(value, MFVec2f):
    ###         # if _DEBUG: print('MFVec2f type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFVec2f)=' + str(isinstance(value, MFVec2f)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, MFVec2f):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(MFVec2f().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, SFVec2f):
    ###     value = list(value.value) # dereference value from this SF type, convert to list #1
    ###     return True
    ### if not isinstance(value, list):
    ###     return False
    ### index = 0
    ### for each in value:
    ###     index += 1
   ###      if len(each) % MFVec2f().TUPLE_SIZE()  != 0:
    ###         # if _DEBUG:
    ###         print('* isValidMFVec2f tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec2f().TUPLE_SIZE() =' + str(MFVec2f().TUPLE_SIZE() ) + ' for value=' + str(value), flush=True)
    ###         return False
    ###     for element in each:
    ###         if not isinstance(element, float) and not isinstance(element, int):
    ###             return False
    ### return True

def assertValidMFVec2f(value):
    """
    Utility function to assert type validity of a MFVec2f value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        MFVec2f(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid MFVec2f') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFVec2f) and not isinstance(value, MFVec2f):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFVec2f')
    ### if isinstance(value, MFVec2f):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = MFVec2f(value)
    ###     print('found string for MFVec2f, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif (isinstance(value, SFVec2f)) and not isinstance(value, list):
        ### value = list(SFVec2f(value).value) # dereference value from this SF type, convert to list #2c
    ### if not isinstance(value, list):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec2f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    ### if isinstance(value, list):
    ###     index = 0
    ###     for each in value:
    ###         if len(each) % MFVec2f().TUPLE_SIZE()  != 0:
                # print(flush=True)
    ###             raise X3DValueError('MFVec2f tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec2f().TUPLE_SIZE() =' + str(MFVec2f().TUPLE_SIZE() ) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFVec2f)):
#                # print(flush=True)
#                raise X3DTypeError('MFVec2f element #' + str(index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
        ###     index += 1
        ###     if isinstance(each, tuple):
        ###         for element in each:
        ###             if not isinstance(element, float) and not isinstance(element, int):
        ###                 # print(flush=True)
        ###                 raise X3DTypeError('MFVec2f element #' + str(index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    ### if not isValidMFVec2f(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec2f')
    return True

def isValidSFVec3d(value):
    """
    Utility function to determine type validity of a SFVec3d value.
    """
    if re.fullmatch(SFVec3d().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch SFVec3d().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        SFVec3d(value)
        return True
    except ValueError:
        print('isValidSFVec3d failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFVec3d) and not isinstance(value, MFVec3d):
    ###         # if _DEBUG: print('SFVec3d type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFVec3d)=' + str(isinstance(value, SFVec3d)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, SFVec3d):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(SFVec3d().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, MFVec3d) and (len(value) == 1) and isValidMFVec3d(value):
    ###     value = value.value[0] # dereference value from this MF type
    ###     return True
    ### if not isinstance(value, tuple):
    ###     return False
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFVec3d):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         return False
    ### if tupleCount != 3:
    ###     return False
    ### return True

def assertValidSFVec3d(value):
    """
    Utility function to assert type validity of a SFVec3d value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        SFVec3d(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid SFVec3d') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFVec3d) and not isinstance(value, MFVec3d):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFVec3d')
    ### if isinstance(value, SFVec3d):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = SFVec3d(value)
    ###     print('found string for SFVec3d, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif isinstance(value, MFVec3d) and len(value) == 1:
    ###     value = value.value[0] # dereference value from this MF type #2b
    # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
    ### elif isinstance(value, str):
    ###     try:
    ###         float(value) # checks but does not set value, may throw exception
    ###     except ValueError:
    ###         print('SFVec3d encountered string with illegal value=' + str(value))
    ###         raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFVec3d')
    ### if not isinstance(value, tuple):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec3d')
    ### # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFVec3d):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         # print(flush=True)
    ###         raise X3DTypeError('SFVec3d list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    ### if tupleCount != 3:
    ###     # print(flush=True)
    ###     raise X3DTypeError('SFVec3d ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 3')
    ### if not isValidSFVec3d(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec3d')
    return True

def isValidMFVec3d(value):
    """
    Utility function to determine type validity of a MFVec3d value.
    """
    if re.fullmatch(MFVec3d().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch MFVec3d().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        MFVec3d(value)
        return True
    except ValueError:
        print('isValidMFVec3d failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFVec3d) and not isinstance(value, MFVec3d):
    ###         # if _DEBUG: print('MFVec3d type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFVec3d)=' + str(isinstance(value, MFVec3d)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, MFVec3d):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(MFVec3d().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, SFVec3d):
    ###     value = list(value.value) # dereference value from this SF type, convert to list #1
    ###     return True
    ### if not isinstance(value, list):
    ###     return False
    ### index = 0
    ### for each in value:
    ###     index += 1
   ###      if len(each) % MFVec3d().TUPLE_SIZE()  != 0:
    ###         # if _DEBUG:
    ###         print('* isValidMFVec3d tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec3d().TUPLE_SIZE() =' + str(MFVec3d().TUPLE_SIZE() ) + ' for value=' + str(value), flush=True)
    ###         return False
    ###     for element in each:
    ###         if not isinstance(element, float) and not isinstance(element, int):
    ###             return False
    ### return True

def assertValidMFVec3d(value):
    """
    Utility function to assert type validity of a MFVec3d value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        MFVec3d(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid MFVec3d') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFVec3d) and not isinstance(value, MFVec3d):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFVec3d')
    ### if isinstance(value, MFVec3d):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = MFVec3d(value)
    ###     print('found string for MFVec3d, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif (isinstance(value, SFVec3d)) and not isinstance(value, list):
        ### value = list(SFVec3d(value).value) # dereference value from this SF type, convert to list #2c
    ### if not isinstance(value, list):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec3d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    ### if isinstance(value, list):
    ###     index = 0
    ###     for each in value:
    ###         if len(each) % MFVec3d().TUPLE_SIZE()  != 0:
                # print(flush=True)
    ###             raise X3DValueError('MFVec3d tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec3d().TUPLE_SIZE() =' + str(MFVec3d().TUPLE_SIZE() ) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFVec3d)):
#                # print(flush=True)
#                raise X3DTypeError('MFVec3d element #' + str(index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
        ###     index += 1
        ###     if isinstance(each, tuple):
        ###         for element in each:
        ###             if not isinstance(element, float) and not isinstance(element, int):
        ###                 # print(flush=True)
        ###                 raise X3DTypeError('MFVec3d element #' + str(index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    ### if not isValidMFVec3d(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec3d')
    return True

def isValidSFVec3f(value):
    """
    Utility function to determine type validity of a SFVec3f value.
    """
    if re.fullmatch(SFVec3f().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch SFVec3f().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        SFVec3f(value)
        return True
    except ValueError:
        print('isValidSFVec3f failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFVec3f) and not isinstance(value, MFVec3f):
    ###         # if _DEBUG: print('SFVec3f type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFVec3f)=' + str(isinstance(value, SFVec3f)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, SFVec3f):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(SFVec3f().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, MFVec3f) and (len(value) == 1) and isValidMFVec3f(value):
    ###     value = value.value[0] # dereference value from this MF type
    ###     return True
    ### if not isinstance(value, tuple):
    ###     return False
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFVec3f):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         return False
    ### if tupleCount != 3:
    ###     return False
    ### return True

def assertValidSFVec3f(value):
    """
    Utility function to assert type validity of a SFVec3f value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        SFVec3f(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid SFVec3f') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFVec3f) and not isinstance(value, MFVec3f):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFVec3f')
    ### if isinstance(value, SFVec3f):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = SFVec3f(value)
    ###     print('found string for SFVec3f, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif isinstance(value, MFVec3f) and len(value) == 1:
    ###     value = value.value[0] # dereference value from this MF type #2b
    # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
    ### elif isinstance(value, str):
    ###     try:
    ###         float(value) # checks but does not set value, may throw exception
    ###     except ValueError:
    ###         print('SFVec3f encountered string with illegal value=' + str(value))
    ###         raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFVec3f')
    ### if not isinstance(value, tuple):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec3f')
    ### # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFVec3f):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         # print(flush=True)
    ###         raise X3DTypeError('SFVec3f list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    ### if tupleCount != 3:
    ###     # print(flush=True)
    ###     raise X3DTypeError('SFVec3f ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 3')
    ### if not isValidSFVec3f(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec3f')
    return True

def isValidMFVec3f(value):
    """
    Utility function to determine type validity of a MFVec3f value.
    """
    if re.fullmatch(MFVec3f().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch MFVec3f().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        MFVec3f(value)
        return True
    except ValueError:
        print('isValidMFVec3f failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFVec3f) and not isinstance(value, MFVec3f):
    ###         # if _DEBUG: print('MFVec3f type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFVec3f)=' + str(isinstance(value, MFVec3f)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, MFVec3f):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(MFVec3f().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, SFVec3f):
    ###     value = list(value.value) # dereference value from this SF type, convert to list #1
    ###     return True
    ### if not isinstance(value, list):
    ###     return False
    ### index = 0
    ### for each in value:
    ###     index += 1
   ###      if len(each) % MFVec3f().TUPLE_SIZE()  != 0:
    ###         # if _DEBUG:
    ###         print('* isValidMFVec3f tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec3f().TUPLE_SIZE() =' + str(MFVec3f().TUPLE_SIZE() ) + ' for value=' + str(value), flush=True)
    ###         return False
    ###     for element in each:
    ###         if not isinstance(element, float) and not isinstance(element, int):
    ###             return False
    ### return True

def assertValidMFVec3f(value):
    """
    Utility function to assert type validity of a MFVec3f value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        MFVec3f(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid MFVec3f') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFVec3f) and not isinstance(value, MFVec3f):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFVec3f')
    ### if isinstance(value, MFVec3f):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = MFVec3f(value)
    ###     print('found string for MFVec3f, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif (isinstance(value, SFVec3f)) and not isinstance(value, list):
        ### value = list(SFVec3f(value).value) # dereference value from this SF type, convert to list #2c
    ### if not isinstance(value, list):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec3f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    ### if isinstance(value, list):
    ###     index = 0
    ###     for each in value:
    ###         if len(each) % MFVec3f().TUPLE_SIZE()  != 0:
                # print(flush=True)
    ###             raise X3DValueError('MFVec3f tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec3f().TUPLE_SIZE() =' + str(MFVec3f().TUPLE_SIZE() ) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFVec3f)):
#                # print(flush=True)
#                raise X3DTypeError('MFVec3f element #' + str(index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
        ###     index += 1
        ###     if isinstance(each, tuple):
        ###         for element in each:
        ###             if not isinstance(element, float) and not isinstance(element, int):
        ###                 # print(flush=True)
        ###                 raise X3DTypeError('MFVec3f element #' + str(index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    ### if not isValidMFVec3f(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec3f')
    return True

def isValidSFVec4d(value):
    """
    Utility function to determine type validity of a SFVec4d value.
    """
    if re.fullmatch(SFVec4d().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch SFVec4d().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        SFVec4d(value)
        return True
    except ValueError:
        print('isValidSFVec4d failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFVec4d) and not isinstance(value, MFVec4d):
    ###         # if _DEBUG: print('SFVec4d type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFVec4d)=' + str(isinstance(value, SFVec4d)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, SFVec4d):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(SFVec4d().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, MFVec4d) and (len(value) == 1) and isValidMFVec4d(value):
    ###     value = value.value[0] # dereference value from this MF type
    ###     return True
    ### if not isinstance(value, tuple):
    ###     return False
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFVec4d):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         return False
    ### if tupleCount != 4:
    ###     return False
    ### return True

def assertValidSFVec4d(value):
    """
    Utility function to assert type validity of a SFVec4d value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        SFVec4d(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid SFVec4d') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFVec4d) and not isinstance(value, MFVec4d):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFVec4d')
    ### if isinstance(value, SFVec4d):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = SFVec4d(value)
    ###     print('found string for SFVec4d, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif isinstance(value, MFVec4d) and len(value) == 1:
    ###     value = value.value[0] # dereference value from this MF type #2b
    # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
    ### elif isinstance(value, str):
    ###     try:
    ###         float(value) # checks but does not set value, may throw exception
    ###     except ValueError:
    ###         print('SFVec4d encountered string with illegal value=' + str(value))
    ###         raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFVec4d')
    ### if not isinstance(value, tuple):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec4d')
    ### # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFVec4d):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         # print(flush=True)
    ###         raise X3DTypeError('SFVec4d list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    ### if tupleCount != 4:
    ###     # print(flush=True)
    ###     raise X3DTypeError('SFVec4d ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 4')
    ### if not isValidSFVec4d(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec4d')
    return True

def isValidMFVec4d(value):
    """
    Utility function to determine type validity of a MFVec4d value.
    """
    if re.fullmatch(MFVec4d().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch MFVec4d().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        MFVec4d(value)
        return True
    except ValueError:
        print('isValidMFVec4d failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFVec4d) and not isinstance(value, MFVec4d):
    ###         # if _DEBUG: print('MFVec4d type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFVec4d)=' + str(isinstance(value, MFVec4d)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, MFVec4d):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(MFVec4d().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, SFVec4d):
    ###     value = list(value.value) # dereference value from this SF type, convert to list #1
    ###     return True
    ### if not isinstance(value, list):
    ###     return False
    ### index = 0
    ### for each in value:
    ###     index += 1
   ###      if len(each) % MFVec4d().TUPLE_SIZE()  != 0:
    ###         # if _DEBUG:
    ###         print('* isValidMFVec4d tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec4d().TUPLE_SIZE() =' + str(MFVec4d().TUPLE_SIZE() ) + ' for value=' + str(value), flush=True)
    ###         return False
    ###     for element in each:
    ###         if not isinstance(element, float) and not isinstance(element, int):
    ###             return False
    ### return True

def assertValidMFVec4d(value):
    """
    Utility function to assert type validity of a MFVec4d value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        MFVec4d(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid MFVec4d') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFVec4d) and not isinstance(value, MFVec4d):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFVec4d')
    ### if isinstance(value, MFVec4d):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = MFVec4d(value)
    ###     print('found string for MFVec4d, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif (isinstance(value, SFVec4d)) and not isinstance(value, list):
        ### value = list(SFVec4d(value).value) # dereference value from this SF type, convert to list #2c
    ### if not isinstance(value, list):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec4d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    ### if isinstance(value, list):
    ###     index = 0
    ###     for each in value:
    ###         if len(each) % MFVec4d().TUPLE_SIZE()  != 0:
                # print(flush=True)
    ###             raise X3DValueError('MFVec4d tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec4d().TUPLE_SIZE() =' + str(MFVec4d().TUPLE_SIZE() ) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFVec4d)):
#                # print(flush=True)
#                raise X3DTypeError('MFVec4d element #' + str(index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
        ###     index += 1
        ###     if isinstance(each, tuple):
        ###         for element in each:
        ###             if not isinstance(element, float) and not isinstance(element, int):
        ###                 # print(flush=True)
        ###                 raise X3DTypeError('MFVec4d element #' + str(index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    ### if not isValidMFVec4d(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec4d')
    return True

def isValidSFVec4f(value):
    """
    Utility function to determine type validity of a SFVec4f value.
    """
    if re.fullmatch(SFVec4f().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch SFVec4f().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        SFVec4f(value)
        return True
    except ValueError:
        print('isValidSFVec4f failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFVec4f) and not isinstance(value, MFVec4f):
    ###         # if _DEBUG: print('SFVec4f type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFVec4f)=' + str(isinstance(value, SFVec4f)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, SFVec4f):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(SFVec4f().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, MFVec4f) and (len(value) == 1) and isValidMFVec4f(value):
    ###     value = value.value[0] # dereference value from this MF type
    ###     return True
    ### if not isinstance(value, tuple):
    ###     return False
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFVec4f):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         return False
    ### if tupleCount != 4:
    ###     return False
    ### return True

def assertValidSFVec4f(value):
    """
    Utility function to assert type validity of a SFVec4f value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        SFVec4f(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid SFVec4f') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFVec4f) and not isinstance(value, MFVec4f):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFVec4f')
    ### if isinstance(value, SFVec4f):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = SFVec4f(value)
    ###     print('found string for SFVec4f, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif isinstance(value, MFVec4f) and len(value) == 1:
    ###     value = value.value[0] # dereference value from this MF type #2b
    # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
    ### elif isinstance(value, str):
    ###     try:
    ###         float(value) # checks but does not set value, may throw exception
    ###     except ValueError:
    ###         print('SFVec4f encountered string with illegal value=' + str(value))
    ###         raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFVec4f')
    ### if not isinstance(value, tuple):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec4f')
    ### # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    ### tupleCount = 0
    ### for each in value:
    ###     tupleCount += 1
    ###     while isinstance(each, list) and len(each) == 1:
    ###         each = each[0] # dereference
    ###     if isinstance(each, SFVec4f):
    ###         each = each.value # dereference
    ###     if not isinstance(each, float) and not isinstance(each, int):
    ###         # print(flush=True)
    ###         raise X3DTypeError('SFVec4f list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    ### if tupleCount != 4:
    ###     # print(flush=True)
    ###     raise X3DTypeError('SFVec4f ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 4')
    ### if not isValidSFVec4f(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec4f')
    return True

def isValidMFVec4f(value):
    """
    Utility function to determine type validity of a MFVec4f value.
    """
    if re.fullmatch(MFVec4f().REGEX_PYTHON(),str(value)) is None:
        print('* regex mismatch MFVec4f().REGEX_PYTHON(),' + str(value) + ')')
        return False
    try:
        MFVec4f(value)
        return True
    except ValueError:
        print('isValidMFVec4f failed with illegal value=' + str(value))
        return False
    ### if isinstance(value, _X3DField):
    ###     if not isinstance(value, SFVec4f) and not isinstance(value, MFVec4f):
    ###         # if _DEBUG: print('MFVec4f type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFVec4f)=' + str(isinstance(value, MFVec4f)), flush=True)
    ###        return False # type mismatch!
    ### if isinstance(value, MFVec4f):
    ###     value = value.value # dereference value from base type
    ###     if re.fullmatch(MFVec4f().REGEX_PYTHON(),str(value)) is None:
    ###         return False
    ###     return True
    ### if isinstance(value, SFVec4f):
    ###     value = list(value.value) # dereference value from this SF type, convert to list #1
    ###     return True
    ### if not isinstance(value, list):
    ###     return False
    ### index = 0
    ### for each in value:
    ###     index += 1
   ###      if len(each) % MFVec4f().TUPLE_SIZE()  != 0:
    ###         # if _DEBUG:
    ###         print('* isValidMFVec4f tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec4f().TUPLE_SIZE() =' + str(MFVec4f().TUPLE_SIZE() ) + ' for value=' + str(value), flush=True)
    ###         return False
    ###     for element in each:
    ###         if not isinstance(element, float) and not isinstance(element, int):
    ###             return False
    ### return True

def assertValidMFVec4f(value):
    """
    Utility function to assert type validity of a MFVec4f value, otherwise raise X3DTypeError with diagnostic message.
    """
    try:
        MFVec4f(value)
    except Exception as error:
        # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
        print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' but is not a valid MFVec4f') from error
    # if _DEBUG: print('...DEBUG... debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    # if _DEBUG: print('value=', value, 'str(value)=', str(value))
    ### if isinstance(value, _X3DField) and not isinstance(value, SFVec4f) and not isinstance(value, MFVec4f):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFVec4f')
    ### if isinstance(value, MFVec4f):
    ###     value = value.value # dereference value from this base type #2a
    ### if isinstance(value,str):
    ###     value = MFVec4f(value)
    ###     print('found string for MFVec4f, isinstance(value,list)=' + str(isinstance(value,list)),flush=True)
    ### elif (isinstance(value, SFVec4f)) and not isinstance(value, list):
        ### value = list(SFVec4f(value).value) # dereference value from this SF type, convert to list #2c
    ### if not isinstance(value, list):
    ###     print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec4f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    ### if isinstance(value, list):
    ###     index = 0
    ###     for each in value:
    ###         if len(each) % MFVec4f().TUPLE_SIZE()  != 0:
                # print(flush=True)
    ###             raise X3DValueError('MFVec4f tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec4f().TUPLE_SIZE() =' + str(MFVec4f().TUPLE_SIZE() ) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFVec4f)):
#                # print(flush=True)
#                raise X3DTypeError('MFVec4f element #' + str(index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
        ###     index += 1
        ###     if isinstance(each, tuple):
        ###         for element in each:
        ###             if not isinstance(element, float) and not isinstance(element, int):
        ###                 # print(flush=True)
        ###                 raise X3DTypeError('MFVec4f element #' + str(index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    ### if not isValidMFVec4f(value):
    ###     # print(flush=True)
    ###     raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec4f')
    return True


def assertValidFieldInitializationValue(name, fieldType, value, parent=''):
    """
    Utility function to assert fieldType validity of a field initialization value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('...DEBUG... assertValidFieldInitializationValue name=' + str(name) + ', fieldType=' + str(fieldType) + ', value=' + str(value)[:100] + ', parent=' + parent, flush=True)
    # note that ExternProtoDeclare field definitions do not have any value
    if name is None:
        print('* assertValidFieldInitializationValue improper invocation: name=' + str(name) + ', fieldType=' + str(fieldType) + ', value=' + str(value)[:100] + ', parent=' + parent + ', ignored', flush=True)
        return None # ignore
    if value is None or (not(fieldType == bool) and not value):
        return None # ignore
    if fieldType == 'SFString':
        assertValidSFString(value)
    elif fieldType == 'MFString':
        assertValidMFString(value)
    elif (fieldType == 'SFBool') or (fieldType == bool) or isinstance(value, bool):
        assertValidSFBool(value)
    elif fieldType == 'MFBool':
        assertValidMFBool(value)
    elif (fieldType == 'SFInt32') or (fieldType == int) or isinstance(value, int):
        assertValidSFInt32(value)
    elif fieldType == 'MFInt32':
        assertValidMFInt32(value)
    elif (fieldType == 'SFFloat') or (fieldType == float) or isinstance(value, float):
        assertValidSFFloat(value)
    elif fieldType == 'MFFloat':
        assertValidMFFloat(value)
    elif fieldType == 'SFDouble':
        assertValidSFDouble(value)
    elif fieldType == 'MFDouble':
        assertValidMFDouble(value)
    elif fieldType == 'SFTime':
        assertValidSFTime(value)
    elif fieldType == 'MFTime':
        assertValidMFTime(value)
    elif fieldType == 'SFColor':
        assertValidSFColor(value)
    elif fieldType == 'MFColorRGBA':
        assertValidMFColorRGBA(value)
    elif fieldType == 'SFRotation':
        assertValidSFRotation(value)
    elif fieldType == 'MFRotation':
        assertValidMFRotation(value)
    elif fieldType == 'SFImage':
        assertValidSFImage(value)
    elif fieldType == 'MFImage':
        assertValidMFImage(value)
    elif fieldType == 'SFNode':
        assertValidSFNode(value)
    elif fieldType == 'MFNode':
        assertValidMFNode(value)
    elif fieldType == 'SFVec2f':
        assertValidSFVec2f(value)
    elif fieldType == 'MFVec2f':
        assertValidMFVec2f(value)
    elif fieldType == 'SFVec3f':
        assertValidSFVec3f(value)
    elif fieldType == 'MFVec3f':
        assertValidMFVec3f(value)
    elif fieldType == 'SFVec4f':
        assertValidSFVec4f(value)
    elif fieldType == 'MFVec4f':
        assertValidMFVec4f(value)
    elif fieldType == 'SFVec2d':
        assertValidSFVec2d(value)
    elif fieldType == 'MFVec2d':
        assertValidMFVec2d(value)
    elif fieldType == 'SFVec3d':
        assertValidSFVec3d(value)
    elif fieldType == 'MFVec3d':
        assertValidMFVec3d(value)
    elif fieldType == 'SFVec4d':
        assertValidSFVec4d(value)
    elif fieldType == 'MFVec4d':
        assertValidMFVec4d(value)
    elif fieldType == 'SFMatrix3d':
        assertValidSFMatrix3f(value)
    elif fieldType == 'MFMatrix3f':
        assertValidMFMatrix3f(value)
    elif fieldType == 'SFMatrix4f':
        assertValidSFMatrix4f(value)
    elif fieldType == 'MFMatrix4f':
        assertValidMFMatrix4f(value)
    elif fieldType == 'SFMatrix3d':
        assertValidSFMatrix3d(value)
    elif fieldType == 'MFMatrix3d':
        assertValidMFMatrix3d(value)
    elif fieldType == 'SFMatrix4d':
        assertValidSFMatrix4d(value)
    elif fieldType == 'MFMatrix4d':
        assertValidMFMatrix4d(value)
    elif (fieldType == str)   or isinstance(value, str):
        assertValidSFString(value)
    elif str(parent) == 'fieldValue':
        return True # TODO check further if possible
    elif (fieldType == list) or isinstance(value, list):
        try:
            if isinstance(value[0], tuple):
                print('*** assertValidFieldInitializationValue TODO validate list fieldType: name=' + str(name) + ', passed fieldType=' + str(fieldType) + ', fieldType(value)=' + str(fieldType(value)) + ', value=' + str(value)[:100] + ', parent=' + parent, flush=True)
                return True # TODO check further
            initialListItemType = fieldType(value[0])
            # https://stackoverflow.com/questions/522563/accessing-the-index-in-for-loops/28072982#28072982
            # https://stackoverflow.com/questions/1952464/in-python-how-do-i-determine-if-an-object-is-iterable
            for index, each in enumerate(value):
                assertValidFieldInitializationValue(name + '[' + str(index) + ']', initialListItemType, value[index], parent)
            return True
        except TypeError:
            return False # TODO check further if possible
    elif (fieldType == tuple) or isinstance(value, tuple):
        print('*** assertValidFieldInitializationValue TODO validate tuple fieldType: name=' + str(name) + ', passed fieldType=' + str(fieldType) + ', fieldType(value)=' + str(fieldType(value)) + ', value=' + str(value)[:100] + ', parent=' + parent, flush=True)
        return True # TODO check further if possible
#       initialListItemType = fieldType(value[0])
#       for index, each in enumerate(value):
#           assertValidFieldInitializationValue(name + '[' + str(index) + '], fieldType(value[index])', value[index], parent)
    else:
        print('*** assertValidFieldInitializationValue unknown fieldType: name=' + str(name) + ', passed fieldType=' + str(fieldType) + ', fieldType(value)=' + str(fieldType(value)) + ', value=' + str(value)[:100] + ', parent=' + parent, flush=True)
        return False # TODO check further if possible
    return True
###############################################

class _X3DField:
    """
    X3DField is the abstract field type from which all single values field types are derived. All fields directly derived from X3DField have names beginning with SF (single-valued field). SF fields may only contain a single value of the type indicated by the name of the field type.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return '_X3DField'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldTypes.html#X3DField'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#FieldTypesTable'
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide value of this field type. """
        return self.__value
    def __repl__(self):
        # if _DEBUG: print('...DEBUG... type(self.value)=' + str(type(self.value)), flush=True)
        if isinstance(self.value, (SFString, str)):
            return "'" + self.value + "'"
        if  isinstance(self.value, tuple) and 'SF' in str(type(self)): # avoid X3DTypeError if value is not iterable
            result = '('
            if self.value: # walk each child in list, if any (avoid empty list recursion)
                for each in self.value:
                    result += str(each) + ', '
                    # if _DEBUG: print('...DEBUG... _X3DField debug: str(each)=' + str(each), flush=True)
            return result.rstrip(', ') + ')'
        if  isinstance(self.value, list) and 'MF' in str(type(self)): # avoid X3DTypeError if value is not iterable
            # isinstance(self.value, MFNode): not working, what got passed in was not an MFNode object apparently
            result = '['
            if self.value: # walk each child in list, if any (avoid empty list recursion)
                for each in self.value:
                    result += str(each) + ', '
                    # if _DEBUG: print('...DEBUG... _X3DField debug: str(each)=' + str(each), flush=True)
            return result.rstrip(', ') + ']'
        return str(self.value)
    def __str__(self):
        return self.__repl__()

class _X3DArrayField(_X3DField):
    """
    X3DArrayField is the abstract field type from which all field types that can contain multiple values are derived, implementing the X3DField interface. All fields derived from X3DArrayField have names beginning with MF (multiple-valued field). MF fields may zero or more values, each of which shall be of the type indicated by the corresponding SF field type. It is illegal for any MF field to mix values of different SF field types.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DArrayField'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldTypes.html#X3DArrayField'

def isX3DField(value):
    """
    Determine whether object is an instance of _X3DField.
    """
    return isinstance(value, _X3DField)

# Access Types

class AccessType(_X3DField):
    """
    accessType determines whether a field corresponds to event input, event output, or persistent state information. Events are strictly typed values with a corresponding timestamp. ROUTE connections must match accessType between source field and target field.
    """
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/concepts.html#FieldSemantics'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#accessType'
    @staticmethod
    def initializeOnly():
        """ initializeOnly: can be initialized, but cannot send or receive events. This is usually the case for fields that are considered too computationally expensive to change at run time. """
        return 'initializeOnly'
    @staticmethod
    def inputOutput():
        """ inputOutput: can be initialized, and can also send or receive events during run-time operations. """
        return 'inputOutput'
    @staticmethod
    def inputOnly():
        """ inputOnly: cannot be initialized or included in a scene file, but can receive input event values via a ROUTE during run-time operations. """
        return 'inputOnly'
    @staticmethod
    def outputOnly():

        """ outputOnly: cannot be initialized or included in a scene file, but can send output event values via a ROUTE during run-time operations. """
        return 'outputOnly'


# Field Types

class FieldType(_X3DField):
    """
    The X3D Architecture specification of field types classify the possible values for a field.
    Each field in each node (i.e. each XML attribute) has a strictly defined data type.
    Multiple data types are provided for boolean, integer, floating-point and string values.
    X3D is a strongly typed language, meaning that all data must strictly conform to these data types in order for a scene to be correct.
    """
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#type'
    # string constants listing each allowed type
    @staticmethod
    def SFBool():
        """ Type SFBool https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFBool """
        return 'SFBool'
    @staticmethod
    def MFBool():
        """ Type MFBool https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFBool """
        return 'MFBool'
    @staticmethod
    def SFColor():
        """ Type SFColor https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFColor """
        return 'SFColor'
    @staticmethod
    def MFColor():
        """ Type MFColor https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFColor """
        return 'MFColor'
    @staticmethod
    def SFColorRGBA():
        """ Type SFColorRGBA https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFColorRGBA """
        return 'SFColorRGBA'
    @staticmethod
    def MFColorRGBA():
        """ Type MFColorRGBA https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFColorRGBA """
        return 'MFColorRGBA'
    @staticmethod
    def SFDouble():
        """ Type SFDouble https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFDouble """
        return 'SFDouble'
    @staticmethod
    def MFDouble():
        """ Type MFDouble https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFDouble """
        return 'MFDouble'
    @staticmethod
    def SFFloat():
        """ Type SFFloat https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFFloat """
        return 'SFFloat'
    @staticmethod
    def MFFloat():
        """ Type MFFloat https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFFloat """
        return 'MFFloat'
    @staticmethod
    def SFImage():
        """ Type SFImage https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFImage """
        return 'SFImage'
    @staticmethod
    def MFImage():
        """ Type MFImage https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFImage """
        return 'MFImage'
    @staticmethod
    def SFInt32():
        """ Type SFInt32 https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFInt32 """
        return 'SFInt32'
    @staticmethod
    def MFInt32():
        """ Type MFInt32 https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFInt32 """
        return 'MFInt32'
    @staticmethod
    def SFMatrix3d():
        """ Type SFMatrix3d https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFMatrix3d """
        return 'SFMatrix3d'
    @staticmethod
    def MFMatrix3d():
        """ Type MFMatrix3d https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFMatrix3d """
        return 'MFMatrix3d'
    @staticmethod
    def SFMatrix3f():
        """ Type SFMatrix3f https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFMatrix3f """
        return 'SFMatrix3f'
    @staticmethod
    def MFMatrix3f():
        """ Type MFMatrix3f https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFMatrix3f """
        return 'MFMatrix3f'
    @staticmethod
    def SFMatrix4d():
        """ Type SFMatrix4d https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFMatrix4d """
        return 'SFMatrix4d'
    @staticmethod
    def MFMatrix4d():
        """ Type MFMatrix4d https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFMatrix4d """
        return 'MFMatrix4d'
    @staticmethod
    def SFMatrix4f():
        """ Type SFMatrix4f https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFMatrix4f """
        return 'SFMatrix4f'
    @staticmethod
    def MFMatrix4f():
        """ Type MFMatrix4f https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFMatrix4f """
        return 'MFMatrix4f'
    @staticmethod
    def SFNode():
        """ Type SFNode https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFNode """
        return 'SFNode'
    @staticmethod
    def MFNode():
        """ Type MFNode https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFNode """
        return 'MFNode'
    @staticmethod
    def SFRotation():
        """ Type SFRotation https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFRotation """
        return 'SFRotation'
    @staticmethod
    def MFRotation():
        """ Type MFRotation https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFRotation """
        return 'MFRotation'
    @staticmethod
    def SFString():
        """ Type SFString https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFString """
        return 'SFString'
    @staticmethod
    def MFString():
        """ Type MFString https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFString """
        return 'MFString'
    @staticmethod
    def SFTime():
        """ Type SFTime https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFTime """
        return 'SFTime'
    @staticmethod
    def MFTime():
        """ Type MFTime https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFTime """
        return 'MFTime'
    @staticmethod
    def SFVec2d():
        """ Type SFVec2d https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec2d """
        return 'SFVec2d'
    @staticmethod
    def MFVec2d():
        """ Type MFVec2d https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec2d """
        return 'MFVec2d'
    @staticmethod
    def SFVec2f():
        """ Type SFVec2f https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec2f """
        return 'SFVec2f'
    @staticmethod
    def MFVec2f():
        """ Type MFVec2f https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec2f """
        return 'MFVec2f'
    @staticmethod
    def SFVec3d():
        """ Type SFVec3d https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec3d """
        return 'SFVec3d'
    @staticmethod
    def MFVec3d():
        """ Type MFVec3d https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec3d """
        return 'MFVec3d'
    @staticmethod
    def SFVec3f():
        """ Type SFVec3f https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec3f """
        return 'SFVec3f'
    @staticmethod
    def MFVec3f():
        """ Type MFVec3f https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec3f """
        return 'MFVec3f'
    @staticmethod
    def SFVec4d():
        """ Type SFVec4d https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec4d """
        return 'SFVec4d'
    @staticmethod
    def MFVec4d():
        """ Type MFVec4d https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec4d """
        return 'MFVec4d'
    @staticmethod
    def SFVec4f():
        """ Type SFVec4f https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec4f """
        return 'SFVec4f'
    @staticmethod
    def MFVec4f():
        """ Type MFVec4f https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec4f """
        return 'MFVec4f'

class SFBool(_X3DField):
    """
    Field type Python Boolean values are capitalized as True or False. SFBool is a logical type with possible values (true|false) to match the XML boolean type. Hint: XML boolean values are lower case (true|false) in order to maintain compatibility with HTML and other XML documents.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'SFBool'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFBoolAndMFBool'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFBool'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return False
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return False
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 1
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(true|false|True|False)\s*'  # (less than fully strict Python: allows lower-case strings true, false)
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(true|false)\s*'
    # - - - - - - - - - -
    def __init__(self, value=False):
        # print('*** SFBool __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        value = fixBoolean(value, default=SFBool.DEFAULT_VALUE())
        if isinstance(value,SFBool):
            value = value.value # dereference
        elif value is None:
            value = SFBool.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to SFBool.DEFAULT_VALUE()=' + str(SFBool.DEFAULT_VALUE()))
        elif isinstance(value, MFBool) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        self.__value = value
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, SFBool self.__value type=' + str(type(self.__value)) + ' is not a list')
        return len(self.__value) > 0

class MFBool(_X3DArrayField):
    """
    Field type Python Boolean values are capitalized as True or False. MFBool is an array of boolean values. Type MFBool was previously undefined in the VRML97 Specification, but nevertheless needed for event utilities and scripting. Example use: MFBool is useful for defining a series of behavior states using a BooleanSequencer prototype. Hint: XML boolean values are lower case (true|false) in order to maintain compatibility with HTML and other XML documents.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'MFBool'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFBoolAndMFBool'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFBool'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return True
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 1
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\[?\s*((true|false|True|False)\s*,?\s*)*\]?\s*'  # (less than fully strict Python: allows lower-case strings true, false)
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*((true|false)\s*,?\s*)*'
    # - - - - - - - - - -
    def __init__(self, value=None):
        if value is None:
            value = self.DEFAULT_VALUE()
        # print('*** MFBool __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        value = fixBoolean(value, default=MFBool.DEFAULT_VALUE())
        if not isinstance(value,list):
            _newValue = [ value ]
        else:
            _newValue = []
            for each in value:
                _newValue.append(SFBool(each).value)
        value = _newValue
        if isinstance(value,SFBool):
            value = value.value # dereference
        elif value is None:
            value = MFBool.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to MFBool.DEFAULT_VALUE()=' + str(MFBool.DEFAULT_VALUE()))
    ###     elif not isinstance(value, list) and isValidSFBool(value):
    ###         print(' upcast to MF type', value)
    ###         value = MFBool(SFBool(value))
        elif isinstance(value, list):
            if not value is None and not (isinstance(value,list) and len(value) == 0):
                _newValue = []
                for each in value:
                    _newValue.append(SFBool(each).value)
                # if _DEBUG: print('...DEBUG... assign list, value=' + str(value), ', type=' + str(type(value)), ', _newValue=' + str(_newValue),flush=True)
                value = _newValue
        elif isinstance(value, str):
            value = [ bool(value) ]
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            # if _DEBUG: print('...DEBUG... append to list, value=' + str(self.__value), ', type=' + str(type(self.__value)), ', value=' + str(value),flush=True)
            if isinstance(value,SFBool):
                self.__value.append(value.value) # dereference
            elif not isinstance(value,list) and not isinstance(value,MFBool):
                self.__value.append(SFBool(value).value) # checks validity
            elif (isinstance(value,list) and len(value) > 0) or isinstance(value,MFBool):
                for each in value:
                    self.__value.append(SFBool(each).value) # checks validity
            elif isinstance(value,str):
                self.__value.append(SFBool(value).value) # checks validity
    ###     if  not value is None:
    ###         if isValidSFBool(value):
    ###             if isinstance(value, SFBool):
    ###                 value = SFBool(value).value # dereference value from base type
    ###             self.__value.append(value)
    ###         elif isValidMFBool(value):
    ###             for each in value:
    ###                 while isinstance(each, list) and len(each) == 1:
    ###                     each = each[0] # dereference
    ###                 if isinstance(each, SFBool):
    ###                     each = each.value # dereference
    ###                 self.__value.append(each)
    ###         else:
    ###             assertValidMFBool(value) # report type failure
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, MFBool self.__value type=' + str(type(self.__value)) + ' is not a list', flush=True)
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFColor(_X3DField):
    """
    Field type SFColor specifies one RGB (red-green-blue) color triple, where each color value is an RGB triple of floating point numbers in range [0,1]. The default value of an uninitialized SFColor field is (0 0 0). Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'SFColor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFColorAndMFColor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFColor'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return (0, 0, 0)
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return False
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 3
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\(\s*(([+]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)\s*\,?\s*){2}([+]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)\s*\)\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(([+]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)\s+){2}([+]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)\s*'
    # - - - - - - - - - -
    def __init__(self, value=None,value2=None,value3=None):
        # print('*** SFColor __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        if isinstance(value,str):
            value = float(value)
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value,value2=None,value3=None):
        """ The value setter only allows correctly typed and sized values. """
        if value2 is not None and value3 is not None:
            value = (float(value),float(value2),float(value3))
        if isinstance(value,SFColor):
            value = value.value # dereference
        elif value is None:
            value = SFColor.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to SFColor.DEFAULT_VALUE()=' + str(SFColor.DEFAULT_VALUE()))
        elif isinstance(value, list):
            for each in value: # check that contained elements are not tuples or lists
                if isinstance(each, tuple):
                    break
            if len(value) == 3:
                value = (value[0],value[1],value[2])
            else: # no tuples found, create 3-tuples
                value = [(x, y, z) for x, y, z in value]
        elif isinstance(value, MFColor) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
        if isinstance(value, str):
            try:
                float(value) # this statement checks but does not set value, may throw exception
                print('*** string value provided, value=' + str(value) + ', float(value)=' + str(float(value)), flush=True)
                value = float(value)
            except ValueError as error:
                # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
                raise X3DTypeError('SFColor encountered string with illegal value=' + str(value)) from error
        assertZeroToOne(SFColor,value)
        self.__value = value
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, SFColor self.__value type=' + str(type(self.__value)) + ' is not a list')
        return len(self.__value) > 0

class MFColor(_X3DArrayField):
    """
    Field type MFColor specifies zero or more SFColor RGB triples, where each color value is an RGB triple of floating point numbers in range [0,1]. The default value of an uninitialized MFColor field is the empty list. Individual SFColor array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'MFColor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFColorAndMFColor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFColor'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return True
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 3
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\[?\s*(\s*\(?\s*((([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)\s*\,?\s*){2}([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)\s*,?\s*)*\)?\s*\,?)*\s*\]?\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*((([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)\s+){2}([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)\s*,?\s*)*'
    # - - - - - - - - - -
    def __init__(self, value=None,value2=None,value3=None):
        if value is None:
            value = self.DEFAULT_VALUE()
        # print('*** MFColor __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        if value2 is not None and value3 is not None:
            value = (float(value),float(value2),float(value3))
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value,value2=None,value3=None):
        """ The value setter only allows correctly typed and sized values. """
        if value2 is not None and value3 is not None:
            value = (float(value),float(value2),float(value3))
        if isinstance(value,SFColor):
            value = value.value # dereference
        elif value is None:
            value = MFColor.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to MFColor.DEFAULT_VALUE()=' + str(MFColor.DEFAULT_VALUE()))
        elif isinstance(value, list):
            for each in value: # check that contained elements are not tuples or lists
                if isinstance(each, tuple):
                    break
            if len(value) == 3:
                value = (value[0],value[1],value[2])
            else: # no tuples found, create 3-tuples
                value = [(x, y, z) for x, y, z in value]
    ###     elif not isinstance(value, list) and isValidSFColor(value):
    ###         print(' upcast to MF type', value)
    ###         value = MFColor(SFColor(value))
        elif isinstance(value, list):
            if not value is None and not (isinstance(value,list) and len(value) == 0):
                _newValue = []
                for each in value:
                    _newValue.append(SFColor(each).value)
                # if _DEBUG: print('...DEBUG... assign list, value=' + str(value), ', type=' + str(type(value)), ', _newValue=' + str(_newValue),flush=True)
                value = _newValue
        elif isinstance(value, str):
            value = [ float(value) ]
        assertZeroToOne(MFColor,value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            # if _DEBUG: print('...DEBUG... append to list, value=' + str(self.__value), ', type=' + str(type(self.__value)), ', value=' + str(value),flush=True)
            if isinstance(value,SFColor):
                self.__value.append(value.value) # dereference
            elif not isinstance(value,list) and not isinstance(value,MFColor):
                self.__value.append(SFColor(value).value) # checks validity
            elif (isinstance(value,list) and len(value) > 0) or isinstance(value,MFColor):
                for each in value:
                    self.__value.append(SFColor(each).value) # checks validity
            elif isinstance(value,str):
                self.__value.append(SFColor(value).value) # checks validity
    ###     if  not value is None:
    ###         if isValidSFColor(value):
    ###             if isinstance(value, SFColor):
    ###                 value = SFColor(value).value # dereference value from base type
    ###             self.__value.append(value)
    ###         elif isValidMFColor(value):
    ###             for each in value:
    ###                 while isinstance(each, list) and len(each) == 1:
    ###                     each = each[0] # dereference
    ###                 if isinstance(each, SFColor):
    ###                     each = each.value # dereference
    ###                 self.__value.append(each)
    ###         else:

    ###             assertValidMFColor(value) # report type failure
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, MFColor self.__value type=' + str(type(self.__value)) + ' is not a list', flush=True)
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFColorRGBA(_X3DField):
    """
    Field type SFColorRGBA specifies one RGBA (red-green-blue-alpha) color 4-tuple, where each color value is an RGBA 4-tuple of floating point numbers in range [0,1]. Alpha (opacity) values = (1 - transparency). The default value of an uninitialized SFColorRGBA field is (0 0 0 0). Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'SFColorRGBA'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFColorRGBAAndMFColorRGBA'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFColorRGBA'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return (0, 0, 0, 0)
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return False
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 4
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\(\s*(([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)\s*\,?\s*){3}([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)\s*\)\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)\s+){3}([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)\s*'
    # - - - - - - - - - -
    def __init__(self, value=None,value2=None,value3=None,value4=None):
        # print('*** SFColorRGBA __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        if isinstance(value,str):
            value = float(value)
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value,value2=None,value3=None,value4=None):
        """ The value setter only allows correctly typed and sized values. """
        if value2 is not None and value3 is not None and value4 is not None:
            value = (float(value),float(value2),float(value3),float(value4))
        if isinstance(value,SFColorRGBA):
            value = value.value # dereference
        elif value is None:
            value = SFColorRGBA.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to SFColorRGBA.DEFAULT_VALUE()=' + str(SFColorRGBA.DEFAULT_VALUE()))
        elif isinstance(value, list):
            for each in value: # check that contained elements are not tuples or lists
                if isinstance(each, tuple):
                    break
            if len(value) == 4:
                value = (value[0],value[1],value[2],value[3])
            else: # no tuples found, create 4-tuples
                value = [(x, y, z, w) for x, y, z, w in value]
        elif isinstance(value, MFColorRGBA) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
        if isinstance(value, str):
            try:
                float(value) # this statement checks but does not set value, may throw exception
                print('*** string value provided, value=' + str(value) + ', float(value)=' + str(float(value)), flush=True)
                value = float(value)
            except ValueError as error:
                # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
                raise X3DTypeError('SFColorRGBA encountered string with illegal value=' + str(value)) from error
        assertZeroToOne(SFColorRGBA,value)
        self.__value = value
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, SFColorRGBA self.__value type=' + str(type(self.__value)) + ' is not a list')
        return len(self.__value) > 0

class MFColorRGBA(_X3DArrayField):
    """
    Field type MFColorRGBA specifies zero or more SFColorRGBA 4-tuples, where each color value is an RGBA 4-tuple of floating point numbers in range [0,1]. Alpha (opacity) values = (1 - transparency). The default value of an uninitialized MFColor field is the empty list. Individual SFColorRGBA array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'MFColorRGBA'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFColorRGBAAndMFColorRGBA'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFColorRGBA'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return True
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 4
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\[?\s*(\s*\(?\s*((([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)\s*\,?\s*){3}([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)\s*,?\s*)*\)?\s*\,?)*\s*\]?\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*((([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)\s+){3}([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)\s*,?\s*)*'
    # - - - - - - - - - -
    def __init__(self, value=None,value2=None,value3=None,value4=None):
        if value is None:
            value = self.DEFAULT_VALUE()
        # print('*** MFColorRGBA __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        if value2 is not None and value3 is not None and value4 is not None:
            value = (float(value),float(value2),float(value3),float(value4))
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value,value2=None,value3=None,value4=None):
        """ The value setter only allows correctly typed and sized values. """
        if value2 is not None and value3 is not None and value4 is not None:
            value = (float(value),float(value2),float(value3),float(value4))
        if isinstance(value,SFColorRGBA):
            value = value.value # dereference
        elif value is None:
            value = MFColorRGBA.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to MFColorRGBA.DEFAULT_VALUE()=' + str(MFColorRGBA.DEFAULT_VALUE()))
        elif isinstance(value, list):
            for each in value: # check that contained elements are not tuples or lists
                if isinstance(each, tuple):
                    break
            if len(value) == 4:
                value = (value[0],value[1],value[2],value[3])
            else: # no tuples found, create 4-tuples
                value = [(x, y, z, w) for x, y, z, w in value]
    ###     elif not isinstance(value, list) and isValidSFColorRGBA(value):
    ###         print(' upcast to MF type', value)
    ###         value = MFColorRGBA(SFColorRGBA(value))
        elif isinstance(value, list):
            if not value is None and not (isinstance(value,list) and len(value) == 0):
                _newValue = []
                for each in value:
                    _newValue.append(SFColorRGBA(each).value)
                # if _DEBUG: print('...DEBUG... assign list, value=' + str(value), ', type=' + str(type(value)), ', _newValue=' + str(_newValue),flush=True)
                value = _newValue
        elif isinstance(value, str):
            value = [ float(value) ]
        assertZeroToOne(MFColorRGBA,value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            # if _DEBUG: print('...DEBUG... append to list, value=' + str(self.__value), ', type=' + str(type(self.__value)), ', value=' + str(value),flush=True)
            if isinstance(value,SFColorRGBA):
                self.__value.append(value.value) # dereference
            elif not isinstance(value,list) and not isinstance(value,MFColorRGBA):
                self.__value.append(SFColorRGBA(value).value) # checks validity
            elif (isinstance(value,list) and len(value) > 0) or isinstance(value,MFColorRGBA):
                for each in value:
                    self.__value.append(SFColorRGBA(each).value) # checks validity
            elif isinstance(value,str):
                self.__value.append(SFColorRGBA(value).value) # checks validity
    ###     if  not value is None:
    ###         if isValidSFColorRGBA(value):
    ###             if isinstance(value, SFColorRGBA):
    ###                 value = SFColorRGBA(value).value # dereference value from base type
    ###             self.__value.append(value)
    ###         elif isValidMFColorRGBA(value):
    ###             for each in value:
    ###                 while isinstance(each, list) and len(each) == 1:
    ###                     each = each[0] # dereference
    ###                 if isinstance(each, SFColorRGBA):
    ###                     each = each.value # dereference
    ###                 self.__value.append(each)
    ###         else:
    ###             assertValidMFColorRGBA(value) # report type failure
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, MFColorRGBA self.__value type=' + str(type(self.__value)) + ' is not a list', flush=True)
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFDouble(_X3DField):
    """
    Field type SFDouble is a double-precision floating-point type. Array values are optionally separated by commas in XML syntax. See GeoVRML 1.0 Recommended Practice, Section 2.3, Limitations of Single Precision for rationale.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'SFDouble'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFDoubleAndMFDouble'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFDouble'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return 0.0
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return False
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 1
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*'
    # - - - - - - - - - -
    def __init__(self, value=0.0):
        # print('*** SFDouble __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        if isinstance(value,str):
            value = float(value)
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFDouble):
            value = value.value # dereference
        elif value is None:
            value = SFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to SFDouble.DEFAULT_VALUE()=' + str(SFDouble.DEFAULT_VALUE()))
        elif isinstance(value, MFDouble) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
        if isinstance(value, str):
            try:
                float(value) # this statement checks but does not set value, may throw exception
                print('*** string value provided, value=' + str(value) + ', float(value)=' + str(float(value)), flush=True)
                value = float(value)
            except ValueError as error:
                # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
                raise X3DTypeError('SFDouble encountered string with illegal value=' + str(value)) from error
        self.__value = value
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, SFDouble self.__value type=' + str(type(self.__value)) + ' is not a list')
        return len(self.__value) > 0

class MFDouble(_X3DArrayField):
    """
    Field type MFDouble is an array of Double values, meaning a double-precision floating-point array type. See GeoVRML 1.0 Recommended Practice, Section 2.3, Limitations of Single Precision for rationale. Array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'MFDouble'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFDoubleAndMFDouble'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFDouble'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return True
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 1
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\[?\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*\]?\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*'
    # - - - - - - - - - -
    def __init__(self, value=None):
        if value is None:
            value = self.DEFAULT_VALUE()
        # print('*** MFDouble __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFDouble):
            value = value.value # dereference
        elif value is None:
            value = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to MFDouble.DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
    ###     elif not isinstance(value, list) and isValidSFDouble(value):
    ###         print(' upcast to MF type', value)
    ###         value = MFDouble(SFDouble(value))
        elif isinstance(value, list):
            if not value is None and not (isinstance(value,list) and len(value) == 0):
                _newValue = []
                for each in value:
                    _newValue.append(SFDouble(each).value)
                # if _DEBUG: print('...DEBUG... assign list, value=' + str(value), ', type=' + str(type(value)), ', _newValue=' + str(_newValue),flush=True)
                value = _newValue
        elif isinstance(value, str):
            value = [ float(value) ]
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            # if _DEBUG: print('...DEBUG... append to list, value=' + str(self.__value), ', type=' + str(type(self.__value)), ', value=' + str(value),flush=True)
            if isinstance(value,SFDouble):
                self.__value.append(value.value) # dereference
            elif not isinstance(value,list) and not isinstance(value,MFDouble):
                self.__value.append(SFDouble(value).value) # checks validity
            elif (isinstance(value,list) and len(value) > 0) or isinstance(value,MFDouble):
                for each in value:
                    self.__value.append(SFDouble(each).value) # checks validity
            elif isinstance(value,str):
                self.__value.append(SFDouble(value).value) # checks validity
    ###     if  not value is None:
    ###         if isValidSFDouble(value):
    ###             if isinstance(value, SFDouble):
    ###                 value = SFDouble(value).value # dereference value from base type
    ###             self.__value.append(value)
    ###         elif isValidMFDouble(value):
    ###             for each in value:
    ###                 while isinstance(each, list) and len(each) == 1:
    ###                     each = each[0] # dereference
    ###                 if isinstance(each, SFDouble):
    ###                     each = each.value # dereference
    ###                 self.__value.append(each)
    ###         else:
    ###             assertValidMFDouble(value) # report type failure
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, MFDouble self.__value type=' + str(type(self.__value)) + ' is not a list', flush=True)
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFFloat(_X3DField):
    """
    Field type SFFloat is a single-precision floating-point type.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'SFFloat'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFFloatAndMFFloat'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFFloat'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return 0.0
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return False
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 1
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*'
    # - - - - - - - - - -
    def __init__(self, value=0.0):
        # print('*** SFFloat __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        if isinstance(value,str):
            value = float(value)
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFFloat):
            value = value.value # dereference
        elif value is None:
            value = SFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to SFFloat.DEFAULT_VALUE()=' + str(SFFloat.DEFAULT_VALUE()))
        elif isinstance(value, MFFloat) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
        if isinstance(value, str):
            try:
                float(value) # this statement checks but does not set value, may throw exception
                print('*** string value provided, value=' + str(value) + ', float(value)=' + str(float(value)), flush=True)
                value = float(value)
            except ValueError as error:
                # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
                raise X3DTypeError('SFFloat encountered string with illegal value=' + str(value)) from error
        self.__value = value
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, SFFloat self.__value type=' + str(type(self.__value)) + ' is not a list')
        return len(self.__value) > 0

class MFFloat(_X3DArrayField):
    """
    Field type MFFloat is an array of SFFloat values, meaning a single-precision floating-point array type. Array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'MFFloat'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFFloatAndMFFloat'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFFloat'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return True
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 1
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\[?\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*\]?\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*'
    # - - - - - - - - - -
    def __init__(self, value=None):
        if value is None:
            value = self.DEFAULT_VALUE()
        # print('*** MFFloat __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFFloat):
            value = value.value # dereference
        elif value is None:
            value = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to MFFloat.DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
    ###     elif not isinstance(value, list) and isValidSFFloat(value):
    ###         print(' upcast to MF type', value)
    ###         value = MFFloat(SFFloat(value))
        elif isinstance(value, list):
            if not value is None and not (isinstance(value,list) and len(value) == 0):
                _newValue = []
                for each in value:
                    _newValue.append(SFFloat(each).value)
                # if _DEBUG: print('...DEBUG... assign list, value=' + str(value), ', type=' + str(type(value)), ', _newValue=' + str(_newValue),flush=True)
                value = _newValue
        elif isinstance(value, str):
            value = [ float(value) ]
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            # if _DEBUG: print('...DEBUG... append to list, value=' + str(self.__value), ', type=' + str(type(self.__value)), ', value=' + str(value),flush=True)
            if isinstance(value,SFFloat):
                self.__value.append(value.value) # dereference
            elif not isinstance(value,list) and not isinstance(value,MFFloat):
                self.__value.append(SFFloat(value).value) # checks validity
            elif (isinstance(value,list) and len(value) > 0) or isinstance(value,MFFloat):
                for each in value:
                    self.__value.append(SFFloat(each).value) # checks validity
            elif isinstance(value,str):
                self.__value.append(SFFloat(value).value) # checks validity
    ###     if  not value is None:
    ###         if isValidSFFloat(value):
    ###             if isinstance(value, SFFloat):
    ###                 value = SFFloat(value).value # dereference value from base type
    ###             self.__value.append(value)
    ###         elif isValidMFFloat(value):
    ###             for each in value:
    ###                 while isinstance(each, list) and len(each) == 1:
    ###                     each = each[0] # dereference
    ###                 if isinstance(each, SFFloat):
    ###                     each = each.value # dereference
    ###                 self.__value.append(each)
    ###         else:
    ###             assertValidMFFloat(value) # report type failure
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, MFFloat self.__value type=' + str(type(self.__value)) + ' is not a list', flush=True)
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFImage(_X3DField):
    """
    Field type SFImage specifies a single uncompressed 2-dimensional pixel image. SFImage fields contain three integers representing the width, height and number of components in the image, followed by (width x height) hexadecimal or integer values representing the pixels in the image.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'SFImage'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFImageAndMFImage'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFImage'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [0, 0, 0]
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return False
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 1
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*([+]?(0|[1-9][0-9]*)([Ee][+]?[0-9]+)?\s+){2}[+]?[0-4](\s+(0x[0-9a-fA-F]{1,16}|[+]?(0|[1-9][0-9]*)([Ee][+]?[0-9]+)?))*\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*([+]?(0|[1-9][0-9]*)([Ee][+]?[0-9]+)?\s+){2}[+]?[0-4](\s+(0x[0-9a-fA-F]{1,16}|[+]?(0|[1-9][0-9]*)([Ee][+]?[0-9]+)?))*\s*'
    # - - - - - - - - - -
    def __init__(self, value=[0, 0, 0]):
        # print('*** SFImage __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFImage):
            value = value.value # dereference
        elif value is None:
            value = SFImage.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to SFImage.DEFAULT_VALUE()=' + str(SFImage.DEFAULT_VALUE()))
        elif isinstance(value, MFImage) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
        if isinstance(value, str):
            try:
                float(value) # this statement checks but does not set value, may throw exception
                print('*** string value provided, value=' + str(value) + ', float(value)=' + str(float(value)), flush=True)
                value = float(value)
            except ValueError as error:
                # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
                raise X3DTypeError('SFImage encountered string with illegal value=' + str(value)) from error
        self.__value = value
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, SFImage self.__value type=' + str(type(self.__value)) + ' is not a list')
        return len(self.__value) > 0

class MFImage(_X3DArrayField):
    """
    Field type MFImage is an array of SFImage values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'MFImage'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFImageAndMFImage'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFImage'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return True
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 1
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\[?\s*(([+]?(0|[1-9][0-9]*)([Ee][+]?[0-9]+)?\s+){2}[+]?[0-4](\s+(0x[0-9a-fA-F]{1,16}|[+]?(0|[1-9][0-9]*)([Ee][+]?[0-9]+)?))*\s*,?\s*)*\]?\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(([+]?(0|[1-9][0-9]*)([Ee][+]?[0-9]+)?\s+){2}[+]?[0-4](\s+(0x[0-9a-fA-F]{1,16}|[+]?(0|[1-9][0-9]*)([Ee][+]?[0-9]+)?))*\s*,?\s*)*'
    # - - - - - - - - - -
    def __init__(self, value=None):
        if value is None:
            value = self.DEFAULT_VALUE()
        # print('*** MFImage __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFImage):
            value = value.value # dereference
        elif value is None:
            value = MFImage.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to MFImage.DEFAULT_VALUE()=' + str(MFImage.DEFAULT_VALUE()))
    ###     elif not isinstance(value, list) and isValidSFImage(value):
    ###         print(' upcast to MF type', value)
    ###         value = MFImage(SFImage(value))
        elif isinstance(value, list):
            if not value is None and not (isinstance(value,list) and len(value) == 0):
                _newValue = []
                for each in value:
                    _newValue.append(SFImage(each).value)
                # if _DEBUG: print('...DEBUG... assign list, value=' + str(value), ', type=' + str(type(value)), ', _newValue=' + str(_newValue),flush=True)
                value = _newValue
        elif isinstance(value, str):
            value = [ int(value) ]
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            # if _DEBUG: print('...DEBUG... append to list, value=' + str(self.__value), ', type=' + str(type(self.__value)), ', value=' + str(value),flush=True)
            if isinstance(value,SFImage):
                self.__value.append(value.value) # dereference
            elif not isinstance(value,list) and not isinstance(value,MFImage):
                self.__value.append(SFImage(value).value) # checks validity
            elif (isinstance(value,list) and len(value) > 0) or isinstance(value,MFImage):
                for each in value:
                    self.__value.append(SFImage(each).value) # checks validity
            elif isinstance(value,str):
                self.__value.append(SFImage(value).value) # checks validity
    ###     if  not value is None:
    ###         if isValidSFImage(value):
    ###             if isinstance(value, SFImage):
    ###                 value = SFImage(value).value # dereference value from base type
    ###             self.__value.append(value)
    ###         elif isValidMFImage(value):
    ###             for each in value:
    ###                 while isinstance(each, list) and len(each) == 1:
    ###                     each = each[0] # dereference
    ###                 if isinstance(each, SFImage):
    ###                     each = each.value # dereference
    ###                 self.__value.append(each)
    ###         else:
    ###             assertValidMFImage(value) # report type failure
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, MFImage self.__value type=' + str(type(self.__value)) + ' is not a list', flush=True)
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFInt32(_X3DField):
    """
    Field type SFInt32 specifies one 32-bit signed integer.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'SFInt32'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFInt32AndMFInt32'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFInt32'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return 0
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return False
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 1
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*[+-]?(0|[1-9][0-9]*)([Ee][+-]?[0-9]+)?\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*[+-]?(0|[1-9][0-9]*)([Ee][+-]?[0-9]+)?\s*'
    # - - - - - - - - - -
    def __init__(self, value=0):
        # print('*** SFInt32 __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        if isinstance(value,str):
            value = int(value)
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFInt32):
            value = value.value # dereference
        elif value is None:
            value = SFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to SFInt32.DEFAULT_VALUE()=' + str(SFInt32.DEFAULT_VALUE()))
        elif isinstance(value, MFInt32) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
        if isinstance(value, str):
            try:
                int(value) # this statement checks but does not set value, may throw exception
                print('*** string value provided, value=' + str(value) + ', int(value)=' + str(int(value)), flush=True)
                value = int(value)
            except ValueError as error:
                # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
                raise X3DTypeError('SFInt32 encountered string with illegal value=' + str(value)) from error
        self.__value = value
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, SFInt32 self.__value type=' + str(type(self.__value)) + ' is not a list')
        return len(self.__value) > 0

class MFInt32(_X3DArrayField):
    """
    Field type MFInt32 defines an array of 32-bit signed integers. Array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'MFInt32'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFInt32AndMFInt32'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFInt32'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return True
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 1
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\[?\s*([+-]?(0|[1-9][0-9]*)([Ee][+-]?[0-9]+)?\s*,?\s*)*\]?\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*([+-]?(0|[1-9][0-9]*)([Ee][+-]?[0-9]+)?\s*,?\s*)*'
    # - - - - - - - - - -
    def __init__(self, value=None):
        if value is None:
            value = self.DEFAULT_VALUE()
        # print('*** MFInt32 __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFInt32):
            value = value.value # dereference
        elif value is None:
            value = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to MFInt32.DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
    ###     elif not isinstance(value, list) and isValidSFInt32(value):
    ###         print(' upcast to MF type', value)
    ###         value = MFInt32(SFInt32(value))
        elif isinstance(value, list):
            if not value is None and not (isinstance(value,list) and len(value) == 0):
                _newValue = []
                for each in value:
                    _newValue.append(SFInt32(each).value)
                # if _DEBUG: print('...DEBUG... assign list, value=' + str(value), ', type=' + str(type(value)), ', _newValue=' + str(_newValue),flush=True)
                value = _newValue
        elif isinstance(value, str):
            value = [ int(value) ]
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            # if _DEBUG: print('...DEBUG... append to list, value=' + str(self.__value), ', type=' + str(type(self.__value)), ', value=' + str(value),flush=True)
            if isinstance(value,SFInt32):
                self.__value.append(value.value) # dereference
            elif not isinstance(value,list) and not isinstance(value,MFInt32):
                self.__value.append(SFInt32(value).value) # checks validity
            elif (isinstance(value,list) and len(value) > 0) or isinstance(value,MFInt32):
                for each in value:
                    self.__value.append(SFInt32(each).value) # checks validity
            elif isinstance(value,str):
                self.__value.append(SFInt32(value).value) # checks validity
    ###     if  not value is None:
    ###         if isValidSFInt32(value):
    ###             if isinstance(value, SFInt32):
    ###                 value = SFInt32(value).value # dereference value from base type
    ###             self.__value.append(value)
    ###         elif isValidMFInt32(value):
    ###             for each in value:
    ###                 while isinstance(each, list) and len(each) == 1:
    ###                     each = each[0] # dereference
    ###                 if isinstance(each, SFInt32):
    ###                     each = each.value # dereference
    ###                 self.__value.append(each)
    ###         else:
    ###             assertValidMFInt32(value) # report type failure
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, MFInt32 self.__value type=' + str(type(self.__value)) + ' is not a list', flush=True)
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFMatrix3d(_X3DField):
    """
    Field type SFMatrix3d specifies a 3x3 matrix of double-precision floating point numbers, organized in row-major fashion. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'SFMatrix3d'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFMatrix3dAndMFMatrix3d'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFMatrix3d'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return (1, 0, 0, 0, 1, 0, 0, 0, 1)
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return False
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 9
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){8}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){8}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*'
    # - - - - - - - - - -
    def __init__(self, value=(1, 0, 0, 0, 1, 0, 0, 0, 1)):
        # print('*** SFMatrix3d __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFMatrix3d):
            value = value.value # dereference
        elif value is None:
            value = SFMatrix3d.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to SFMatrix3d.DEFAULT_VALUE()=' + str(SFMatrix3d.DEFAULT_VALUE()))
        elif isinstance(value, MFMatrix3d) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
        if isinstance(value, str):
            try:
                float(value) # this statement checks but does not set value, may throw exception
                print('*** string value provided, value=' + str(value) + ', float(value)=' + str(float(value)), flush=True)
                value = float(value)
            except ValueError as error:
                # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
                raise X3DTypeError('SFMatrix3d encountered string with illegal value=' + str(value)) from error
        self.__value = value
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, SFMatrix3d self.__value type=' + str(type(self.__value)) + ' is not a list')
        return len(self.__value) > 0

class MFMatrix3d(_X3DArrayField):
    """
    Field type MFMatrix3d specifies zero or more 3x3 matrices of double-precision floating point numbers, organized in row-major fashion. Warning: comma characters can only appear between singleton 9-tuple values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'MFMatrix3d'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFMatrix3dAndMFMatrix3d'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFMatrix3d'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return True
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 9
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\[?\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){8}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*\]?\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){8}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*'
    # - - - - - - - - - -
    def __init__(self, value=None):
        if value is None:
            value = self.DEFAULT_VALUE()
        # print('*** MFMatrix3d __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFMatrix3d):
            value = value.value # dereference
        elif value is None:
            value = MFMatrix3d.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to MFMatrix3d.DEFAULT_VALUE()=' + str(MFMatrix3d.DEFAULT_VALUE()))
    ###     elif not isinstance(value, list) and isValidSFMatrix3d(value):
    ###         print(' upcast to MF type', value)
    ###         value = MFMatrix3d(SFMatrix3d(value))
        elif isinstance(value, list):
            if not value is None and not (isinstance(value,list) and len(value) == 0):
                _newValue = []
                for each in value:
                    _newValue.append(SFMatrix3d(each).value)
                # if _DEBUG: print('...DEBUG... assign list, value=' + str(value), ', type=' + str(type(value)), ', _newValue=' + str(_newValue),flush=True)
                value = _newValue
        elif isinstance(value, str):
            value = [ float(value) ]
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            # if _DEBUG: print('...DEBUG... append to list, value=' + str(self.__value), ', type=' + str(type(self.__value)), ', value=' + str(value),flush=True)
            if isinstance(value,SFMatrix3d):
                self.__value.append(value.value) # dereference
            elif not isinstance(value,list) and not isinstance(value,MFMatrix3d):
                self.__value.append(SFMatrix3d(value).value) # checks validity
            elif (isinstance(value,list) and len(value) > 0) or isinstance(value,MFMatrix3d):
                for each in value:
                    self.__value.append(SFMatrix3d(each).value) # checks validity
            elif isinstance(value,str):
                self.__value.append(SFMatrix3d(value).value) # checks validity
    ###     if  not value is None:
    ###         if isValidSFMatrix3d(value):
    ###             if isinstance(value, SFMatrix3d):
    ###                 value = SFMatrix3d(value).value # dereference value from base type
    ###             self.__value.append(value)
    ###         elif isValidMFMatrix3d(value):
    ###             for each in value:
    ###                 while isinstance(each, list) and len(each) == 1:
    ###                     each = each[0] # dereference
    ###                 if isinstance(each, SFMatrix3d):
    ###                     each = each.value # dereference
    ###                 self.__value.append(each)
    ###         else:
    ###             assertValidMFMatrix3d(value) # report type failure
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, MFMatrix3d self.__value type=' + str(type(self.__value)) + ' is not a list', flush=True)
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFMatrix3f(_X3DField):
    """
    Field type SFMatrix3f specifies a 3x3 matrix of single-precision floating point numbers, organized in row-major fashion. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'SFMatrix3f'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFMatrix3fAndMFMatrix3f'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFMatrix3f'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return (1, 0, 0, 0, 1, 0, 0, 0, 1)
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return False
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 9
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){8}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){8}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*'
    # - - - - - - - - - -
    def __init__(self, value=(1, 0, 0, 0, 1, 0, 0, 0, 1)):
        # print('*** SFMatrix3f __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFMatrix3f):
            value = value.value # dereference
        elif value is None:
            value = SFMatrix3f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to SFMatrix3f.DEFAULT_VALUE()=' + str(SFMatrix3f.DEFAULT_VALUE()))
        elif isinstance(value, MFMatrix3f) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
        if isinstance(value, str):
            try:
                float(value) # this statement checks but does not set value, may throw exception
                print('*** string value provided, value=' + str(value) + ', float(value)=' + str(float(value)), flush=True)
                value = float(value)
            except ValueError as error:
                # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
                raise X3DTypeError('SFMatrix3f encountered string with illegal value=' + str(value)) from error
        self.__value = value
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, SFMatrix3f self.__value type=' + str(type(self.__value)) + ' is not a list')
        return len(self.__value) > 0

class MFMatrix3f(_X3DArrayField):
    """
    Field type MFMatrix3f specifies zero or more 3x3 matrices of single-precision floating point numbers, organized in row-major fashion. Warning: comma characters can only appear between singleton 9-tuple values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'MFMatrix3f'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFMatrix3fAndMFMatrix3f'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFMatrix3f'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return True
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 9
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\[?\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){8}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*\]?\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){8}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*'
    # - - - - - - - - - -
    def __init__(self, value=None):
        if value is None:
            value = self.DEFAULT_VALUE()
        # print('*** MFMatrix3f __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFMatrix3f):
            value = value.value # dereference
        elif value is None:
            value = MFMatrix3f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to MFMatrix3f.DEFAULT_VALUE()=' + str(MFMatrix3f.DEFAULT_VALUE()))
    ###     elif not isinstance(value, list) and isValidSFMatrix3f(value):
    ###         print(' upcast to MF type', value)
    ###         value = MFMatrix3f(SFMatrix3f(value))
        elif isinstance(value, list):
            if not value is None and not (isinstance(value,list) and len(value) == 0):
                _newValue = []
                for each in value:
                    _newValue.append(SFMatrix3f(each).value)
                # if _DEBUG: print('...DEBUG... assign list, value=' + str(value), ', type=' + str(type(value)), ', _newValue=' + str(_newValue),flush=True)
                value = _newValue
        elif isinstance(value, str):
            value = [ float(value) ]
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            # if _DEBUG: print('...DEBUG... append to list, value=' + str(self.__value), ', type=' + str(type(self.__value)), ', value=' + str(value),flush=True)
            if isinstance(value,SFMatrix3f):
                self.__value.append(value.value) # dereference
            elif not isinstance(value,list) and not isinstance(value,MFMatrix3f):
                self.__value.append(SFMatrix3f(value).value) # checks validity
            elif (isinstance(value,list) and len(value) > 0) or isinstance(value,MFMatrix3f):
                for each in value:
                    self.__value.append(SFMatrix3f(each).value) # checks validity
            elif isinstance(value,str):
                self.__value.append(SFMatrix3f(value).value) # checks validity
    ###     if  not value is None:
    ###         if isValidSFMatrix3f(value):
    ###             if isinstance(value, SFMatrix3f):
    ###                 value = SFMatrix3f(value).value # dereference value from base type
    ###             self.__value.append(value)
    ###         elif isValidMFMatrix3f(value):
    ###             for each in value:
    ###                 while isinstance(each, list) and len(each) == 1:
    ###                     each = each[0] # dereference
    ###                 if isinstance(each, SFMatrix3f):
    ###                     each = each.value # dereference
    ###                 self.__value.append(each)
    ###         else:
    ###             assertValidMFMatrix3f(value) # report type failure
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, MFMatrix3f self.__value type=' + str(type(self.__value)) + ' is not a list', flush=True)
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFMatrix4d(_X3DField):
    """
    Field type SFMatrix4d specifies a 4x4 matrix of double-precision floating point numbers, organized in row-major fashion. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'SFMatrix4d'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFMatrix4dAndMFMatrix4d'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFMatrix4d'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return (1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return False
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 16
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){15}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){15}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*'
    # - - - - - - - - - -
    def __init__(self, value=(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)):
        # print('*** SFMatrix4d __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFMatrix4d):
            value = value.value # dereference
        elif value is None:
            value = SFMatrix4d.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to SFMatrix4d.DEFAULT_VALUE()=' + str(SFMatrix4d.DEFAULT_VALUE()))
        elif isinstance(value, MFMatrix4d) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
        if isinstance(value, str):
            try:
                float(value) # this statement checks but does not set value, may throw exception
                print('*** string value provided, value=' + str(value) + ', float(value)=' + str(float(value)), flush=True)
                value = float(value)
            except ValueError as error:
                # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
                raise X3DTypeError('SFMatrix4d encountered string with illegal value=' + str(value)) from error
        self.__value = value
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, SFMatrix4d self.__value type=' + str(type(self.__value)) + ' is not a list')
        return len(self.__value) > 0

class MFMatrix4d(_X3DArrayField):
    """
    Field type MFMatrix4d specifies zero or more 4x4 matrices of double-precision floating point numbers, organized in row-major fashion. Warning: comma characters can only appear between singleton 16-tuple values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'MFMatrix4d'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFMatrix4dAndMFMatrix4d'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFMatrix4d'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return True
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 16
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\[?\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){15}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*\]?\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){15}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*'
    # - - - - - - - - - -
    def __init__(self, value=None):
        if value is None:
            value = self.DEFAULT_VALUE()
        # print('*** MFMatrix4d __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFMatrix4d):
            value = value.value # dereference
        elif value is None:
            value = MFMatrix4d.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to MFMatrix4d.DEFAULT_VALUE()=' + str(MFMatrix4d.DEFAULT_VALUE()))
    ###     elif not isinstance(value, list) and isValidSFMatrix4d(value):
    ###         print(' upcast to MF type', value)
    ###         value = MFMatrix4d(SFMatrix4d(value))
        elif isinstance(value, list):
            if not value is None and not (isinstance(value,list) and len(value) == 0):
                _newValue = []
                for each in value:
                    _newValue.append(SFMatrix4d(each).value)
                # if _DEBUG: print('...DEBUG... assign list, value=' + str(value), ', type=' + str(type(value)), ', _newValue=' + str(_newValue),flush=True)
                value = _newValue
        elif isinstance(value, str):
            value = [ float(value) ]
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            # if _DEBUG: print('...DEBUG... append to list, value=' + str(self.__value), ', type=' + str(type(self.__value)), ', value=' + str(value),flush=True)
            if isinstance(value,SFMatrix4d):
                self.__value.append(value.value) # dereference
            elif not isinstance(value,list) and not isinstance(value,MFMatrix4d):
                self.__value.append(SFMatrix4d(value).value) # checks validity
            elif (isinstance(value,list) and len(value) > 0) or isinstance(value,MFMatrix4d):
                for each in value:
                    self.__value.append(SFMatrix4d(each).value) # checks validity
            elif isinstance(value,str):
                self.__value.append(SFMatrix4d(value).value) # checks validity
    ###     if  not value is None:
    ###         if isValidSFMatrix4d(value):
    ###             if isinstance(value, SFMatrix4d):
    ###                 value = SFMatrix4d(value).value # dereference value from base type
    ###             self.__value.append(value)
    ###         elif isValidMFMatrix4d(value):
    ###             for each in value:
    ###                 while isinstance(each, list) and len(each) == 1:
    ###                     each = each[0] # dereference
    ###                 if isinstance(each, SFMatrix4d):
    ###                     each = each.value # dereference
    ###                 self.__value.append(each)
    ###         else:
    ###             assertValidMFMatrix4d(value) # report type failure
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, MFMatrix4d self.__value type=' + str(type(self.__value)) + ' is not a list', flush=True)
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFMatrix4f(_X3DField):
    """
    Field type SFMatrix4f specifies a 4x4 matrix of single-precision floating point numbers, organized in row-major fashion. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'SFMatrix4f'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFMatrix4fAndMFMatrix4f'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFMatrix4f'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return (1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return False
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 16
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){15}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){15}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*'
    # - - - - - - - - - -
    def __init__(self, value=(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)):
        # print('*** SFMatrix4f __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFMatrix4f):
            value = value.value # dereference
        elif value is None:
            value = SFMatrix4f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to SFMatrix4f.DEFAULT_VALUE()=' + str(SFMatrix4f.DEFAULT_VALUE()))
        elif isinstance(value, MFMatrix4f) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
        if isinstance(value, str):
            try:
                float(value) # this statement checks but does not set value, may throw exception
                print('*** string value provided, value=' + str(value) + ', float(value)=' + str(float(value)), flush=True)
                value = float(value)
            except ValueError as error:
                # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
                raise X3DTypeError('SFMatrix4f encountered string with illegal value=' + str(value)) from error
        self.__value = value
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, SFMatrix4f self.__value type=' + str(type(self.__value)) + ' is not a list')
        return len(self.__value) > 0

class MFMatrix4f(_X3DArrayField):
    """
    Field type MFMatrix4f specifies zero or more 4x4 matrices of single-precision floating point numbers, organized in row-major fashion. Warning: comma characters can only appear between singleton 16-tuple values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'MFMatrix4f'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFMatrix4fAndMFMatrix4f'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFMatrix4f'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return True
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 16
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\[?\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){15}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*\]?\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){15}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*'
    # - - - - - - - - - -
    def __init__(self, value=None):
        if value is None:
            value = self.DEFAULT_VALUE()
        # print('*** MFMatrix4f __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFMatrix4f):
            value = value.value # dereference
        elif value is None:
            value = MFMatrix4f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to MFMatrix4f.DEFAULT_VALUE()=' + str(MFMatrix4f.DEFAULT_VALUE()))
    ###     elif not isinstance(value, list) and isValidSFMatrix4f(value):
    ###         print(' upcast to MF type', value)
    ###         value = MFMatrix4f(SFMatrix4f(value))
        elif isinstance(value, list):
            if not value is None and not (isinstance(value,list) and len(value) == 0):
                _newValue = []
                for each in value:
                    _newValue.append(SFMatrix4f(each).value)
                # if _DEBUG: print('...DEBUG... assign list, value=' + str(value), ', type=' + str(type(value)), ', _newValue=' + str(_newValue),flush=True)
                value = _newValue
        elif isinstance(value, str):
            value = [ float(value) ]
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            # if _DEBUG: print('...DEBUG... append to list, value=' + str(self.__value), ', type=' + str(type(self.__value)), ', value=' + str(value),flush=True)
            if isinstance(value,SFMatrix4f):
                self.__value.append(value.value) # dereference
            elif not isinstance(value,list) and not isinstance(value,MFMatrix4f):
                self.__value.append(SFMatrix4f(value).value) # checks validity
            elif (isinstance(value,list) and len(value) > 0) or isinstance(value,MFMatrix4f):
                for each in value:
                    self.__value.append(SFMatrix4f(each).value) # checks validity
            elif isinstance(value,str):
                self.__value.append(SFMatrix4f(value).value) # checks validity
    ###     if  not value is None:
    ###         if isValidSFMatrix4f(value):
    ###             if isinstance(value, SFMatrix4f):
    ###                 value = SFMatrix4f(value).value # dereference value from base type
    ###             self.__value.append(value)
    ###         elif isValidMFMatrix4f(value):
    ###             for each in value:
    ###                 while isinstance(each, list) and len(each) == 1:
    ###                     each = each[0] # dereference
    ###                 if isinstance(each, SFMatrix4f):
    ###                     each = each.value # dereference
    ###                 self.__value.append(each)
    ###         else:
    ###             assertValidMFMatrix4f(value) # report type failure
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, MFMatrix4f self.__value type=' + str(type(self.__value)) + ' is not a list', flush=True)
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFNode(_X3DField):
    """
    Field type SFNode specifies an X3D node; the default empty value of an uninitialized SFNode field is sometimes described as NULL.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'SFNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFNodeAndMFNode'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFNode'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return None
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [('value', 'None', FieldType.SFNode, AccessType.inputOutput, 'SFNode')]
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return False
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 1
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r''
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r''
    # - - - - - - - - - -
    def __init__(self, value=None):
        # print('*** SFNode __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFNode):
            value = value.value # dereference
        elif value is None:
            value = SFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to SFNode.DEFAULT_VALUE()=' + str(SFNode.DEFAULT_VALUE()))
        elif isinstance(value, MFNode) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        self.__value = value
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, SFNode self.__value type=' + str(type(self.__value)) + ' is not a list')
        return len(self.__value) > 0

class MFNode(_X3DArrayField):
    """
    Field type MFNode specifies zero or more nodes; the default value of an MFNode field is the empty list.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'MFNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFNodeAndMFNode'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFNode'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [('value', None, FieldType.MFNode, AccessType.inputOutput, 'MFNode')]
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return True
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 1
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r''
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r''
    # - - - - - - - - - -
    def __init__(self, value=None):
        if value is None:
            value = self.DEFAULT_VALUE()
        # print('*** MFNode __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFNode):
            value = value.value # dereference
        elif value is None:
            value = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to MFNode.DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
    ###     elif not isinstance(value, list) and isValidSFNode(value):
    ###         print(' upcast to MF type', value)
    ###         value = MFNode(SFNode(value))
        elif isinstance(value, list):
            if not value is None and not (isinstance(value,list) and len(value) == 0):
                _newValue = []
                for each in value:
                    _newValue.append(SFNode(each).value)
                # if _DEBUG: print('...DEBUG... assign list, value=' + str(value), ', type=' + str(type(value)), ', _newValue=' + str(_newValue),flush=True)
                value = _newValue
        elif isinstance(value, str):
            value = [ list(value) ]
        self.__value = value
    def __repl__(self):
        result = '['
        if self.__value: # walk each child in list, if any (avoid empty list recursion)
            for each in self.__value:
                result += str(each) + ', '
        return result.rstrip(', ') + ']'
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            # if _DEBUG: print('...DEBUG... append to list, value=' + str(self.__value), ', type=' + str(type(self.__value)), ', value=' + str(value),flush=True)
            if isinstance(value,SFNode):
                self.__value.append(value.value) # dereference
            elif not isinstance(value,list) and not isinstance(value,MFNode):
                self.__value.append(SFNode(value).value) # checks validity
            elif (isinstance(value,list) and len(value) > 0) or isinstance(value,MFNode):
                for each in value:
                    self.__value.append(SFNode(each).value) # checks validity
            elif isinstance(value,str):
                self.__value.append(SFNode(value).value) # checks validity
    ###     if  not value is None:
    ###         if isValidSFNode(value):
    ###             if isinstance(value, SFNode):
    ###                 value = SFNode(value).value # dereference value from base type
    ###             self.__value.append(value)
    ###         elif isValidMFNode(value):
    ###             for each in value:
    ###                 while isinstance(each, list) and len(each) == 1:
    ###                     each = each[0] # dereference
    ###                 if isinstance(each, SFNode):
    ###                     each = each.value # dereference
    ###                 self.__value.append(each)
    ###         else:
    ###             assertValidMFNode(value) # report type failure
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, MFNode self.__value type=' + str(type(self.__value)) + ' is not a list', flush=True)
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFRotation(_X3DField):
    """
    Field type SFRotation is an axis-angle 4-tuple, indicating X-Y-Z direction axis plus angle orientation about that axis. The first three values specify a normalized axis vector about which the rotation takes place, so the first three values shall be within the range [-1..+1] in order to represent a normalized unit vector. The fourth value specifies the amount of right-handed rotation about that axis in radians. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'SFRotation'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFRotationAndMFRotation'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFRotation'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return (0, 0, 1, 0)
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return False
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 4
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\(\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\)\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*'
    # - - - - - - - - - -
    def __init__(self, value=None,value2=None,value3=None,value4=None):
        # print('*** SFRotation __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        if isinstance(value,str):
            value = float(value)
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value,value2=None,value3=None,value4=None):
        """ The value setter only allows correctly typed and sized values. """
        if value2 is not None and value3 is not None and value4 is not None:
            value = (float(value),float(value2),float(value3),float(value4))
        if isinstance(value,SFRotation):
            value = value.value # dereference
        elif value is None:
            value = SFRotation.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to SFRotation.DEFAULT_VALUE()=' + str(SFRotation.DEFAULT_VALUE()))
        elif isinstance(value, list):
            for each in value: # check that contained elements are not tuples or lists
                if isinstance(each, tuple):
                    break
            if len(value) == 4:
                value = (value[0],value[1],value[2],value[3])
            else: # no tuples found, create 4-tuples
                value = [(x, y, z, w) for x, y, z, w in value]
        elif isinstance(value, MFRotation) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
        if isinstance(value, str):
            try:
                float(value) # this statement checks but does not set value, may throw exception
                print('*** string value provided, value=' + str(value) + ', float(value)=' + str(float(value)), flush=True)
                value = float(value)
            except ValueError as error:
                # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
                raise X3DTypeError('SFRotation encountered string with illegal value=' + str(value)) from error
        self.__value = value
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, SFRotation self.__value type=' + str(type(self.__value)) + ' is not a list')
        return len(self.__value) > 0

class MFRotation(_X3DArrayField):
    """
    Field type MFRotation is an array of SFRotation values. Individual singleton SFRotation array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'MFRotation'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFRotationAndMFRotation'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFRotation'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return True
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 4
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\[?\s*(\s*\(?\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*\)?\s*\,?)*\s*\]?\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*'
    # - - - - - - - - - -
    def __init__(self, value=None,value2=None,value3=None,value4=None):
        if value is None:
            value = self.DEFAULT_VALUE()
        # print('*** MFRotation __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        if value2 is not None and value3 is not None and value4 is not None:
            value = (float(value),float(value2),float(value3),float(value4))
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value,value2=None,value3=None,value4=None):
        """ The value setter only allows correctly typed and sized values. """
        if value2 is not None and value3 is not None and value4 is not None:
            value = (float(value),float(value2),float(value3),float(value4))
        if isinstance(value,SFRotation):
            value = value.value # dereference
        elif value is None:
            value = MFRotation.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to MFRotation.DEFAULT_VALUE()=' + str(MFRotation.DEFAULT_VALUE()))
        elif isinstance(value, list):
            for each in value: # check that contained elements are not tuples or lists
                if isinstance(each, tuple):
                    break
            if len(value) == 4:
                value = (value[0],value[1],value[2],value[3])
            else: # no tuples found, create 4-tuples
                value = [(x, y, z, w) for x, y, z, w in value]
    ###     elif not isinstance(value, list) and isValidSFRotation(value):
    ###         print(' upcast to MF type', value)
    ###         value = MFRotation(SFRotation(value))
        elif isinstance(value, list):
            if not value is None and not (isinstance(value,list) and len(value) == 0):
                _newValue = []
                for each in value:
                    _newValue.append(SFRotation(each).value)
                # if _DEBUG: print('...DEBUG... assign list, value=' + str(value), ', type=' + str(type(value)), ', _newValue=' + str(_newValue),flush=True)
                value = _newValue
        elif isinstance(value, str):
            value = [ float(value) ]
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            # if _DEBUG: print('...DEBUG... append to list, value=' + str(self.__value), ', type=' + str(type(self.__value)), ', value=' + str(value),flush=True)
            if isinstance(value,SFRotation):
                self.__value.append(value.value) # dereference
            elif not isinstance(value,list) and not isinstance(value,MFRotation):
                self.__value.append(SFRotation(value).value) # checks validity
            elif (isinstance(value,list) and len(value) > 0) or isinstance(value,MFRotation):
                for each in value:
                    self.__value.append(SFRotation(each).value) # checks validity
            elif isinstance(value,str):
                self.__value.append(SFRotation(value).value) # checks validity
    ###     if  not value is None:
    ###         if isValidSFRotation(value):
    ###             if isinstance(value, SFRotation):
    ###                 value = SFRotation(value).value # dereference value from base type
    ###             self.__value.append(value)
    ###         elif isValidMFRotation(value):
    ###             for each in value:
    ###                 while isinstance(each, list) and len(each) == 1:
    ###                     each = each[0] # dereference
    ###                 if isinstance(each, SFRotation):
    ###                     each = each.value # dereference
    ###                 self.__value.append(each)
    ###         else:
    ###             assertValidMFRotation(value) # report type failure
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, MFRotation self.__value type=' + str(type(self.__value)) + ' is not a list', flush=True)
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFString(_X3DField):
    """
    Field type SFString defines a single string encoded with the UTF-8 universal character set.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'SFString'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFStringAndMFString'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFString'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return ''
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return False
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 1
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'(\s|\S)*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'(\s|\S)*'
    # - - - - - - - - - -
    def __init__(self, value=''):
        # print('*** SFString __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFString):
            value = value.value # dereference
        elif value is None:
            value = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to SFString.DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        elif isinstance(value, MFString) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        self.__value = value
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, SFString self.__value type=' + str(type(self.__value)) + ' is not a list')
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).replace("'","&apos;").replace("& ","&amp; ").replace("<","&lt;").replace(">","&gt;")

class MFString(_X3DArrayField):
    """
    Field type MFString is an array of SFString values, each "quoted" and separated by whitespace. Individual SFString array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'MFString'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFStringAndMFString'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFString'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return True
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 1
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\[?(\s|\S)*\]?\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'(\s|\S)*'
    # - - - - - - - - - -
    def __init__(self, value=None):
        if value is None:
            value = self.DEFAULT_VALUE()
        # print('*** MFString __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFString):
            value = value.value # dereference
        elif value is None:
            value = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to MFString.DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
    ###     elif not isinstance(value, list) and isValidSFString(value):
    ###         print(' upcast to MF type', value)
    ###         value = MFString(SFString(value))
        elif isinstance(value, list):
            if not value is None and not (isinstance(value,list) and len(value) == 0):
                _newValue = []
                for each in value:
                    _newValue.append(SFString(each).value)
                # if _DEBUG: print('...DEBUG... assign list, value=' + str(value), ', type=' + str(type(value)), ', _newValue=' + str(_newValue),flush=True)
                value = _newValue
        elif isinstance(value, str):
            value = [ str(value) ]
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            # if _DEBUG: print('...DEBUG... append to list, value=' + str(self.__value), ', type=' + str(type(self.__value)), ', value=' + str(value),flush=True)
            if isinstance(value,SFString):
                self.__value.append(value.value) # dereference
            elif not isinstance(value,list) and not isinstance(value,MFString):
                self.__value.append(SFString(value).value) # checks validity
            elif (isinstance(value,list) and len(value) > 0) or isinstance(value,MFString):
                for each in value:
                    self.__value.append(SFString(each).value) # checks validity
            elif isinstance(value,str):
                self.__value.append(SFString(value).value) # checks validity
    ###     if  not value is None:
    ###         if isValidSFString(value):
    ###             if isinstance(value, SFString):
    ###                 value = SFString(value).value # dereference value from base type
    ###             self.__value.append(value)
    ###         elif isValidMFString(value):
    ###             for each in value:
    ###                 while isinstance(each, list) and len(each) == 1:
    ###                     each = each[0] # dereference
    ###                 if isinstance(each, SFString):
    ###                     each = each.value # dereference
    ###                 self.__value.append(each)
    ###         else:
    ###             assertValidMFString(value) # report type failure
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, MFString self.__value type=' + str(type(self.__value)) + ' is not a list', flush=True)
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        result = ''
        if self.__value: # walk each child in list, if any (avoid empty list recursion)
            for each in self.__value:
                result += '"' + str(each).replace("'","&apos;").replace("& ","&amp; ").replace("<","&lt;").replace(">","&gt;") + '"' + ' '
        result = result.rstrip(' ')
        return result

class SFTime(_X3DField):
    """
    Field type SFTime specifies a single time value, expressed as a double-precision floating point number. Typically, SFTime fields represent the number of seconds since Jan 1, 1970, 00:00:00 GMT.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'SFTime'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFTimeAndMFTime'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFTime'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return -1.0
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return False
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 1
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*'
    # - - - - - - - - - -
    def __init__(self, value=-1.0):
        # print('*** SFTime __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFTime):
            value = value.value # dereference
        elif value is None:
            value = SFTime.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to SFTime.DEFAULT_VALUE()=' + str(SFTime.DEFAULT_VALUE()))
        elif isinstance(value, MFTime) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
        if isinstance(value, str):
            try:
                float(value) # this statement checks but does not set value, may throw exception
                print('*** string value provided, value=' + str(value) + ', float(value)=' + str(float(value)), flush=True)
                value = float(value)
            except ValueError as error:
                # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
                raise X3DTypeError('SFTime encountered string with illegal value=' + str(value)) from error
        self.__value = value
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, SFTime self.__value type=' + str(type(self.__value)) + ' is not a list')
        return len(self.__value) > 0

class MFTime(_X3DArrayField):
    """
    Field type MFTime is an array of SFTime values. Array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'MFTime'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFTimeAndMFTime'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFTime'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return True
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 1
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\[?\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*\]?\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*'
    # - - - - - - - - - -
    def __init__(self, value=None):
        if value is None:
            value = self.DEFAULT_VALUE()
        # print('*** MFTime __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed and sized values. """
        if isinstance(value,SFTime):
            value = value.value # dereference
        elif value is None:
            value = MFTime.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to MFTime.DEFAULT_VALUE()=' + str(MFTime.DEFAULT_VALUE()))
    ###     elif not isinstance(value, list) and isValidSFTime(value):
    ###         print(' upcast to MF type', value)
    ###         value = MFTime(SFTime(value))
        elif isinstance(value, list):
            if not value is None and not (isinstance(value,list) and len(value) == 0):
                _newValue = []
                for each in value:
                    _newValue.append(SFTime(each).value)
                # if _DEBUG: print('...DEBUG... assign list, value=' + str(value), ', type=' + str(type(value)), ', _newValue=' + str(_newValue),flush=True)
                value = _newValue
        elif isinstance(value, str):
            value = [ float(value) ]
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            # if _DEBUG: print('...DEBUG... append to list, value=' + str(self.__value), ', type=' + str(type(self.__value)), ', value=' + str(value),flush=True)
            if isinstance(value,SFTime):
                self.__value.append(value.value) # dereference
            elif not isinstance(value,list) and not isinstance(value,MFTime):
                self.__value.append(SFTime(value).value) # checks validity
            elif (isinstance(value,list) and len(value) > 0) or isinstance(value,MFTime):
                for each in value:
                    self.__value.append(SFTime(each).value) # checks validity
            elif isinstance(value,str):
                self.__value.append(SFTime(value).value) # checks validity
    ###     if  not value is None:
    ###         if isValidSFTime(value):
    ###             if isinstance(value, SFTime):
    ###                 value = SFTime(value).value # dereference value from base type
    ###             self.__value.append(value)
    ###         elif isValidMFTime(value):
    ###             for each in value:
    ###                 while isinstance(each, list) and len(each) == 1:
    ###                     each = each[0] # dereference
    ###                 if isinstance(each, SFTime):
    ###                     each = each.value # dereference
    ###                 self.__value.append(each)
    ###         else:
    ###             assertValidMFTime(value) # report type failure
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, MFTime self.__value type=' + str(type(self.__value)) + ' is not a list', flush=True)
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFVec2d(_X3DField):
    """
    Field type SFVec2d is a 2-tuple pair of SFDouble values. Hint: SFVec2d can be used to specify a 2D double-precision coordinate. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'SFVec2d'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFVec2dAndMFVec2d'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec2d'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return (0.0, 0.0)
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return False
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 2
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\(\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){1}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\)\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){1}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*'
    # - - - - - - - - - -
    def __init__(self, value=None,value2=None):
        # print('*** SFVec2d __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        if isinstance(value,str):
            value = float(value)
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value,value2=None):
        """ The value setter only allows correctly typed and sized values. """
        if value2 is not None:
            value = (float(value),float(value2))
        if isinstance(value,SFVec2d):
            value = value.value # dereference
        elif value is None:
            value = SFVec2d.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to SFVec2d.DEFAULT_VALUE()=' + str(SFVec2d.DEFAULT_VALUE()))
        elif isinstance(value, list):
            for each in value: # check that contained elements are not tuples or lists
                if isinstance(each, tuple):
                    break
            if len(value) == 2:
                value = (value[0],value[1])
            else: # no tuples found, create 2-tuples
                value = [(x, y) for x, y, in value]
        elif isinstance(value, MFVec2d) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
        if isinstance(value, str):
            try:
                float(value) # this statement checks but does not set value, may throw exception
                print('*** string value provided, value=' + str(value) + ', float(value)=' + str(float(value)), flush=True)
                value = float(value)
            except ValueError as error:
                # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
                raise X3DTypeError('SFVec2d encountered string with illegal value=' + str(value)) from error
        self.__value = value
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, SFVec2d self.__value type=' + str(type(self.__value)) + ' is not a list')
        return len(self.__value) > 0

class MFVec2d(_X3DArrayField):
    """
    Field type MFVec2d is an array of SFVec2d values. Individual singleton SFVec2d array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'MFVec2d'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFVec2dAndMFVec2d'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec2d'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return True
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 2
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\[?\s*(\s*\(?\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){1}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*\)?\s*\,?)*\s*\]?\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){1}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*'
    # - - - - - - - - - -
    def __init__(self, value=None,value2=None):
        if value is None:
            value = self.DEFAULT_VALUE()
        # print('*** MFVec2d __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        if value2 is not None:
            value = (float(value),float(value2))
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value,value2=None):
        """ The value setter only allows correctly typed and sized values. """
        if value2 is not None:
            value = (float(value),float(value2))
        if isinstance(value,SFVec2d):
            value = value.value # dereference
        elif value is None:
            value = MFVec2d.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to MFVec2d.DEFAULT_VALUE()=' + str(MFVec2d.DEFAULT_VALUE()))
        elif isinstance(value, list):
            for each in value: # check that contained elements are not tuples or lists
                if isinstance(each, tuple):
                    break
            if len(value) == 2:
                value = (value[0],value[1])
            else: # no tuples found, create 2-tuples
                value = [(x, y) for x, y, in value]
    ###     elif not isinstance(value, list) and isValidSFVec2d(value):
    ###         print(' upcast to MF type', value)
    ###         value = MFVec2d(SFVec2d(value))
        elif isinstance(value, list):
            if not value is None and not (isinstance(value,list) and len(value) == 0):
                _newValue = []
                for each in value:
                    _newValue.append(SFVec2d(each).value)
                # if _DEBUG: print('...DEBUG... assign list, value=' + str(value), ', type=' + str(type(value)), ', _newValue=' + str(_newValue),flush=True)
                value = _newValue
        elif isinstance(value, str):
            value = [ float(value) ]
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            # if _DEBUG: print('...DEBUG... append to list, value=' + str(self.__value), ', type=' + str(type(self.__value)), ', value=' + str(value),flush=True)
            if isinstance(value,SFVec2d):
                self.__value.append(value.value) # dereference
            elif not isinstance(value,list) and not isinstance(value,MFVec2d):
                self.__value.append(SFVec2d(value).value) # checks validity
            elif (isinstance(value,list) and len(value) > 0) or isinstance(value,MFVec2d):
                for each in value:
                    self.__value.append(SFVec2d(each).value) # checks validity
            elif isinstance(value,str):
                self.__value.append(SFVec2d(value).value) # checks validity
    ###     if  not value is None:
    ###         if isValidSFVec2d(value):
    ###             if isinstance(value, SFVec2d):
    ###                 value = SFVec2d(value).value # dereference value from base type
    ###             self.__value.append(value)
    ###         elif isValidMFVec2d(value):
    ###             for each in value:
    ###                 while isinstance(each, list) and len(each) == 1:
    ###                     each = each[0] # dereference
    ###                 if isinstance(each, SFVec2d):
    ###                     each = each.value # dereference
    ###                 self.__value.append(each)
    ###         else:
    ###             assertValidMFVec2d(value) # report type failure
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, MFVec2d self.__value type=' + str(type(self.__value)) + ' is not a list', flush=True)
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFVec2f(_X3DField):
    """
    Field type SFVec2f is a 2-tuple pair of SFFloat values. Hint: SFVec2f can be used to specify a 2D single-precision coordinate. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'SFVec2f'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFVec2fAndMFVec2f'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec2f'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return (0.0, 0.0)
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return False
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 2
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\(\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){1}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\)\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){1}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*'
    # - - - - - - - - - -
    def __init__(self, value=None,value2=None):
        # print('*** SFVec2f __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        if isinstance(value,str):
            value = float(value)
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value,value2=None):
        """ The value setter only allows correctly typed and sized values. """
        if value2 is not None:
            value = (float(value),float(value2))
        if isinstance(value,SFVec2f):
            value = value.value # dereference
        elif value is None:
            value = SFVec2f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to SFVec2f.DEFAULT_VALUE()=' + str(SFVec2f.DEFAULT_VALUE()))
        elif isinstance(value, list):
            for each in value: # check that contained elements are not tuples or lists
                if isinstance(each, tuple):
                    break
            if len(value) == 2:
                value = (value[0],value[1])
            else: # no tuples found, create 2-tuples
                value = [(x, y) for x, y, in value]
        elif isinstance(value, MFVec2f) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
        if isinstance(value, str):
            try:
                float(value) # this statement checks but does not set value, may throw exception
                print('*** string value provided, value=' + str(value) + ', float(value)=' + str(float(value)), flush=True)
                value = float(value)
            except ValueError as error:
                # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
                raise X3DTypeError('SFVec2f encountered string with illegal value=' + str(value)) from error
        self.__value = value
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, SFVec2f self.__value type=' + str(type(self.__value)) + ' is not a list')
        return len(self.__value) > 0

class MFVec2f(_X3DArrayField):
    """
    Field type MFVec2f is an array of SFVec2f values. Individual singleton SFVec2f array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'MFVec2f'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFVec2fAndMFVec2f'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec2f'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return True
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 2
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\[?\s*(\s*\(?\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){1}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*\)?\s*\,?)*\s*\]?\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){1}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*'
    # - - - - - - - - - -
    def __init__(self, value=None,value2=None):
        if value is None:
            value = self.DEFAULT_VALUE()
        # print('*** MFVec2f __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        if value2 is not None:
            value = (float(value),float(value2))
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value,value2=None):
        """ The value setter only allows correctly typed and sized values. """
        if value2 is not None:
            value = (float(value),float(value2))
        if isinstance(value,SFVec2f):
            value = value.value # dereference
        elif value is None:
            value = MFVec2f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to MFVec2f.DEFAULT_VALUE()=' + str(MFVec2f.DEFAULT_VALUE()))
        elif isinstance(value, list):
            for each in value: # check that contained elements are not tuples or lists
                if isinstance(each, tuple):
                    break
            if len(value) == 2:
                value = (value[0],value[1])
            else: # no tuples found, create 2-tuples
                value = [(x, y) for x, y, in value]
    ###     elif not isinstance(value, list) and isValidSFVec2f(value):
    ###         print(' upcast to MF type', value)
    ###         value = MFVec2f(SFVec2f(value))
        elif isinstance(value, list):
            if not value is None and not (isinstance(value,list) and len(value) == 0):
                _newValue = []
                for each in value:
                    _newValue.append(SFVec2f(each).value)
                # if _DEBUG: print('...DEBUG... assign list, value=' + str(value), ', type=' + str(type(value)), ', _newValue=' + str(_newValue),flush=True)
                value = _newValue
        elif isinstance(value, str):
            value = [ float(value) ]
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            # if _DEBUG: print('...DEBUG... append to list, value=' + str(self.__value), ', type=' + str(type(self.__value)), ', value=' + str(value),flush=True)
            if isinstance(value,SFVec2f):
                self.__value.append(value.value) # dereference
            elif not isinstance(value,list) and not isinstance(value,MFVec2f):
                self.__value.append(SFVec2f(value).value) # checks validity
            elif (isinstance(value,list) and len(value) > 0) or isinstance(value,MFVec2f):
                for each in value:
                    self.__value.append(SFVec2f(each).value) # checks validity
            elif isinstance(value,str):
                self.__value.append(SFVec2f(value).value) # checks validity
    ###     if  not value is None:
    ###         if isValidSFVec2f(value):
    ###             if isinstance(value, SFVec2f):
    ###                 value = SFVec2f(value).value # dereference value from base type
    ###             self.__value.append(value)
    ###         elif isValidMFVec2f(value):
    ###             for each in value:
    ###                 while isinstance(each, list) and len(each) == 1:
    ###                     each = each[0] # dereference
    ###                 if isinstance(each, SFVec2f):
    ###                     each = each.value # dereference
    ###                 self.__value.append(each)
    ###         else:
    ###             assertValidMFVec2f(value) # report type failure
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, MFVec2f self.__value type=' + str(type(self.__value)) + ' is not a list', flush=True)
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFVec3d(_X3DField):
    """
    Field type SFVec3d is a 3-tuple triplet of SFDouble values. See GeoVRML 1.0 Recommended Practice, Section 2.3, Limitations of Single Precision. Hint: SFVec3d can be used to specify a georeferenced 3D coordinate. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'SFVec3d'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFVec3dAndMFVec3d'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec3d'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return (0.0, 0.0, 0.0)
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return False
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 3
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\(\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){2}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\)\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){2}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*'
    # - - - - - - - - - -
    def __init__(self, value=None,value2=None,value3=None):
        # print('*** SFVec3d __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        if isinstance(value,str):
            value = float(value)
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value,value2=None,value3=None):
        """ The value setter only allows correctly typed and sized values. """
        if value2 is not None and value3 is not None:
            value = (float(value),float(value2),float(value3))
        if isinstance(value,SFVec3d):
            value = value.value # dereference
        elif value is None:
            value = SFVec3d.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to SFVec3d.DEFAULT_VALUE()=' + str(SFVec3d.DEFAULT_VALUE()))
        elif isinstance(value, list):
            for each in value: # check that contained elements are not tuples or lists
                if isinstance(each, tuple):
                    break
            if len(value) == 3:
                value = (value[0],value[1],value[2])
            else: # no tuples found, create 3-tuples
                value = [(x, y, z) for x, y, z in value]
        elif isinstance(value, MFVec3d) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
        if isinstance(value, str):
            try:
                float(value) # this statement checks but does not set value, may throw exception
                print('*** string value provided, value=' + str(value) + ', float(value)=' + str(float(value)), flush=True)
                value = float(value)
            except ValueError as error:
                # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
                raise X3DTypeError('SFVec3d encountered string with illegal value=' + str(value)) from error
        self.__value = value
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, SFVec3d self.__value type=' + str(type(self.__value)) + ' is not a list')
        return len(self.__value) > 0

class MFVec3d(_X3DArrayField):
    """
    Field type MFVec3d is an array of SFVec3d values. Individual singleton SFVec3d array values are optionally separated by commas in XML syntax. Original rationale for inclusion: GeoVRML 1.0 Recommended Practice, Section 2.3, Limitations of Single Precision. Hint: MFVec3d can be used to specify a list of georeferenced 3D coordinates.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'MFVec3d'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFVec3dAndMFVec3d'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec3d'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return True
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 3
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\[?\s*(\s*\(?\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){2}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*\)?\s*\,?)*\s*\]?\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){2}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*'
    # - - - - - - - - - -
    def __init__(self, value=None,value2=None,value3=None):
        if value is None:
            value = self.DEFAULT_VALUE()
        # print('*** MFVec3d __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        if value2 is not None and value3 is not None:
            value = (float(value),float(value2),float(value3))
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value,value2=None,value3=None):
        """ The value setter only allows correctly typed and sized values. """
        if value2 is not None and value3 is not None:
            value = (float(value),float(value2),float(value3))
        if isinstance(value,SFVec3d):
            value = value.value # dereference
        elif value is None:
            value = MFVec3d.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to MFVec3d.DEFAULT_VALUE()=' + str(MFVec3d.DEFAULT_VALUE()))
        elif isinstance(value, list):
            for each in value: # check that contained elements are not tuples or lists
                if isinstance(each, tuple):
                    break
            if len(value) == 3:
                value = (value[0],value[1],value[2])
            else: # no tuples found, create 3-tuples
                value = [(x, y, z) for x, y, z in value]
    ###     elif not isinstance(value, list) and isValidSFVec3d(value):
    ###         print(' upcast to MF type', value)
    ###         value = MFVec3d(SFVec3d(value))
        elif isinstance(value, list):
            if not value is None and not (isinstance(value,list) and len(value) == 0):
                _newValue = []
                for each in value:
                    _newValue.append(SFVec3d(each).value)
                # if _DEBUG: print('...DEBUG... assign list, value=' + str(value), ', type=' + str(type(value)), ', _newValue=' + str(_newValue),flush=True)
                value = _newValue
        elif isinstance(value, str):
            value = [ float(value) ]
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            # if _DEBUG: print('...DEBUG... append to list, value=' + str(self.__value), ', type=' + str(type(self.__value)), ', value=' + str(value),flush=True)
            if isinstance(value,SFVec3d):
                self.__value.append(value.value) # dereference
            elif not isinstance(value,list) and not isinstance(value,MFVec3d):
                self.__value.append(SFVec3d(value).value) # checks validity
            elif (isinstance(value,list) and len(value) > 0) or isinstance(value,MFVec3d):
                for each in value:
                    self.__value.append(SFVec3d(each).value) # checks validity
            elif isinstance(value,str):
                self.__value.append(SFVec3d(value).value) # checks validity
    ###     if  not value is None:
    ###         if isValidSFVec3d(value):
    ###             if isinstance(value, SFVec3d):
    ###                 value = SFVec3d(value).value # dereference value from base type
    ###             self.__value.append(value)
    ###         elif isValidMFVec3d(value):
    ###             for each in value:
    ###                 while isinstance(each, list) and len(each) == 1:
    ###                     each = each[0] # dereference
    ###                 if isinstance(each, SFVec3d):
    ###                     each = each.value # dereference
    ###                 self.__value.append(each)
    ###         else:
    ###             assertValidMFVec3d(value) # report type failure
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, MFVec3d self.__value type=' + str(type(self.__value)) + ' is not a list', flush=True)
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFVec3f(_X3DField):
    """
    Field type SFVec3f is a 3-tuple triplet of SFFloat values. Hint: SFVec3f can be used to specify a 3D coordinate or a 3D scale value. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'SFVec3f'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFVec3fAndMFVec3f'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec3f'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return (0.0, 0.0, 0.0)
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return False
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 3
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\(\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){2}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\)\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){2}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*'
    # - - - - - - - - - -
    def __init__(self, value=None,value2=None,value3=None):
        # print('*** SFVec3f __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        if isinstance(value,str):
            value = float(value)
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value,value2=None,value3=None):
        """ The value setter only allows correctly typed and sized values. """
        if value2 is not None and value3 is not None:
            value = (float(value),float(value2),float(value3))
        if isinstance(value,SFVec3f):
            value = value.value # dereference
        elif value is None:
            value = SFVec3f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to SFVec3f.DEFAULT_VALUE()=' + str(SFVec3f.DEFAULT_VALUE()))
        elif isinstance(value, list):
            for each in value: # check that contained elements are not tuples or lists
                if isinstance(each, tuple):
                    break
            if len(value) == 3:
                value = (value[0],value[1],value[2])
            else: # no tuples found, create 3-tuples
                value = [(x, y, z) for x, y, z in value]
        elif isinstance(value, MFVec3f) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
        if isinstance(value, str):
            try:
                float(value) # this statement checks but does not set value, may throw exception
                print('*** string value provided, value=' + str(value) + ', float(value)=' + str(float(value)), flush=True)
                value = float(value)
            except ValueError as error:
                # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
                raise X3DTypeError('SFVec3f encountered string with illegal value=' + str(value)) from error
        self.__value = value
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, SFVec3f self.__value type=' + str(type(self.__value)) + ' is not a list')
        return len(self.__value) > 0

class MFVec3f(_X3DArrayField):
    """
    Field type MFVec3f is an array of SFVec3f values. Individual singleton SFVec3f array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'MFVec3f'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFVec3fAndMFVec3f'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec3f'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return True
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 3
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\[?\s*(\s*\(?\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){2}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*\)?\s*\,?)*\s*\]?\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){2}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*'
    # - - - - - - - - - -
    def __init__(self, value=None,value2=None,value3=None):
        if value is None:
            value = self.DEFAULT_VALUE()
        # print('*** MFVec3f __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        if value2 is not None and value3 is not None:
            value = (float(value),float(value2),float(value3))
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value,value2=None,value3=None):
        """ The value setter only allows correctly typed and sized values. """
        if value2 is not None and value3 is not None:
            value = (float(value),float(value2),float(value3))
        if isinstance(value,SFVec3f):
            value = value.value # dereference
        elif value is None:
            value = MFVec3f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to MFVec3f.DEFAULT_VALUE()=' + str(MFVec3f.DEFAULT_VALUE()))
        elif isinstance(value, list):
            for each in value: # check that contained elements are not tuples or lists
                if isinstance(each, tuple):
                    break
            if len(value) == 3:
                value = (value[0],value[1],value[2])
            else: # no tuples found, create 3-tuples
                value = [(x, y, z) for x, y, z in value]
    ###     elif not isinstance(value, list) and isValidSFVec3f(value):
    ###         print(' upcast to MF type', value)
    ###         value = MFVec3f(SFVec3f(value))
        elif isinstance(value, list):
            if not value is None and not (isinstance(value,list) and len(value) == 0):
                _newValue = []
                for each in value:
                    _newValue.append(SFVec3f(each).value)
                # if _DEBUG: print('...DEBUG... assign list, value=' + str(value), ', type=' + str(type(value)), ', _newValue=' + str(_newValue),flush=True)
                value = _newValue
        elif isinstance(value, str):
            value = [ float(value) ]
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            # if _DEBUG: print('...DEBUG... append to list, value=' + str(self.__value), ', type=' + str(type(self.__value)), ', value=' + str(value),flush=True)
            if isinstance(value,SFVec3f):
                self.__value.append(value.value) # dereference
            elif not isinstance(value,list) and not isinstance(value,MFVec3f):
                self.__value.append(SFVec3f(value).value) # checks validity
            elif (isinstance(value,list) and len(value) > 0) or isinstance(value,MFVec3f):
                for each in value:
                    self.__value.append(SFVec3f(each).value) # checks validity
            elif isinstance(value,str):
                self.__value.append(SFVec3f(value).value) # checks validity
    ###     if  not value is None:
    ###         if isValidSFVec3f(value):
    ###             if isinstance(value, SFVec3f):
    ###                 value = SFVec3f(value).value # dereference value from base type
    ###             self.__value.append(value)
    ###         elif isValidMFVec3f(value):
    ###             for each in value:
    ###                 while isinstance(each, list) and len(each) == 1:
    ###                     each = each[0] # dereference
    ###                 if isinstance(each, SFVec3f):
    ###                     each = each.value # dereference
    ###                 self.__value.append(each)
    ###         else:
    ###             assertValidMFVec3f(value) # report type failure
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, MFVec3f self.__value type=' + str(type(self.__value)) + ' is not a list', flush=True)
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFVec4d(_X3DField):
    """
    Field type SFVec4d is a 4-tuple set of double-precision floating-point values, specifying a 3D homogeneous vector. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'SFVec4d'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFVec4dAndMFVec4d'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec4d'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return (0.0, 0.0, 0.0, 1.0)
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return False
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 4
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\(\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\)\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*'
    # - - - - - - - - - -
    def __init__(self, value=None,value2=None,value3=None,value4=None):
        # print('*** SFVec4d __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        if isinstance(value,str):
            value = float(value)
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value,value2=None,value3=None,value4=None):
        """ The value setter only allows correctly typed and sized values. """
        if value2 is not None and value3 is not None and value4 is not None:
            value = (float(value),float(value2),float(value3),float(value4))
        if isinstance(value,SFVec4d):
            value = value.value # dereference
        elif value is None:
            value = SFVec4d.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to SFVec4d.DEFAULT_VALUE()=' + str(SFVec4d.DEFAULT_VALUE()))
        elif isinstance(value, list):
            for each in value: # check that contained elements are not tuples or lists
                if isinstance(each, tuple):
                    break
            if len(value) == 4:
                value = (value[0],value[1],value[2],value[3])
            else: # no tuples found, create 4-tuples
                value = [(x, y, z, w) for x, y, z, w in value]
        elif isinstance(value, MFVec4d) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
        if isinstance(value, str):
            try:
                float(value) # this statement checks but does not set value, may throw exception
                print('*** string value provided, value=' + str(value) + ', float(value)=' + str(float(value)), flush=True)
                value = float(value)
            except ValueError as error:
                # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
                raise X3DTypeError('SFVec4d encountered string with illegal value=' + str(value)) from error
        self.__value = value
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, SFVec4d self.__value type=' + str(type(self.__value)) + ' is not a list')
        return len(self.__value) > 0

class MFVec4d(_X3DArrayField):
    """
    Field type MFVec4d is zero or more SFVec4d values. Individual singleton SFVec4d array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'MFVec4d'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFVec4dAndMFVec4d'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec4d'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return True
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 4
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\[?\s*(\s*\(?\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*\)?\s*\,?)*\s*\]?\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*'
    # - - - - - - - - - -
    def __init__(self, value=None,value2=None,value3=None,value4=None):
        if value is None:
            value = self.DEFAULT_VALUE()
        # print('*** MFVec4d __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        if value2 is not None and value3 is not None and value4 is not None:
            value = (float(value),float(value2),float(value3),float(value4))
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value,value2=None,value3=None,value4=None):
        """ The value setter only allows correctly typed and sized values. """
        if value2 is not None and value3 is not None and value4 is not None:
            value = (float(value),float(value2),float(value3),float(value4))
        if isinstance(value,SFVec4d):
            value = value.value # dereference
        elif value is None:
            value = MFVec4d.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to MFVec4d.DEFAULT_VALUE()=' + str(MFVec4d.DEFAULT_VALUE()))
        elif isinstance(value, list):
            for each in value: # check that contained elements are not tuples or lists
                if isinstance(each, tuple):
                    break
            if len(value) == 4:
                value = (value[0],value[1],value[2],value[3])
            else: # no tuples found, create 4-tuples
                value = [(x, y, z, w) for x, y, z, w in value]
    ###     elif not isinstance(value, list) and isValidSFVec4d(value):
    ###         print(' upcast to MF type', value)
    ###         value = MFVec4d(SFVec4d(value))
        elif isinstance(value, list):
            if not value is None and not (isinstance(value,list) and len(value) == 0):
                _newValue = []
                for each in value:
                    _newValue.append(SFVec4d(each).value)
                # if _DEBUG: print('...DEBUG... assign list, value=' + str(value), ', type=' + str(type(value)), ', _newValue=' + str(_newValue),flush=True)
                value = _newValue
        elif isinstance(value, str):
            value = [ float(value) ]
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            # if _DEBUG: print('...DEBUG... append to list, value=' + str(self.__value), ', type=' + str(type(self.__value)), ', value=' + str(value),flush=True)
            if isinstance(value,SFVec4d):
                self.__value.append(value.value) # dereference
            elif not isinstance(value,list) and not isinstance(value,MFVec4d):
                self.__value.append(SFVec4d(value).value) # checks validity
            elif (isinstance(value,list) and len(value) > 0) or isinstance(value,MFVec4d):
                for each in value:
                    self.__value.append(SFVec4d(each).value) # checks validity
            elif isinstance(value,str):
                self.__value.append(SFVec4d(value).value) # checks validity
    ###     if  not value is None:
    ###         if isValidSFVec4d(value):
    ###             if isinstance(value, SFVec4d):
    ###                 value = SFVec4d(value).value # dereference value from base type
    ###             self.__value.append(value)
    ###         elif isValidMFVec4d(value):
    ###             for each in value:
    ###                 while isinstance(each, list) and len(each) == 1:
    ###                     each = each[0] # dereference
    ###                 if isinstance(each, SFVec4d):
    ###                     each = each.value # dereference
    ###                 self.__value.append(each)
    ###         else:
    ###             assertValidMFVec4d(value) # report type failure
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, MFVec4d self.__value type=' + str(type(self.__value)) + ' is not a list', flush=True)
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFVec4f(_X3DField):
    """
    Field type SFVec4f is a 4-tuple set of single-precision floating-point values, specifying a 3D homogeneous vector. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'SFVec4f'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFVec4fAndMFVec4f'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec4f'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return (0.0, 0.0, 0.0, 1.0)
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return False
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 4
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\(\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\)\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*'
    # - - - - - - - - - -
    def __init__(self, value=None,value2=None,value3=None,value4=None):
        # print('*** SFVec4f __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        if isinstance(value,str):
            value = float(value)
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value,value2=None,value3=None,value4=None):
        """ The value setter only allows correctly typed and sized values. """
        if value2 is not None and value3 is not None and value4 is not None:
            value = (float(value),float(value2),float(value3),float(value4))
        if isinstance(value,SFVec4f):
            value = value.value # dereference
        elif value is None:
            value = SFVec4f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to SFVec4f.DEFAULT_VALUE()=' + str(SFVec4f.DEFAULT_VALUE()))
        elif isinstance(value, list):
            for each in value: # check that contained elements are not tuples or lists
                if isinstance(each, tuple):
                    break
            if len(value) == 4:
                value = (value[0],value[1],value[2],value[3])
            else: # no tuples found, create 4-tuples
                value = [(x, y, z, w) for x, y, z, w in value]
        elif isinstance(value, MFVec4f) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        # https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-is-a-number-float
        if isinstance(value, str):
            try:
                float(value) # this statement checks but does not set value, may throw exception
                print('*** string value provided, value=' + str(value) + ', float(value)=' + str(float(value)), flush=True)
                value = float(value)
            except ValueError as error:
                # https://stackoverflow.com/questions/66995878/consider-explicitly-re-raising-using-the-from-keyword-pylint-suggestion
                raise X3DTypeError('SFVec4f encountered string with illegal value=' + str(value)) from error
        self.__value = value
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, SFVec4f self.__value type=' + str(type(self.__value)) + ' is not a list')
        return len(self.__value) > 0

class MFVec4f(_X3DArrayField):
    """
    Field type MFVec4f is zero or more SFVec4f values. Individual singleton SFVec4f array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Field class. """
        return 'MFVec4f'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFVec4fAndMFVec4f'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec4f'
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value defined for this data type by the X3D Specification """
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    @classmethod
    def ARRAY_TYPE(cls):
        """ Whether or not this field class is array based. """
        return True
    @classmethod
    def TUPLE_SIZE(cls):
        """ How many values make up each data tuple. """
        return 4
    @classmethod
    def REGEX_PYTHON(cls):
        """ Regular expression for validating Python values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*\[?\s*(\s*\(?\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*\,?\s*){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*\)?\s*\,?)*\s*\]?\s*'
    @classmethod
    def REGEX_XML(cls):
        """ Regular expression for validating XML values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*'
    # - - - - - - - - - -
    def __init__(self, value=None,value2=None,value3=None,value4=None):
        if value is None:
            value = self.DEFAULT_VALUE()
        # print('*** MFVec4f __init__ value=' + str(value), 'type=' + str(type(value))) # debug
        if value2 is not None and value3 is not None and value4 is not None:
            value = (float(value),float(value2),float(value3),float(value4))
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value,value2=None,value3=None,value4=None):
        """ The value setter only allows correctly typed and sized values. """
        if value2 is not None and value3 is not None and value4 is not None:
            value = (float(value),float(value2),float(value3),float(value4))
        if isinstance(value,SFVec4f):
            value = value.value # dereference
        elif value is None:
            value = MFVec4f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to MFVec4f.DEFAULT_VALUE()=' + str(MFVec4f.DEFAULT_VALUE()))
        elif isinstance(value, list):
            for each in value: # check that contained elements are not tuples or lists
                if isinstance(each, tuple):
                    break
            if len(value) == 4:
                value = (value[0],value[1],value[2],value[3])
            else: # no tuples found, create 4-tuples
                value = [(x, y, z, w) for x, y, z, w in value]
    ###     elif not isinstance(value, list) and isValidSFVec4f(value):
    ###         print(' upcast to MF type', value)
    ###         value = MFVec4f(SFVec4f(value))
        elif isinstance(value, list):
            if not value is None and not (isinstance(value,list) and len(value) == 0):
                _newValue = []
                for each in value:
                    _newValue.append(SFVec4f(each).value)
                # if _DEBUG: print('...DEBUG... assign list, value=' + str(value), ', type=' + str(type(value)), ', _newValue=' + str(_newValue),flush=True)
                value = _newValue
        elif isinstance(value, str):
            value = [ float(value) ]
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            # if _DEBUG: print('...DEBUG... append to list, value=' + str(self.__value), ', type=' + str(type(self.__value)), ', value=' + str(value),flush=True)
            if isinstance(value,SFVec4f):
                self.__value.append(value.value) # dereference
            elif not isinstance(value,list) and not isinstance(value,MFVec4f):
                self.__value.append(SFVec4f(value).value) # checks validity
            elif (isinstance(value,list) and len(value) > 0) or isinstance(value,MFVec4f):
                for each in value:
                    self.__value.append(SFVec4f(each).value) # checks validity
            elif isinstance(value,str):
                self.__value.append(SFVec4f(value).value) # checks validity
    ###     if  not value is None:
    ###         if isValidSFVec4f(value):
    ###             if isinstance(value, SFVec4f):
    ###                 value = SFVec4f(value).value # dereference value from base type
    ###             self.__value.append(value)
    ###         elif isValidMFVec4f(value):
    ###             for each in value:
    ###                 while isinstance(each, list) and len(each) == 1:
    ###                     each = each[0] # dereference
    ###                 if isinstance(each, SFVec4f):
    ###                     each = each.value # dereference
    ###                 self.__value.append(each)
    ###         else:
    ###             assertValidMFVec4f(value) # report type failure
    def __bool__(self):
        if not isinstance(self.__value,list):
            print('*** x3d.py internal error, MFVec4f self.__value type=' + str(type(self.__value)) + ' is not a list', flush=True)
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class _X3DNode:
    """
    All instantiable nodes implement X3DNode, which corresponds to SFNode type in the X3D specification.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#X3DNode'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html'
    # Field declarations for this node are performed by implementing node
    def __init__(self, DEF="", USE="", class_="", id_="", style_="", IS=None, metadata=None):
        self.DEF = DEF
        self.USE = USE
        self.class_ = class_
        self.id_ = id_
        self.style_ = style_
        self.IS = IS
        self.metadata = metadata
        # if _DEBUG: print('...DEBUG... in X3DNode __init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
    @property # getter - - - - - - - - - -
    def DEF(self):
        """ Unique ID name for this node, referenceable by other X3D nodes. """
        return self.__DEF
    @DEF.setter
    def DEF(self, DEF):
        if  DEF is None:
            DEF = SFString.DEFAULT_VALUE()
        assertValidSFString(DEF)
        self.__DEF = str(DEF)
        if self.__DEF:
            self.__USE = None # DEF and USE are mutually exclusive
    @property # getter - - - - - - - - - -
    def USE(self):
        """ Reuse an already DEF-ed node ID, excluding all child nodes and all other attributes. """
        return self.__USE
    @USE.setter
    def USE(self, USE):
        if  USE is None:
            USE = SFString.DEFAULT_VALUE()
        assertValidSFString(USE)
        self.__USE = str(USE)
        if self.__USE:
            self.__DEF = None # DEF and USE are mutually exclusive
    @property # getter - - - - - - - - - -
    def class_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading stylesheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__class_
    @class_.setter
    def class_(self, class_):
        if  class_ is None:
            class_ = SFString.DEFAULT_VALUE()
        assertValidSFString(class_)
        self.__class_ = class_
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
        assertValidSFString(id_)
        self.__id = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
        assertValidSFString(style_)
        self.__style_ = style_
    @property # getter - - - - - - - - - -
    def IS(self):
        """ The IS statement connects node fields defined inside a ProtoBody declaration back to corresponding ProtoInterface fields. """
        return self.__IS
    @IS.setter
    def IS(self, IS):
        if  IS is None:
            self.__IS = SFNode.DEFAULT_VALUE()
        assertValidSFNode(IS)
        if not isinstance(IS, object) and not isinstance(IS, [ IS ] ): # TODO disambiguate IS naming
            # print(flush=True)
            raise X3DTypeError(str(IS) + ' IS.setter does not have a valid node type object, must be an IS node')
        self.__IS = IS
    @property # getter - - - - - - - - - -
    def metadata(self):
        """ The metadata field can contain a single MetadataBoolean, MetadataInteger, MetadataFloat, MetadataDouble, MetadataString or MetadataSet node. """
        return self.__metadata
    @metadata.setter
    def metadata(self, metadata):
        if  metadata is None:
            metadata = SFNode.DEFAULT_VALUE()
        assertValidSFNode(metadata)
        if not isinstance(metadata, object) and not isinstance(metadata, ( MetadataBoolean, MetadataInteger, MetadataFloat, MetadataDouble, MetadataString, MetadataSet, ProtoInstance ) ):
            # print(flush=True)
            raise X3DTypeError(str(metadata) + ' metadata.setter does not have a valid node type object, must be a Metadata* node or ProtoInstance')
        self.__metadata = metadata
    def __repl__(self):
        result = self.NAME() + '('
        # TODO put DEF first, matching canonical form
        if self.FIELD_DECLARATIONS():
            for each in self.FIELD_DECLARATIONS():
                # if _DEBUG: print(self.NAME() + ' for each in self.FIELD_DECLARATIONS(): each=' + str(each))
                name = each[0]
                default = each[1]
                type_ = each[2]
                accessType = each[3]
                value = getattr(self, name)
                # if _DEBUG: print('gettattr(self, ' + str(name) + ') value="' + str(value)[:100] + '" for FIELD_DECLARATIONS() ' + str(each) + ')', flush=True)
                if value != default:
                    # consider whether indentation is useful; probably not
                    # print("\n\t")
                    if  isinstance(value, list): # avoid X3DTypeError if value is not iterable
                        result += str(name) + '=['
                        for each in value:
                            # if _DEBUG: print('...DEBUG... X3DNode debug: str(each)=' + str(each), flush=True)
                            result += str(each) + ', '
                        result = result.rstrip(', ')
                        result += '],'
                    elif isinstance(value, str) and "'" in value:
                        result += str(name) + '=' + '"' + str(value)[:100] + '"' + ','
                    elif isinstance(value, str) and value != default:
                        result += str(name) + '=' + "'" + str(value)[:100] + "'" + ','
                    elif value != default:
                        result += str(name) + '='       + str(value)[:100]       + ','
                    # elif _DEBUG:
                    #   result += str(name) + '=' + "'" + str(value)[:100] + "'" + ','
        return result.strip().rstrip(',').rstrip(', ') + ')'
    def __str__(self):
        return self.__repl__().strip() # X3DNode

class _X3DChildNode(_X3DNode):
    """
    A node that implements X3DChildNode is one of the legal children for a X3DGroupingNode parent.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DChildNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#X3DChildNode'

class _X3DSoundNode(_X3DChildNode):
    """
    Base type for all sound nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DSoundNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#X3DSoundNode'

class _X3DSoundChannelNode(_X3DSoundNode):
    """
    Base type for all sound destination nodes, which represent the final destination of an audio signal and are what the user can ultimately hear.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DSoundChannelNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#X3DSoundChannelNode'

class _X3DTimeDependentNode(_X3DChildNode):
    """
    Base type from which all time-dependent nodes are derived.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DTimeDependentNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/time.html#X3DTimeDependentNode'

class _X3DGeometryNode(_X3DNode):
    """
    Geometry nodes produce renderable geometry and are contained by a Shape node.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DGeometryNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#X3DGeometryNode'

class _X3DParametricGeometryNode(_X3DGeometryNode):
    """
    Base type for all geometry node types that are created parametrically and use control points to describe the final shape of the surface.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DParametricGeometryNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#X3DParametricGeometryNode'

class _X3DAppearanceChildNode(_X3DNode):
    """
    Nodes of this type can be used as child nodes for Appearance.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DAppearanceChildNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#X3DAppearanceChildNode'

class _X3DTextureNode(_X3DAppearanceChildNode):
    """
    Base type for all nodes which specify sources for texture images.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DTextureNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#X3DTextureNode'

class _X3DSensorNode(_X3DChildNode):
    """
    Base type for all sensors.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DSensorNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#X3DSensorNode'

class _X3DPointingDeviceSensorNode(_X3DSensorNode):
    """
    Base type for all pointing device sensors.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DPointingDeviceSensorNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/pointingDeviceSensor.html#X3DPointingDeviceSensorNode'

class _X3DVolumeRenderStyleNode(_X3DNode):
    """
    The X3DVolumeRenderStyleNode abstract node type is the base type for all node types that specify a specific visual rendering style to be used when rendering volume data.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DVolumeRenderStyleNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#X3DVolumeRenderStyleNode'

class _X3DGeometricPropertyNode(_X3DNode):
    """
    Base type for all geometric property node types.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DGeometricPropertyNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#X3DGeometricPropertyNode'

class _X3DFollowerNode(_X3DChildNode):
    """
    X3DFollowerNode is the abstract base class for all nodes in the Followers component.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DFollowerNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#X3DFollowerNode'

class _X3DBindableNode(_X3DChildNode):
    """
    Bindable nodes implement the binding stack, so that only one of each node type is active at a given time.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DBindableNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#X3DBindableNode'

class _X3DAppearanceNode(_X3DNode):
    """
    Base type for all Appearance nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DAppearanceNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#X3DAppearanceNode'

class _X3DBackgroundNode(_X3DBindableNode):
    """
    Abstract type from which all backgrounds inherit, also defining a background binding stack.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DBackgroundNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalEffects.html#X3DBackgroundNode'

class _X3DChaserNode(_X3DFollowerNode):
    """
    The X3DChaserNode abstract node type calculates the output on value_changed as a finite impulse response (FIR) based on the events received on set_destination field.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DChaserNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#X3DChaserNode'

class _X3DColorNode(_X3DGeometricPropertyNode):
    """
    Base type for color specifications in X3D.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DColorNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#X3DColorNode'

class _X3DComposableVolumeRenderStyleNode(_X3DVolumeRenderStyleNode):
    """
    The X3DComposableVolumeRenderStyleNode abstract node type is the base type for all node types that allow rendering styles to be sequentially composed together to form a single renderable output.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DComposableVolumeRenderStyleNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#X3DComposableVolumeRenderStyleNode'

class _X3DComposedGeometryNode(_X3DGeometryNode):
    """
    Composed geometry nodes produce renderable geometry, can contain Color Coordinate Normal TextureCoordinate, and are contained by a Shape node.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DComposedGeometryNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#X3DComposedGeometryNode'

class _X3DCoordinateNode(_X3DGeometricPropertyNode):
    """
    Base type for all coordinate node types in X3D.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DCoordinateNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#X3DCoordinateNode'

class _X3DDamperNode(_X3DFollowerNode):
    """
    The X3DDamperNode abstract node type creates an IIR response that approaches the destination value according to the shape of the e-function only asymptotically but very quickly.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DDamperNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#X3DDamperNode'

class _X3DDragSensorNode(_X3DPointingDeviceSensorNode):
    """
    Base type for all drag-style pointing device sensors.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DDragSensorNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/pointingDeviceSensor.html#X3DDragSensorNode'

class _X3DEnvironmentalSensorNode(_X3DSensorNode):
    """
    Base type for the environmental sensor nodes ProximitySensor, TransformSensor and VisibilitySensor.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DEnvironmentalSensorNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalSensor.html#X3DEnvironmentalSensorNode'

class _X3DEnvironmentTextureNode(_X3DTextureNode):
    """
    Base type for all nodes that specify cubic environment map sources for texture images.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DEnvironmentTextureNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalTexturing.html#X3DEnvironmentTextureNode'

class _X3DFontStyleNode(_X3DNode):
    """
    Base type for all font style nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DFontStyleNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/text.html#X3DFontStyleNode'

class _X3DGroupingNode(_X3DChildNode):
    """
    Grouping nodes can contain other nodes as children, thus making up the backbone of a scene graph.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DGroupingNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/grouping.html#X3DGroupingNode'

class _X3DInfoNode(_X3DChildNode):
    """
    Base type for all nodes that contain only information without visual semantics.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DInfoNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/grouping.html#X3DInfoNode'

class _X3DInterpolatorNode(_X3DChildNode):
    """
    Interpolator nodes are designed for linear keyframed animation. Interpolators are driven by an input key ranging [0..1] and produce corresponding piecewise-linear output functions.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DInterpolatorNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#X3DInterpolatorNode'

class _X3DKeyDeviceSensorNode(_X3DSensorNode):
    """
    Base type for all sensor node types that operate using key devices.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DKeyDeviceSensorNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/keyDeviceSensor.html#X3DKeyDeviceSensorNode'

class _X3DLayerNode(_X3DNode):
    """
    The X3DLayerNode abstract node type is the base node type for layer nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DLayerNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/layering.html#X3DLayerNode'

class _X3DLayoutNode(_X3DChildNode):
    """
    X3DLayoutNode is the base node type for layout nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DLayoutNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/layout.html#X3DLayoutNode'

class _X3DLightNode(_X3DChildNode):
    """
    Light nodes provide illumination for rendering geometry in the scene. Implementing nodes must include a global field with type SFBool and accessType inputOutput.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DLightNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/lighting.html#X3DLightNode'

class _X3DMaterialNode(_X3DAppearanceChildNode):
    """
    Base type for all Material nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DMaterialNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#X3DMaterialNode'

class _X3DNBodyCollidableNode(_X3DChildNode):
    """
    The X3DNBodyCollidableNode abstract node type represents objects that act as the interface between the rigid body physics, collision geometry proxy, and renderable objects in the scene graph hierarchy.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DNBodyCollidableNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#X3DNBodyCollidableNode'

class _X3DNBodyCollisionSpaceNode(_X3DNode):
    """
    The X3DNBodyCollisionSpaceNode abstract node type represents objects that act as a self-contained spatial collection of objects that can interact through collision detection routines.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DNBodyCollisionSpaceNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#X3DNBodyCollisionSpaceNode'

class _X3DNetworkSensorNode(_X3DSensorNode):
    """
    Base typefor all sensors that generate events based on network activity.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DNetworkSensorNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/networking.html#X3DNetworkSensorNode'

class _X3DNormalNode(_X3DGeometricPropertyNode):
    """
    Base type for all normal node types in X3D.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DNormalNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#X3DNormalNode'

class _X3DNurbsControlCurveNode(_X3DNode):
    """
    Base type for all nodes that provide control curve information in 2D space.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DNurbsControlCurveNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#X3DNurbsControlCurveNode'

class _X3DNurbsSurfaceGeometryNode(_X3DParametricGeometryNode):
    """
    Abstract geometry type for all types of NURBS surfaces.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DNurbsSurfaceGeometryNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#X3DNurbsSurfaceGeometryNode'

class _X3DOneSidedMaterialNode(_X3DMaterialNode):
    """
    Base type for material nodes that describe how the shape looks like from one side. A different number of contanied texture nodes are allowed by each of the implementing nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DOneSidedMaterialNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#X3DOneSidedMaterialNode'

class _X3DParticleEmitterNode(_X3DNode):
    """
    The X3DParticleEmitterNode abstract type represents any node that is an emitter of particles.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DParticleEmitterNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#X3DParticleEmitterNode'

class _X3DParticlePhysicsModelNode(_X3DNode):
    """
    The X3DParticlePhysicsModelNode abstract type represents any node that applies a form of constraints on the particles after they have been generated.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DParticlePhysicsModelNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#X3DParticlePhysicsModelNode'

class _X3DPickSensorNode(_X3DSensorNode):
    """
    The X3DPickSensorNode abstract node type is the base node type that represents the lowest common denominator of picking capabilities.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DPickSensorNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/picking.html#X3DPickSensorNode'

class _X3DProductStructureChildNode(_X3DChildNode):
    """
    Base type marking nodes that are valid product structure children for the CADGeometry component.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DProductStructureChildNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/CADGeometry.html#X3DProductStructureChildNode'

class _X3DPrototypeInstance(_X3DNode):
    """
    Base type for all prototype instances. Note that direct children nodes are disallowed, instead let fieldValue with type SFNode/MFNode contain them. Current practice is that, if desired, prototype authors must explicitly add the metadata SFNode field in the ProtoInterface.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DPrototypeInstance'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#X3DPrototypeInstance'

class _X3DRigidJointNode(_X3DNode):
    """
    The X3DRigidJointNode abstract node type is the base type for all joint types.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DRigidJointNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#X3DRigidJointNode'

class _X3DScriptNode(_X3DChildNode):
    """
    Base type for scripting nodes (but not shader nodes).
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DScriptNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/scripting.html#X3DScriptNode'

class _X3DSequencerNode(_X3DChildNode):
    """
    Base type from which all Sequencers are derived.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DSequencerNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/eventUtilities.html#X3DSequencerNode'

class _X3DShaderNode(_X3DAppearanceChildNode):
    """
    Base type for all nodes that specify a programmable shader.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DShaderNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shaders.html#X3DShaderNode'

class _X3DShapeNode(_X3DChildNode):
    """
    Base type for all Shape nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DShapeNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#X3DShapeNode'

class _X3DSoundDestinationNode(_X3DSoundNode):
    """
    Base type for all sound destination nodes, which represent the final destination of an audio signal and are what the user can ultimately hear.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DSoundDestinationNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#X3DSoundDestinationNode'

class _X3DSoundProcessingNode(_X3DTimeDependentNode):
    """
    Base type for all sound processing nodes, which are used to enhance audio with filtering, delaying, changing gain, etc.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DSoundProcessingNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#X3DSoundProcessingNode'

class _X3DSoundSourceNode(_X3DTimeDependentNode):
    """
    Nodes implementing X3DSoundSourceNode provide signal inputs to the audio graph.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DSoundSourceNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#X3DSoundSourceNode'

class _X3DTexture3DNode(_X3DTextureNode):
    """
    Base type for all nodes that specify 3D sources for texture images.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DTexture3DNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texture3D.html#X3DTexture3DNode'

class _X3DTextureProjectorNode(_X3DLightNode):
    """
    Base type for all node types that specify texture projector nodes, which provide a form of lighting.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DTextureProjectorNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/textureProjector.html#X3DTextureProjectorNode'

class _X3DTouchSensorNode(_X3DPointingDeviceSensorNode):
    """
    Base type for all touch-style pointing device sensors.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DTouchSensorNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/pointingDeviceSensor.html#X3DTouchSensorNode'

class _X3DTriggerNode(_X3DChildNode):
    """
    Base type from which all trigger nodes are derived.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DTriggerNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/eventUtilities.html#X3DTriggerNode'

class _X3DVertexAttributeNode(_X3DGeometricPropertyNode):
    """
    Base type for all nodes that specify per-vertex attribute information to the shader.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DVertexAttributeNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shaders.html#X3DVertexAttributeNode'

class _X3DViewpointNode(_X3DBindableNode):
    """
    Node type X3DViewpointNode defines a specific location in the local coordinate system from which the user may view the scene, and also defines a viewpoint binding stack.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DViewpointNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/navigation.html#X3DViewpointNode'

class _X3DViewportNode(_X3DGroupingNode):
    """
    The X3DViewportNode abstract node type is the base node type for viewport nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DViewportNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/layering.html#X3DViewportNode'

class _X3DVolumeDataNode(_X3DChildNode):
    """
    The X3DVolumeDataNode abstract node type is the base type for all node types that describe volumetric data to be rendered.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DVolumeDataNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#X3DVolumeDataNode'

class _X3DTextureTransformNode(_X3DAppearanceChildNode):
    """
    Base type for all nodes which specify a transformation of texture coordinates.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DTextureTransformNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#X3DTextureTransformNode'

class _X3DSingleTextureTransformNode(_X3DTextureTransformNode):
    """
    Base type for all texture transform nodes which specify texture coordinate transformation for a single texture.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DSingleTextureTransformNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#X3DSingleTextureTransformNode'

class _X3DTextureCoordinateNode(_X3DGeometricPropertyNode):
    """
    Base type for all nodes which specify texture coordinates.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DTextureCoordinateNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#X3DTextureCoordinateNode'

class _X3DSingleTextureCoordinateNode(_X3DTextureCoordinateNode):
    """
    Base type for all texture coordinate nodes which specify texture coordinates for a single texture.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DSingleTextureCoordinateNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#X3DSingleTextureCoordinateNode'

class _X3DSingleTextureNode(_X3DTextureNode):
    """
    Base type for all texture node types that define a single texture. A single texture can be used to influence a parameter of various material nodes in the Shape component, and it can be a child of MultiTexture.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DSingleTextureNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#X3DSingleTextureNode'

class _X3DTexture2DNode(_X3DSingleTextureNode):
    """
    Base type for all nodes which specify 2D sources for texture images.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DTexture2DNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#X3DTexture2DNode'

###############################################

# Abstract Object Types

# Note that these package-internal class names are preceded by an underscore _ character since X3D authors are not expected to use them

class _X3DBoundedObject(_X3DNode):
    """
    X3DBoundedObject indicates that bounding box values can be provided (or computed) to encompass this node and any children.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DBoundedObject'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/grouping.html#X3DBoundedObject'

class _X3DFogObject(_X3DNode):
    """
    Abstract type describing a node that influences the lighting equation through the use of fog semantics.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DFogObject'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalEffects.html#X3DFogOjbect'

class _X3DMetadataObject(_X3DNode):
    """
    Each node inheriting the X3DMetadataObject interface contains a single array of strictly typed values: MFBool, MFInt32, MFFloat, MFDouble, MFString, or MFNode, the latter having children that are all Metadata nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DMetadataObject'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#X3DMetadataObject'

class _X3DPickableObject(_X3DNode):
    """
    The X3DPickableObject abstract interface marks a node as being capable of having customized picking performed on its contents or children.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DPickableObject'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/picking.html#X3DPickableObject'

class _X3DProgrammableShaderObject(_X3DNode):
    """
    Base type for all nodes that specify arbitrary fields for interfacing with per-object attribute values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DProgrammableShaderObject'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shaders.html#X3DProgrammableShaderObject'

class _X3DUrlObject(_X3DNode):
    """
    X3DUrlObject indicates that a node has content loaded from a Uniform Resource Locator (URL) and can be tracked via a LoadSensor. Such child nodes have containerField='children' to indicate their relationship to the parent LoadSensor node.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DUrlObject'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/networking.html#X3DUrlObject'

###############################################

# Statements

class _X3DStatement:
    """
    All X3D statements implement _X3DStatement abstract type.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Statement class. """
        return '_X3DStatement'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return []
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#AbstractX3DStructure'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html'
    def __init__(self, class_="", id_="", style_=""):
        self.class_ = class_
        self.id_ = id_
        self.style_ = style_
        # if _DEBUG: print('...DEBUG... in X3DNode __init__(' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + ')', flush=True)
    @property # getter - - - - - - - - - -
    def class_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading stylesheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__class_
    @class_.setter
    def class_(self, class_):
        if  class_ is None:
            class_ = SFString.DEFAULT_VALUE()
        assertValidSFString(class_)
        self.__class_ = class_
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
        assertValidSFString(style_)
        self.__style_ = style_
    def __repl__(self):
        result = self.NAME() + '('
        # if _DEBUG: print(self.NAME() + ' self.FIELD_DECLARATIONS(): ' + str(self.FIELD_DECLARATIONS))
        if self.FIELD_DECLARATIONS():
            for each in self.FIELD_DECLARATIONS():
                # if _DEBUG: print(self.NAME() + ' for each in self.FIELD_DECLARATIONS(): each=' + str(each))
                name = each[0]
                default = each[1]
                type_ = each[2]
                accessType = each[3]
                value = getattr(self, name)
                # if _DEBUG: print('gettattr(self, ' + str(name) + ') value="' + str(value)[:100] + '" for FIELD_DECLARATIONS() ' + str(each) + ')', flush=True)
                if value != default:
                    if  isinstance(value, list): # avoid X3DTypeError if value is not iterable
                        result += str(name) + '=['
                        for each in value:
                            result += str(each) + ', '
                            # if _DEBUG: print('...DEBUG... _X3DStatement debug: str(each)=' + str(each), flush=True)
                        result = result.rstrip(', ')
                        result += '],'
                    elif isinstance(value, str) and "'" in value:
                        result += str(name) + '=' + '"' + str(value)[:100] + '"' + ','
                    elif isinstance(value, str) and value != default:
                        result += str(name) + '=' + "'" + str(value)[:100] + "'" + ','
                    elif value != default:
                        result += str(name) + '='       + str(value)[:100]       + ','
                    # elif _DEBUG:
        #   result += str(name) + '=' + "'" + str(value)[:100] + "'" + ','
        return result.strip().rstrip(',').rstrip(', ') + ')'
    def __str__(self):
        return self.__repl__().strip() # _X3DStatement

def isX3DStatement(value):
    """
    Whether or not value is an _X3DStatement object.
    """
    return isinstance(value, _X3DStatement)

class Comment(_X3DStatement):
    """
    X3D statement containing zero or more comment strings.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Statement class. """
        return 'Comment'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#Organization'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html'
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def DEFAULT_VALUE(cls):
        """ Default value for comments is empty string """
        return ''
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return []
    @classmethod
    def REGEX_PYTHON(cls):
        """' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'(\s|\S)*' # (includes lower-case true, false)
    @classmethod
    def REGEX_XML(cls):
        """' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html """
        return r'(\s|\S)*' # (includes lower-case true, false)
    def __init__(self, value=''):
        super().__init__()
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide list of comment strings. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = SFString.DEFAULT_VALUE()
        self.__value = str(value)
    # output function - - - - - - - - - -

class component(_X3DStatement):
    """
    Functional summary: each added component statement indicates needed scene functionality support above the given X3D profile.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'component'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/concepts.html#Components'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#component'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('level', 1, FieldType.SFInt32, AccessType.inputOutput, 'component'),
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'component'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement')]
    def __init__(self,
        level=1,
        name='',
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in Statement component __init__ calling super.__init__(' + str(class_) + ',' + str(id_) + ',' + str(style_) +  + ')', flush=True)
        super().__init__(class_, id_, style_) # fields for _X3DStatement only
        self.level = level
        self.name = name
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def level(self):
        """Necessary level of support for this scene, as defined in corresponding Support table for a given node's component."""
        return self.__level
    @level.setter
    def level(self, level):
        if  level is None:
            level = 1  # default
        assertValidSFInt32(level)
        assertGreaterThanEquals('level', level, 1)
        assertLessThanEquals('level', level, 5)
        self.__level = level
    @property # getter - - - - - - - - - -
    def name(self):
        """Provides name of this component, as defined in corresponding X3D Specification component Introduction."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        assertValidComponentName('name', name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return False
    # output function - - - - - - - - - -

class connect(_X3DStatement):
    """
    Functional summary: connect statements define event-routing connections between node fields defined inside a ProtoBody declaration back to corresponding ProtoInterface fields.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'connect'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#IS_ConnectStatementSyntax'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#connect'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('nodeField', '', FieldType.SFString, AccessType.inputOutput, 'connect'),
        ('protoField', '', FieldType.SFString, AccessType.inputOutput, 'connect'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement')]
    def __init__(self,
        nodeField='',
        protoField='',
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in Statement connect __init__ calling super.__init__(' + str(class_) + ',' + str(id_) + ',' + str(style_) +  + ')', flush=True)
        super().__init__(class_, id_, style_) # fields for _X3DStatement only
        self.nodeField = nodeField
        self.protoField = protoField
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def nodeField(self):
        """Name of field within this node which IS CONNECTed to the ancestor ProtoDeclare field definition."""
        return self.__nodeField
    @nodeField.setter
    def nodeField(self, nodeField):
        if  nodeField is None:
            nodeField = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(nodeField)
        self.__nodeField = nodeField
    @property # getter - - - - - - - - - -
    def protoField(self):
        """Name of parent ProtoDeclare field definition connecting to field in this node."""
        return self.__protoField
    @protoField.setter
    def protoField(self, protoField):
        if  protoField is None:
            protoField = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(protoField)
        self.__protoField = protoField
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return False
    # output function - - - - - - - - - -

class EXPORT(_X3DStatement):
    """
    Functional summary: EXPORT exposes a local node for ROUTE passing of event values when the current Scene is included via Inline by a parent external world. These connections allow event values to be exchanged via ROUTE statements between a parent model and a child Inline model.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'EXPORT'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/concepts.html#ImportExportsemantics'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#EXPORT'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('AS', '', FieldType.SFString, AccessType.inputOutput, 'EXPORT'),
        ('localDEF', '', FieldType.SFString, AccessType.inputOutput, 'EXPORT'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement')]
    def __init__(self,
        AS='',
        localDEF='',
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in Statement EXPORT __init__ calling super.__init__(' + str(class_) + ',' + str(id_) + ',' + str(style_) +  + ')', flush=True)
        super().__init__(class_, id_, style_) # fields for _X3DStatement only
        self.AS = AS
        self.localDEF = localDEF
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def AS(self):
        """rename localDEF node AS a different name when exporting."""
        return self.__AS
    @AS.setter
    def AS(self, AS):
        if  AS is None:
            AS = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(AS)
        self.__AS = AS
    @property # getter - - - - - - - - - -
    def localDEF(self):
        """localDEF is the DEF name of the local node to be EXPORTed."""
        return self.__localDEF
    @localDEF.setter
    def localDEF(self, localDEF):
        if  localDEF is None:
            localDEF = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(localDEF)
        self.__localDEF = localDEF
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return False
    # output function - - - - - - - - - -

class ExternProtoDeclare(_X3DStatement):
    """
    ExternProtoDeclare refers to a ProtoDeclare node declaration provided in another file. ExternProtoDeclare interfaces are defined by field statements (and without IS/connect statements).
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ExternProtoDeclare'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/concepts.html#Externalprototypesemantics'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ExternProtoDeclare'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('appinfo', '', FieldType.SFString, AccessType.inputOutput, 'ExternProtoDeclare'),
        ('documentation', '', FieldType.SFString, AccessType.inputOutput, 'ExternProtoDeclare'),
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'ExternProtoDeclare'),
        ('url', [], FieldType.MFString, AccessType.inputOutput, 'ExternProtoDeclare'),
        ('field', [], FieldType.MFNode, AccessType.inputOutput, 'ExternProtoDeclare'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement')]
    def __init__(self,
        appinfo='',
        documentation='',
        name='',
        url=None,
        field=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in Statement ExternProtoDeclare __init__ calling super.__init__(' + str(class_) + ',' + str(id_) + ',' + str(style_) +  + ')', flush=True)
        super().__init__(class_, id_, style_) # fields for _X3DStatement only
        self.appinfo = appinfo
        self.documentation = documentation
        self.name = name
        self.url = url
        self.field = field
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def appinfo(self):
        """Application information to provide simple description usable as a tooltip, similar to XML Schema appinfo tag."""
        return self.__appinfo
    @appinfo.setter
    def appinfo(self, appinfo):
        if  appinfo is None:
            appinfo = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(appinfo)
        self.__appinfo = appinfo
    @property # getter - - - - - - - - - -
    def documentation(self):
        """Documentation url for further information, similar to XML Schema documentation tag."""
        return self.__documentation
    @documentation.setter
    def documentation(self, documentation):
        if  documentation is None:
            documentation = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(documentation)
        self.__documentation = documentation
    @property # getter - - - - - - - - - -
    def name(self):
        """name of the ExternProtoDeclare (External Prototype Declaration) being referenced."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def url(self):
        """Location and filename of ProtoDeclare source declaration of interest."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def field(self):
        """Include a field statement for each field declaration in the corresponding original ProtoDeclare."""
        return self.__field
    @field.setter
    def field(self, field):
        if  field is None:
            field = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        # TODO type-aware checks for field
        if field: # walk each child in list, if any (avoid empty list recursion)
            for each in field:
                assertValidFieldInitializationValue(each.name, type(each.value), each.value, parent='ExternProtoDeclare/field')
        self.__field = field
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return (len(self.field) > 0)
    # output function - - - - - - - - - -

class field(_X3DStatement):
    """
    Functional summary: a field statement defines an interface attribute or node. Each field statement can contain either attribute-value or node content.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'field'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#NodeAndFieldStatementSyntax'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#field'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('accessType', '', FieldType.SFString, AccessType.inputOutput, 'field'),
        ('appinfo', '', FieldType.SFString, AccessType.inputOutput, 'field'),
        ('documentation', '', FieldType.SFString, AccessType.inputOutput, 'field'),
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'field'),
        ('type', '', FieldType.SFString, AccessType.inputOutput, 'field'),
        ('value', '', FieldType.SFString, AccessType.inputOutput, 'field'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'field'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement')]
    def __init__(self,
        accessType='',
        appinfo='',
        documentation='',
        name='',
        type='',
        value='',
        children=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in Statement field __init__ calling super.__init__(' + str(class_) + ',' + str(id_) + ',' + str(style_) +  + ')', flush=True)
        super().__init__(class_, id_, style_) # fields for _X3DStatement only
        self.accessType = accessType
        self.appinfo = appinfo
        self.documentation = documentation
        self.name = name
        self.type = type
        self.value = value
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def accessType(self):
        """Event-model semantics for field set/get capabilities."""
        return self.__accessType
    @accessType.setter
    def accessType(self, accessType):
        if  accessType is None:
            accessType = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(accessType)
        assertValidAccessType('accessType', accessType)
        self.__accessType = accessType
    @property # getter - - - - - - - - - -
    def appinfo(self):
        """Application information to provide simple description usable as a tooltip, similar to XML Schema appinfo tag."""
        return self.__appinfo
    @appinfo.setter
    def appinfo(self, appinfo):
        if  appinfo is None:
            appinfo = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(appinfo)
        self.__appinfo = appinfo
    @property # getter - - - - - - - - - -
    def documentation(self):
        """Documentation url for further information, similar to XML Schema documentation tag."""
        return self.__documentation
    @documentation.setter
    def documentation(self, documentation):
        if  documentation is None:
            documentation = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(documentation)
        self.__documentation = documentation
    @property # getter - - - - - - - - - -
    def name(self):
        """Name of this field declaration."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def type(self):
        """Base type of this field variable."""
        return self.__type
    @type.setter
    def type(self, type):
        if  type is None:
            type = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(type)
        assertValidFieldType('type', type)
        self.__type = type
    @property # getter - - - - - - - - - -
    def value(self):
        """Provide default initialization value for this field variable (which may be re-initialized later by instantiation value of a named ProtoInstance fieldValue)."""
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidFieldInitializationValue(self.name, self.type, value, parent='field/@value')
        self.__value = value
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DNode] If this field definition has type SFNode or MFNode, then initialization node (or nodes) of any appropriate type may be provided as children of the field definition."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return (len(self.children) > 0)
    # output function - - - - - - - - - -

class fieldValue(_X3DStatement):
    """
    Functional summary: a fieldValue statement re-initializes the default value of a field in a ProtoInstance. Each fieldValue statement can contain either attribute-value or node content.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'fieldValue'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#ProtoInstanceAndFieldValueStatement'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#fieldValue'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'fieldValue'),
        ('value', '', FieldType.SFString, AccessType.inputOutput, 'fieldValue'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'fieldValue'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement')]
    def __init__(self,
        name='',
        value='',
        children=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in Statement fieldValue __init__ calling super.__init__(' + str(class_) + ',' + str(id_) + ',' + str(style_) +  + ')', flush=True)
        super().__init__(class_, id_, style_) # fields for _X3DStatement only
        self.name = name
        self.value = value
        self.children = children
        self.id_ = id_
        self.style_ = style_
        self.type='SFString' # convenience property matching corresponding field declaration
    @property # getter - - - - - - - - - -
    # convenience property matching corresponding field declaration
    def type(self):
        """ Computed type of this fieldValue corresponding to corresponding field declaration. """
        if self.__type is None:
            self.__type = 'SFString'
        #print('*** need to find fieldValue type, using type=' + str(self.__type))
        return self.__type
    @type.setter
    def type(self, type):
        if  type is None:
            type = SFString.NAME()
            # if _DEBUG: print('...DEBUG... set type to SFString.NAME()=' + str(SFString.NAME()))
        assertValidSFString(type)
    ### assertValidFieldType('type', type) # something strange is happening here
        self.__type = type
    @property # getter - - - - - - - - - -
    def name(self):
        """Name of the ProtoInstance field being re-initialized (corresponding to field name already defined in ProtoDeclare or ExternProtoDeclare)."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def value(self):
        """Initial value for this field, which overrides default initialization value defined in original ProtoDeclare field."""
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidFieldInitializationValue(self.name, type(value), value, parent='fieldValue')
        if isinstance(value,list) and isinstance(value[0],str):
            # print('*** found MFString when setting fieldValue name=' + self.name) # hack, better would be matching proto declaration
            self.type = 'MFString'
        self.__value = value
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DNode] If this field definition has type SFNode or MFNode, then initialization node (or nodes) of any appropriate type may be provided as children of the field definition."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return (len(self.children) > 0)
    # output function - - - - - - - - - -

class head(_X3DStatement):
    """
    Functional summary: each X3D scene includes a head statement that can contain component, unit and meta statements.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'head'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#Header'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#head'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [('children', None, FieldType.MFNode, AccessType.inputOutput, 'head')]
    def __init__(self, class_="", id_="", style_="", children=None):
        self.class_ = class_
        self.id_ = id_
        self.style_ = style_
        self.children = children
    @property # getter - - - - - - - - - -
    def class_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading stylesheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__class_
    @class_.setter
    def class_(self, class_):
        if  class_ is None:
            class_ = SFString.DEFAULT_VALUE()
        assertValidSFString(class_)
        self.__class_ = class_
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
        assertValidSFString(id_)
        self.__id = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
        assertValidSFString(style_)
        self.__style_ = style_
    @property # getter - - - - - - - - - -
    def children(self):
        """ The head statement has children consisting of component, unit and meta statements. """
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return bool(self.children)
    # output function - - - - - - - - - -

class IMPORT(_X3DStatement):
    """
    Functional summary: IMPORT provides ROUTE access to a node that has a corresponding EXPORT statement within an Inline scene. These connections allow event values to be exchanged via ROUTE statements between a parent model and a child Inline model.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'IMPORT'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/concepts.html#ImportExportsemantics'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IMPORT'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('AS', '', FieldType.SFString, AccessType.inputOutput, 'IMPORT'),
        ('importedDEF', '', FieldType.SFString, AccessType.inputOutput, 'IMPORT'),
        ('inlineDEF', '', FieldType.SFString, AccessType.inputOutput, 'IMPORT'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement')]
    def __init__(self,
        AS='',
        importedDEF='',
        inlineDEF='',
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in Statement IMPORT __init__ calling super.__init__(' + str(class_) + ',' + str(id_) + ',' + str(style_) +  + ')', flush=True)
        super().__init__(class_, id_, style_) # fields for _X3DStatement only
        self.AS = AS
        self.importedDEF = importedDEF
        self.inlineDEF = inlineDEF
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def AS(self):
        """map importedDEF name AS a new name in current scene."""
        return self.__AS
    @AS.setter
    def AS(self, AS):
        if  AS is None:
            AS = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(AS)
        self.__AS = AS
    @property # getter - - - - - - - - - -
    def importedDEF(self):
        """importedDEF is DEF name of the node of interest that is exported by the remote inlineDEF model."""
        return self.__importedDEF
    @importedDEF.setter
    def importedDEF(self, importedDEF):
        if  importedDEF is None:
            importedDEF = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(importedDEF)
        self.__importedDEF = importedDEF
    @property # getter - - - - - - - - - -
    def inlineDEF(self):
        """inlineDEF is the DEF name of Inline node in the same scene as this IMPORT statement."""
        return self.__inlineDEF
    @inlineDEF.setter
    def inlineDEF(self, inlineDEF):
        if  inlineDEF is None:
            inlineDEF = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(inlineDEF)
        self.__inlineDEF = inlineDEF
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return False
    # output function - - - - - - - - - -

class IS(_X3DStatement):
    """
    Functional summary: the IS statement connects node fields defined inside a ProtoBody declaration back to corresponding ProtoInterface fields. IS/connect statements can be added if the parent node is within a ProtoBody and connect statements define correspondences between prototype fields and built-in node fields.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'IS'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/concepts.html#PROTOdefinitionsemantics'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IS'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('connect', [], FieldType.MFNode, AccessType.inputOutput, 'IS'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement')]
    def __init__(self,
        connect=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in Statement IS __init__ calling super.__init__(' + str(class_) + ',' + str(id_) + ',' + str(style_) +  + ')', flush=True)
        super().__init__(class_, id_, style_) # fields for _X3DStatement only
        self.connect = connect
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def connect(self):
        """When inside a ProtoBody declaration and an IS statement, add a connect statement to define event-routing connections between a parent node's field to a corresponding ProtoInterface field."""
        return self.__connect
    @connect.setter
    def connect(self, connect):
        if  connect is None:
            connect = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(connect)
        self.__connect = connect
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return (len(self.connect) > 0)
    # output function - - - - - - - - - -

class meta(_X3DStatement):
    """
    Functional summary: the meta statement provides metadata information about a scene, where name and content attributes provide attribute=value metadata pairs.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'meta'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#Header'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#meta'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('content', '', FieldType.SFString, AccessType.inputOutput, 'meta'),
        ('dir', '', FieldType.SFString, AccessType.inputOutput, 'meta'),
        ('httpequiv', '', FieldType.SFString, AccessType.inputOutput, 'meta'),
        ('lang', '', FieldType.SFString, AccessType.inputOutput, 'meta'),
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'meta'),
        ('scheme', '', FieldType.SFString, AccessType.inputOutput, 'meta'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement')]
    def __init__(self,
        content='',
        dir='',
        httpequiv='',
        lang='',
        name='',
        scheme='',
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in Statement meta __init__ calling super.__init__(' + str(class_) + ',' + str(id_) + ',' + str(style_) +  + ')', flush=True)
        super().__init__(class_, id_, style_) # fields for _X3DStatement only
        self.content = content
        self.dir = dir
        self.httpequiv = httpequiv
        self.lang = lang
        self.name = name
        self.scheme = scheme
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def content(self):
        """The content attribute provides metadata information relevant to the name attribute provided."""
        return self.__content
    @content.setter
    def content(self, content):
        if  content is None:
            content = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(content)
        self.__content = content
    @property # getter - - - - - - - - - -
    def dir(self):
        """Direction for weak/neutral text (ltr=left-to-right, rtl=right-to-left)."""
        return self.__dir
    @dir.setter
    def dir(self, dir):
        if  dir is None:
            dir = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(dir)
        assertValidMetaDirection('dir', dir)
        self.__dir = dir
    @property # getter - - - - - - - - - -
    def httpequiv(self):
        """The http-equiv attribute provides an HTTP header for the value of the content attribute."""
        return self.__httpequiv
    @httpequiv.setter
    def httpequiv(self, httpequiv):
        if  httpequiv is None:
            httpequiv = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(httpequiv)
        self.__httpequiv = httpequiv
    @property # getter - - - - - - - - - -
    def lang(self):
        """Language code, as per [IETF BCP47/RFC5646]."""
        return self.__lang
    @lang.setter
    def lang(self, lang):
        if  lang is None:
            lang = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(lang)
        self.__lang = lang
    @property # getter - - - - - - - - - -
    def name(self):
        """Keyword name of the meta attribute, following the same naming conventions as HTML's meta tag."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def scheme(self):
        """The scheme attribute allows authors to provide user agents more context for the correct interpretation of meta information."""
        return self.__scheme
    @scheme.setter
    def scheme(self, scheme):
        if  scheme is None:
            scheme = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(scheme)
        self.__scheme = scheme
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return False
    # output function - - - - - - - - - -

class ProtoBody(_X3DStatement):
    """
    ProtoBody contains the definition nodes for new Prototype nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ProtoBody'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#PrototypeAndFieldDeclarationSyntax'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProtoBody'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'ProtoBody'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement')]
    def __init__(self,
        children=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in Statement ProtoBody __init__ calling super.__init__(' + str(class_) + ',' + str(id_) + ',' + str(style_) +  + ')', flush=True)
        super().__init__(class_, id_, style_) # fields for _X3DStatement only
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DNode] ProtoBody can contain nodes, statements and comments."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return (len(self.children) > 0)
    # output function - - - - - - - - - -

class ProtoDeclare(_X3DStatement):
    """
    ProtoDeclare defines new Prototype nodes. Nested ProtoDeclares and ProtoInstances are allowed by the specification.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ProtoDeclare'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#PrototypeAndFieldDeclarationSyntax'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProtoDeclare'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('appinfo', '', FieldType.SFString, AccessType.inputOutput, 'ProtoDeclare'),
        ('documentation', '', FieldType.SFString, AccessType.inputOutput, 'ProtoDeclare'),
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'ProtoDeclare'),
        ('ProtoBody', None, FieldType.SFNode, AccessType.inputOutput, 'ProtoDeclare'),
        ('ProtoInterface', None, FieldType.SFNode, AccessType.inputOutput, 'ProtoDeclare'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement')]
    def __init__(self,
        appinfo='',
        documentation='',
        name='',
        ProtoBody=None,
        ProtoInterface=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in Statement ProtoDeclare __init__ calling super.__init__(' + str(class_) + ',' + str(id_) + ',' + str(style_) +  + ')', flush=True)
        super().__init__(class_, id_, style_) # fields for _X3DStatement only
        self.appinfo = appinfo
        self.documentation = documentation
        self.name = name
        self.ProtoBody = ProtoBody
        self.ProtoInterface = ProtoInterface
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def appinfo(self):
        """Application information to provide simple description usable as a tooltip, similar to XML Schema appinfo tag."""
        return self.__appinfo
    @appinfo.setter
    def appinfo(self, appinfo):
        if  appinfo is None:
            appinfo = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(appinfo)
        self.__appinfo = appinfo
    @property # getter - - - - - - - - - -
    def documentation(self):
        """Documentation url for further information, similar to XML Schema documentation tag."""
        return self.__documentation
    @documentation.setter
    def documentation(self, documentation):
        if  documentation is None:
            documentation = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(documentation)
        self.__documentation = documentation
    @property # getter - - - - - - - - - -
    def name(self):
        """name of this prototype being declared."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def ProtoBody(self):
        """Include one ProtoBody statement after the ProtoInterface statement."""
        return self.__ProtoBody
    @ProtoBody.setter
    def ProtoBody(self, ProtoBody):
        if  ProtoBody is None:
            ProtoBody = None  # default
        assertValidSFNode(ProtoBody)
        self.__ProtoBody = ProtoBody
    @property # getter - - - - - - - - - -
    def ProtoInterface(self):
        """Include an optional ProtoInterface statement if this ProtoDeclare has field declarations."""
        return self.__ProtoInterface
    @ProtoInterface.setter
    def ProtoInterface(self, ProtoInterface):
        if  ProtoInterface is None:
            ProtoInterface = None  # default
        assertValidSFNode(ProtoInterface)
        self.__ProtoInterface = ProtoInterface
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.ProtoBody or self.ProtoInterface
    # output function - - - - - - - - - -

class ProtoInterface(_X3DStatement):
    """
    ProtoInterface defines fields for new Prototype nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ProtoInterface'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#PrototypeAndFieldDeclarationSyntax'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProtoInterface'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('field', [], FieldType.MFNode, AccessType.inputOutput, 'ProtoInterface'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement')]
    def __init__(self,
        field=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in Statement ProtoInterface __init__ calling super.__init__(' + str(class_) + ',' + str(id_) + ',' + str(style_) +  + ')', flush=True)
        super().__init__(class_, id_, style_) # fields for _X3DStatement only
        self.field = field
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def field(self):
        """Include a field statement for each field declaration in this ProtoDeclare's ProtoInterface."""
        return self.__field
    @field.setter
    def field(self, field):
        if  field is None:
            field = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        # TODO type-aware checks for field
        if field: # walk each child in list, if any (avoid empty list recursion)
            for each in field:
                assertValidFieldInitializationValue(each.name, each.type, each.value, parent='ProtoInterface')
        self.__field = field
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return (len(self.field) > 0)
    # output function - - - - - - - - - -

class ROUTE(_X3DStatement):
    """
    ROUTE connects output fields of event-producing nodes to input fields of event-consuming nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ROUTE'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/concepts.html#ModifyingObjectsRoutes'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ROUTE'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('fromField', '', FieldType.SFString, AccessType.inputOutput, 'ROUTE'),
        ('fromNode', '', FieldType.SFString, AccessType.inputOutput, 'ROUTE'),
        ('toField', '', FieldType.SFString, AccessType.inputOutput, 'ROUTE'),
        ('toNode', '', FieldType.SFString, AccessType.inputOutput, 'ROUTE'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement')]
    def __init__(self,
        fromField='',
        fromNode='',
        toField='',

        toNode='',
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in Statement ROUTE __init__ calling super.__init__(' + str(class_) + ',' + str(id_) + ',' + str(style_) +  + ')', flush=True)
        super().__init__(class_, id_, style_) # fields for _X3DStatement only
        self.fromField = fromField
        self.fromNode = fromNode
        self.toField = toField
        self.toNode = toNode
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def fromField(self):
        """fromField is the field name in the source node which is originating an event."""
        return self.__fromField
    @fromField.setter
    def fromField(self, fromField):
        if  fromField is None:
            fromField = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(fromField)
        self.__fromField = fromField
    @property # getter - - - - - - - - - -
    def fromNode(self):
        """fromNode is the DEF name of the node originating an event."""
        return self.__fromNode
    @fromNode.setter
    def fromNode(self, fromNode):
        if  fromNode is None:
            fromNode = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(fromNode)
        self.__fromNode = fromNode
    @property # getter - - - - - - - - - -
    def toField(self):
        """toField is the field name in the destination node which is receiving an event."""
        return self.__toField
    @toField.setter
    def toField(self, toField):
        if  toField is None:
            toField = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(toField)
        self.__toField = toField
    @property # getter - - - - - - - - - -
    def toNode(self):
        """toNode is the DEF name of the destination node receiving an event."""
        return self.__toNode
    @toNode.setter
    def toNode(self, toNode):
        if  toNode is None:
            toNode = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(toNode)
        self.__toNode = toNode
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return False
    # output function - - - - - - - - - -

class Scene(_X3DStatement):
    """
    Scene is the implicit root node of the X3D scene graph.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Scene'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#Header'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Scene'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'Scene'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement')]
    def __init__(self,
        children=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in Statement Scene __init__ calling super.__init__(' + str(class_) + ',' + str(id_) + ',' + str(style_) +  + ')', flush=True)
        super().__init__(class_, id_, style_) # fields for _X3DStatement only
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DNode] Scene can contain nodes, statements and comments."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return (len(self.children) > 0)
    # output function - - - - - - - - - -

class unit(_X3DStatement):
    """
    Functional summary: unit statement defines data-conversion factors for typed values defined in a scene.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'unit'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#UNITStatement'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#unit'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('category', '', FieldType.SFString, AccessType.initializeOnly, 'unit'),
        ('conversionFactor', 1.0, FieldType.SFDouble, AccessType.inputOutput, 'unit'),
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'unit'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement')]
    def __init__(self,
        category='',
        conversionFactor=1.0,
        name='',
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in Statement unit __init__ calling super.__init__(' + str(class_) + ',' + str(id_) + ',' + str(style_) +  + ')', flush=True)
        super().__init__(class_, id_, style_) # fields for _X3DStatement only
        self.category = category
        self.conversionFactor = conversionFactor
        self.name = name
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def category(self):
        """Base-unit category as defined in X3D Specification."""
        return self.__category
    @category.setter
    def category(self, category):
        if  category is None:
            category = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(category)
        assertValidUnitCategory('category', category)
        self.__category = category
    @property # getter - - - - - - - - - -
    def conversionFactor(self):
        """[0,+infinity) Positive double-precision factor that converts new base unit to default base unit."""
        return self.__conversionFactor
    @conversionFactor.setter
    def conversionFactor(self, conversionFactor):
        if  conversionFactor is None:
            conversionFactor = 1.0  # default
        assertValidSFDouble(conversionFactor)
        assertPositive('conversionFactor', conversionFactor)
        self.__conversionFactor = conversionFactor
    @property # getter - - - - - - - - - -
    def name(self):
        """Author-defined name for this unit conversionFactor value (for example, FeetToMeters)."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return False
    # output function - - - - - - - - - -

class X3D(_X3DNode):
    """
    X3D is the root node for an Extensible 3D (X3D) Graphics model.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'X3D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#Header'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#X3D'
    XML_HEADER = '<?xml version="1.0" encoding="UTF-8"?>'
    XML_DOCTYPE_X3D_3_0 = '<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.0//EN" "https://www.web3d.org/specifications/x3d-3.0.dtd">'
    XML_DOCTYPE_X3D_3_1 = '<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.1//EN" "https://www.web3d.org/specifications/x3d-3.1.dtd">'
    XML_DOCTYPE_X3D_3_2 = '<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.2//EN" "https://www.web3d.org/specifications/x3d-3.2.dtd">'
    XML_DOCTYPE_X3D_3_3 = '<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.3//EN" "https://www.web3d.org/specifications/x3d-3.3.dtd">'
    XML_DOCTYPE_X3D_4_0 = '<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 4.0//EN" "https://www.web3d.org/specifications/x3d-4.0.dtd">'
    XML_DOCTYPE_X3D_4_1 = '<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 4.1//EN" "https://www.web3d.org/specifications/x3d-4.1.dtd">'
    X3D_XML_SCHEMA_ATTRIBUTES_3_0 = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-3.0.xsd'"
    X3D_XML_SCHEMA_ATTRIBUTES_3_1 = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-3.1.xsd'"
    X3D_XML_SCHEMA_ATTRIBUTES_3_2 = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-3.2.xsd'"
    X3D_XML_SCHEMA_ATTRIBUTES_3_3 = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-3.3.xsd'"
    X3D_XML_SCHEMA_ATTRIBUTES_4_0 = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-4.0.xsd'"
    X3D_XML_SCHEMA_ATTRIBUTES_4_1 = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-4.1.xsd'"
    VRML97_HEADER = '#VRML V2.0 utf8'
    CLASSIC_VRML_HEADER_PREFIX = '#VRML V' # followed by X3D version number
    CLASSIC_VRML_HEADER_SUFFIX = ' utf8'

    # TODO confirm JSON Schema header
    JSON_HEADER = '''{
    "X3D":,
    {
        "encoding":"UTF-8",
        "$id":   "https://www.web3d.org/specifications/x3d-4.0-JSONSchema.json",
        "$schema": "https://json-schema.org/draft/2020-12/schema",
'''

    X3D_XML_VALIDATOR  = "https://savage.nps.edu/X3dValidator"
    X3D_JSON_VALIDATOR = "https://coderextreme.net/X3DJSONLD/src/main/html/validator.html"

    X3DOM_HEADER = """<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- =================================================================== -->
<!-- embedded X3D scene appears after html/head/script and style entries -->
<!-- =================================================================== -->
<html>
   <head>
      <title></title>
      <meta http-equiv="X-UA-Compatible" content="chrome=1,IE=edge"/>
      <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<!-- Numbered X3DOM release versions: https://doc.x3dom.org/download -->
<!-- Developer X3DOM release version: https://doc.x3dom.org/download/dev -->
<link rel="stylesheet"
            type="text/css"
            href="https://x3dom.org/release/x3dom.css"/>
      <script type="text/javascript" src="https://x3dom.org/release/x3dom-full.js"/>
      <meta name="warning"
            content="Webfonts must be loaded prior to using Text node in X3D scene... see https://x3dom.org/x3dom/example/x3dom_text.html"/>
      <!-- X3DOM needs Web Fonts when an X3D Text node is included -->
      <!-- adapted from https://x3dom.org/x3dom/example/x3dom_text.html and https://web.mit.edu/jmorzins/www/fonts.html -->
      <style type="text/css">
/* ============================================================================= */
@font-face {
  font-family: 'SERIF'; /* default original */
  font-style: normal;
  font-weight: 700;
  src: local('Roman'), url('Roman.ttf') format('truetype');
}
@font-face {
  font-family: 'SERIF'; /* default alternate */
  font-style: normal;
  font-weight: 700;
  src: local('Times New Roman'), local('TimesNewRoman'), url('Times New Roman.ttf') format('truetype');
}
/* ============================================================================= */
@font-face {
  font-family: 'SANS'; /* default original */
  font-style: normal;
  font-weight: 400;
  src: local('Arial'), url('Arial.ttf') format('truetype');
}
@font-face {
  font-family: 'SANS'; /* default alternate */
  font-style: normal;
  font-weight: 400;
  src: local('Helvetica'), url('Helvetica.ttf') format('truetype');
}
/* ============================================================================= */
@font-face {
  font-family: 'TYPEWRITER'; /* default original */
  font-style: normal;
  font-weight: 900;
  src: local('Courier'), url('Courier.ttf') format('truetype');
}
@font-face {
  font-family: 'TYPEWRITER'; /* default alternate */
  font-style: normal;
  font-weight: 900;
  src: local('Courier New'), url('Courier New.ttf') format('truetype');
}
/* ============================================================================= */
</style>
   </head>
   <body>"""
    X3DOM_FOOTER = """
   </body>
</html>
"""
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('profile', 'Full', FieldType.SFString, AccessType.inputOutput, 'X3D'),
        ('version', '4.0', FieldType.SFString, AccessType.inputOutput, 'X3D'),
        ('head', None, FieldType.SFNode, AccessType.inputOutput, 'X3D'),
        ('Scene', None, FieldType.SFNode, AccessType.inputOutput, 'X3D'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DStatement')]
    def __init__(self,
        profile='Full',
        version='4.0',
        head=None,
        Scene=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in Statement X3D __init__ calling super.__init__(' + str(class_) + ',' + str(id_) + ',' + str(style_) +  + ')', flush=True)
        super().__init__(class_, id_, style_) # fields for _X3DStatement only
        self.profile = profile
        self.version = version
        self.head = head
        self.Scene = Scene
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def profile(self):
        """profile attribute is required and defines the player or tool support needed for this model."""
        return self.__profile
    @profile.setter
    def profile(self, profile):
        if  profile is None:
            profile = 'Full'  # default
        assertValidSFString(profile)
        assertValidProfileName('profile', profile)
        self.__profile = profile
    @property # getter - - - - - - - - - -
    def version(self):
        """Default is highest value matching schema and DOCTYPE in the scene."""
        return self.__version
    @version.setter
    def version(self, version):
        if  version is None:
            version = '4.0'  # default
        assertValidSFString(version)
        assertValidX3dVersion('version', version)
        self.__version = version
    @property # getter - - - - - - - - - -
    def head(self):
        """Include a head element to contain component, unit or meta statements for this X3D model."""
        return self.__head
    @head.setter
    def head(self, head):
        if  head is None:
            head = None  # default
        assertValidSFNode(head)
        if not head is None and not isinstance(head,object):
            # print(flush=True)
            raise X3DTypeError(str(head) + ' does not match required node type object and is invalid')
        self.__head = head
    @property # getter - - - - - - - - - -
    def Scene(self):
        """Include a Scene element to contain scene-graph nodes for this X3D model."""
        return self.__Scene
    @Scene.setter
    def Scene(self, Scene):
        if  Scene is None:
            Scene = None  # default
        assertValidSFNode(Scene)
        if not Scene is None and not isinstance(Scene,object):
            # print(flush=True)
            raise X3DTypeError(str(Scene) + ' does not match required node type object and is invalid')
        self.__Scene = Scene
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.head or self.Scene
    # output function - - - - - - - - - -

class AcousticProperties(_X3DAppearanceChildNode):
    """
    AcousticProperties specifies the interaction of sound waves with characteristics of geometric objects in the scene.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'AcousticProperties'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#AcousticProperties'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#AcousticProperties'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('absorption', 0, FieldType.SFFloat, AccessType.inputOutput, 'AcousticProperties'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'AcousticProperties'),
        ('diffuse', 0, FieldType.SFFloat, AccessType.inputOutput, 'AcousticProperties'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'AcousticProperties'),
        ('refraction', 0, FieldType.SFFloat, AccessType.inputOutput, 'AcousticProperties'),
        ('specular', 0, FieldType.SFFloat, AccessType.inputOutput, 'AcousticProperties'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        absorption=0,
        description='',
        diffuse=0,
        enabled=True,
        refraction=0,
        specular=0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode AcousticProperties __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.absorption = absorption
        self.description = description
        self.diffuse = diffuse
        self.enabled = enabled
        self.refraction = refraction
        self.specular = specular
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def absorption(self):
        """[0,1] specifies the sound absorption coefficient of a surface, meaning the ratio of sound intensity not reflected by a surface."""
        return self.__absorption
    @absorption.setter
    def absorption(self, absorption):
        if  absorption is None:
            absorption = 0  # default
        assertValidSFFloat(absorption)
        assertZeroToOne('absorption', absorption)
        self.__absorption = absorption
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def diffuse(self):
        """[0,1] diffuse coefficient of sound reflection indicates how much of the incident sound energy is reflected back in multiple directions."""
        return self.__diffuse
    @diffuse.setter
    def diffuse(self, diffuse):
        if  diffuse is None:
            diffuse = 0  # default
        assertValidSFFloat(diffuse)
        assertZeroToOne('diffuse', diffuse)
        self.__diffuse = diffuse
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def refraction(self):
        """[0,1] sound refraction coefficient of a medium, which determines change in propagation direction of sound wave when obliquely crossing boundary between two mediums where its speed is different."""
        return self.__refraction
    @refraction.setter
    def refraction(self, refraction):
        if  refraction is None:
            refraction = 0  # default
        assertValidSFFloat(refraction)
        assertZeroToOne('refraction', refraction)
        self.__refraction = refraction
    @property # getter - - - - - - - - - -
    def specular(self):
        """[0,1] specular coefficient of sound reflection striking a plane surface, directly reflected back into space, where angle of reflection equals angle of incidence."""
        return self.__specular
    @specular.setter
    def specular(self, specular):
        if  specular is None:
            specular = 0  # default
        assertValidSFFloat(specular)
        assertZeroToOne('specular', specular)
        self.__specular = specular
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class Analyser(_X3DSoundProcessingNode):
    """
    Analyser provides real-time frequency and time-domain analysis information, without any change to the input.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Analyser'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#Analyser'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Analyser'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('channelCountMode', 'MAX', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('channelInterpretation', 'SPEAKERS', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('fftSize', 2048, FieldType.SFInt32, AccessType.inputOutput, 'Analyser'),
        ('frequencyBinCount', 1024, FieldType.SFInt32, AccessType.inputOutput, 'Analyser'),
        ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('maxDecibels', -30, FieldType.SFFloat, AccessType.inputOutput, 'Analyser'),
        ('minDecibels', -100, FieldType.SFFloat, AccessType.inputOutput, 'Analyser'),
        ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('smoothingTimeConstant', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'Analyser'),
        ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('tailTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'Analyser'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        channelCountMode='MAX',
        channelInterpretation='SPEAKERS',
        description='',
        enabled=True,
        fftSize=2048,
        frequencyBinCount=1024,
        gain=1,
        maxDecibels=-30,
        minDecibels=-100,
        pauseTime=0,
        resumeTime=0,
        smoothingTimeConstant=0.8,
        startTime=0,
        stopTime=0,
        tailTime=0,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Analyser __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.enabled = enabled
        self.fftSize = fftSize
        self.frequencyBinCount = frequencyBinCount
        self.gain = gain
        self.maxDecibels = maxDecibels
        self.minDecibels = minDecibels
        self.pauseTime = pauseTime
        self.resumeTime = resumeTime
        self.smoothingTimeConstant = smoothingTimeConstant
        self.startTime = startTime
        self.stopTime = stopTime
        self.tailTime = tailTime
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'MAX'  # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'SPEAKERS'  # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def fftSize(self):
        """(0,+infinity) fftSize represents size of Fast Fourier Transform (FFT) used to determine frequency domain."""
        return self.__fftSize
    @fftSize.setter
    def fftSize(self, fftSize):
        if  fftSize is None:
            fftSize = 2048  # default
        assertValidSFInt32(fftSize)
        assertNonNegative('fftSize', fftSize)
        self.__fftSize = fftSize
    @property # getter - - - - - - - - - -
    def frequencyBinCount(self):
        """(0,+infinity) frequencyBinCount is half of fftSize and generally equates to number of data values available for the visualization."""
        return self.__frequencyBinCount
    @frequencyBinCount.setter
    def frequencyBinCount(self, frequencyBinCount):
        if  frequencyBinCount is None:
            frequencyBinCount = 1024  # default
        assertValidSFInt32(frequencyBinCount)
        assertNonNegative('frequencyBinCount', frequencyBinCount)
        self.__frequencyBinCount = frequencyBinCount
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1  # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def maxDecibels(self):
        """(-infinity,+infinity) maxDecibels represents maximum power value in scaling range for FFT analysis data."""
        return self.__maxDecibels
    @maxDecibels.setter
    def maxDecibels(self, maxDecibels):
        if  maxDecibels is None:
            maxDecibels = -30  # default
        assertValidSFFloat(maxDecibels)
        self.__maxDecibels = maxDecibels
    @property # getter - - - - - - - - - -
    def minDecibels(self):
        """(-infinity,+infinity) minDecibels represents minimum power value in scaling range for FFT analysis data."""
        return self.__minDecibels
    @minDecibels.setter
    def minDecibels(self, minDecibels):
        if  minDecibels is None:
            minDecibels = -100  # default
        assertValidSFFloat(minDecibels)
        self.__minDecibels = minDecibels
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0  # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0  # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def smoothingTimeConstant(self):
        """(0,+infinity) smoothingTimeConstant represents averaging constant during last analysis frame."""
        return self.__smoothingTimeConstant
    @smoothingTimeConstant.setter
    def smoothingTimeConstant(self, smoothingTimeConstant):
        if  smoothingTimeConstant is None:
            smoothingTimeConstant = 0.8  # default
        assertValidSFFloat(smoothingTimeConstant)
        assertNonNegative('smoothingTimeConstant', smoothingTimeConstant)
        self.__smoothingTimeConstant = smoothingTimeConstant
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0  # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0  # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def tailTime(self):
        """[0,+infinity) tailTime is duration of time that a node continues to provide output signal after the input signal becomes silent."""
        return self.__tailTime
    @tailTime.setter
    def tailTime(self, tailTime):
        if  tailTime is None:
            tailTime = 0  # default
        assertValidSFTime(tailTime)
        assertNonNegative('tailTime', tailTime)
        self.__tailTime = tailTime
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DSoundChannelNode|X3DSoundProcessingNode|X3DSoundSourceNode] The children field specifies audio-graph sound sources providing input signals for this node."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class Anchor(_X3DGroupingNode, _X3DUrlObject):
    """
    Anchor is a Grouping node that can contain most nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Anchor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/networking.html#Anchor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Anchor'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('autoRefresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('autoRefreshTimeLimit', 3600, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DUrlObject'),
        ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
        ('parameter', [], FieldType.MFString, AccessType.inputOutput, 'Anchor'),
        ('url', [], FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        autoRefresh=0,
        autoRefreshTimeLimit=3600,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        description='',
        load=True,
        parameter=None,
        url=None,
        visible=True,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Anchor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.autoRefresh = autoRefresh
        self.autoRefreshTimeLimit = autoRefreshTimeLimit
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.description = description
        self.load = load
        self.parameter = parameter
        self.url = url
        self.visible = visible
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def autoRefresh(self):
        """The [autoRefresh field has no effect, Anchor operation is only triggered by user selection."""
        return self.__autoRefresh
    @autoRefresh.setter
    def autoRefresh(self, autoRefresh):
        if  autoRefresh is None:
            autoRefresh = 0  # default
        assertValidSFTime(autoRefresh)
        assertNonNegative('autoRefresh', autoRefresh)
        self.__autoRefresh = autoRefresh
    @property # getter - - - - - - - - - -
    def autoRefreshTimeLimit(self):
        """The [autoRefreshTimeLimit field has no effect, Anchor operation is only triggered by user selection."""
        return self.__autoRefreshTimeLimit
    @autoRefreshTimeLimit.setter
    def autoRefreshTimeLimit(self, autoRefreshTimeLimit):
        if  autoRefreshTimeLimit is None:
            autoRefreshTimeLimit = 3600  # default
        assertValidSFTime(autoRefreshTimeLimit)
        assertNonNegative('autoRefreshTimeLimit', autoRefreshTimeLimit)
        self.__autoRefreshTimeLimit = autoRefreshTimeLimit
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def load(self):
        """The load field has no effect, Anchor operation is only triggered by user selection."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True  # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def parameter(self):
        """If provided, parameter tells the X3D player where to to redirect the loaded url."""
        return self.__parameter
    @parameter.setter
    def parameter(self, parameter):
        if  parameter is None:
            parameter = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(parameter)
        self.__parameter = parameter
    @property # getter - - - - - - - - - -
    def url(self):
        """Address of replacement world, or #ViewpointDEFName within the current scene, or alternate Web resource, activated by the user selecting Shape geometry within the Anchor children nodes."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class Appearance(_X3DAppearanceNode):
    """
    Appearance specifies the visual properties of geometry by containing the Material, ImageTexture/MovieTexture/PixelTexture, FillProperties, LineProperties, programmable shader nodes (ComposedShader, PackagedShader, ProgramShader) and TextureTransform nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Appearance'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#Appearance'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Appearance'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('alphaCutoff', 0.5, FieldType.SFFloat, AccessType.inputOutput, 'Appearance'),
        ('alphaMode', 'AUTO', FieldType.SFString, AccessType.inputOutput, 'Appearance'),
        ('acousticProperties', None, FieldType.SFNode, AccessType.inputOutput, 'Appearance'),
        ('material', None, FieldType.SFNode, AccessType.inputOutput, 'Appearance'),
        ('backMaterial', None, FieldType.SFNode, AccessType.inputOutput, 'Appearance'),
        ('fillProperties', None, FieldType.SFNode, AccessType.inputOutput, 'Appearance'),
        ('lineProperties', None, FieldType.SFNode, AccessType.inputOutput, 'Appearance'),
        ('pointProperties', None, FieldType.SFNode, AccessType.inputOutput, 'Appearance'),
        ('texture', None, FieldType.SFNode, AccessType.inputOutput, 'Appearance'),
        ('textureTransform', None, FieldType.SFNode, AccessType.inputOutput, 'Appearance'),
        ('shaders', [], FieldType.MFNode, AccessType.inputOutput, 'Appearance'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        alphaCutoff=0.5,
        alphaMode='AUTO',
        acousticProperties=None,
        material=None,
        backMaterial=None,
        fillProperties=None,
        lineProperties=None,
        pointProperties=None,
        texture=None,
        textureTransform=None,
        shaders=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Appearance __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.alphaCutoff = alphaCutoff
        self.alphaMode = alphaMode
        self.acousticProperties = acousticProperties
        self.material = material
        self.backMaterial = backMaterial
        self.fillProperties = fillProperties
        self.lineProperties = lineProperties
        self.pointProperties = pointProperties
        self.texture = texture
        self.textureTransform = textureTransform
        self.shaders = shaders
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def alphaCutoff(self):
        """[0,1] Threshold value used for pixel rendering either transparent or opaque, used when alphaMode="MASK"."""
        return self.__alphaCutoff
    @alphaCutoff.setter
    def alphaCutoff(self, alphaCutoff):
        if  alphaCutoff is None:
            alphaCutoff = 0.5  # default
        assertValidSFFloat(alphaCutoff)
        assertZeroToOne('alphaCutoff', alphaCutoff)
        self.__alphaCutoff = alphaCutoff
    @property # getter - - - - - - - - - -
    def alphaMode(self):
        """Provides options for control of alpha transparency handling for textures."""
        return self.__alphaMode
    @alphaMode.setter
    def alphaMode(self, alphaMode):
        if  alphaMode is None:
            alphaMode = 'AUTO'  # default
        assertValidSFString(alphaMode)
        assertValidAlphaMode('alphaMode', alphaMode)
        self.__alphaMode = alphaMode
    @property # getter - - - - - - - - - -
    def acousticProperties(self):
        """[AcousticProperties] Single contained acousticProperties node that can specify additional acoustic attributes applied to associated surface geometry."""
        return self.__acousticProperties
    @acousticProperties.setter
    def acousticProperties(self, acousticProperties):
        if  acousticProperties is None:
            acousticProperties = None  # default
        assertValidSFNode(acousticProperties)
        if not acousticProperties is None and not isinstance(acousticProperties,(AcousticProperties,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(acousticProperties) + ' does not match required node type (AcousticProperties,ProtoInstance) and is invalid')
        self.__acousticProperties = acousticProperties
    @property # getter - - - - - - - - - -
    def material(self):
        """[X3DMaterialNode] Single contained Material, PhysicalMaterial, TwoSidedMaterial (deprecated), or UnlitMaterial node that can specify visual attributes for lighting response (color types, transparency, etc."""
        return self.__material
    @material.setter
    def material(self, material):
        if  material is None:
            material = None  # default
        assertValidSFNode(material)
        if not material is None and not isinstance(material,(_X3DMaterialNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(material) + ' does not match required node type (_X3DMaterialNode,ProtoInstance) and is invalid')
        self.__material = material
    @property # getter - - - - - - - - - -
    def backMaterial(self):
        """[X3DMaterialNode] Single contained Material, PhysicalMaterial or UnlitMaterial node that can specify visual attributes for lighting response (color types, transparency, etc."""
        return self.__backMaterial
    @backMaterial.setter
    def backMaterial(self, backMaterial):
        if  backMaterial is None:
            backMaterial = None  # default
        assertValidSFNode(backMaterial)
        if not backMaterial is None and not isinstance(backMaterial,(_X3DMaterialNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(backMaterial) + ' does not match required node type (_X3DMaterialNode,ProtoInstance) and is invalid')
        self.__backMaterial = backMaterial
    @property # getter - - - - - - - - - -
    def fillProperties(self):
        """[FillProperties] Single contained FillProperties node that can specify additional visual attributes applied to polygonal areas of corresponding geometry, on top of whatever other appearance is already defined."""
        return self.__fillProperties
    @fillProperties.setter
    def fillProperties(self, fillProperties):
        if  fillProperties is None:
            fillProperties = None  # default
        assertValidSFNode(fillProperties)
        if not fillProperties is None and not isinstance(fillProperties,(FillProperties,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(fillProperties) + ' does not match required node type (FillProperties,ProtoInstance) and is invalid')
        self.__fillProperties = fillProperties
    @property # getter - - - - - - - - - -
    def lineProperties(self):
        """[LineProperties] Single contained LineProperties node that can specify additional visual attributes applied to corresponding line geometry."""
        return self.__lineProperties
    @lineProperties.setter
    def lineProperties(self, lineProperties):
        if  lineProperties is None:
            lineProperties = None  # default
        assertValidSFNode(lineProperties)
        if not lineProperties is None and not isinstance(lineProperties,(LineProperties,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(lineProperties) + ' does not match required node type (LineProperties,ProtoInstance) and is invalid')
        self.__lineProperties = lineProperties
    @property # getter - - - - - - - - - -
    def pointProperties(self):
        """[LineProperties] Single contained PointProperties node that can specify additional visual attributes applied to corresponding point geometry."""
        return self.__pointProperties

    @pointProperties.setter
    def pointProperties(self, pointProperties):
        if  pointProperties is None:
            pointProperties = None  # default
        assertValidSFNode(pointProperties)
        if not pointProperties is None and not isinstance(pointProperties,(PointProperties,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(pointProperties) + ' does not match required node type (PointProperties,ProtoInstance) and is invalid')
        self.__pointProperties = pointProperties
    @property # getter - - - - - - - - - -
    def texture(self):
        """[X3DTextureNode] Single contained texture node (ImageTexture, MovieTexture, PixelTexture, MultiTexture) that maps image(s) to surface geometry."""
        return self.__texture
    @texture.setter
    def texture(self, texture):
        if  texture is None:
            texture = None  # default
        assertValidSFNode(texture)
        if not texture is None and not isinstance(texture,(_X3DTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(texture) + ' does not match required node type (_X3DTextureNode,ProtoInstance) and is invalid')
        self.__texture = texture
    @property # getter - - - - - - - - - -
    def textureTransform(self):
        """[X3DTextureTransformNode] Single contained TextureTransform node that defines 2D transformation applied to texture coordinates."""
        return self.__textureTransform
    @textureTransform.setter
    def textureTransform(self, textureTransform):
        if  textureTransform is None:
            textureTransform = None  # default
        assertValidSFNode(textureTransform)
        if not textureTransform is None and not isinstance(textureTransform,(_X3DTextureTransformNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(textureTransform) + ' does not match required node type (_X3DTextureTransformNode,ProtoInstance) and is invalid')
        self.__textureTransform = textureTransform
    @property # getter - - - - - - - - - -
    def shaders(self):
        """[X3DShaderNode] Zero or more contained programmable shader nodes (ComposedShader, PackagedShader, ProgramShader) that specify, in order of preference, author-programmed rendering characteristics."""
        return self.__shaders
    @shaders.setter
    def shaders(self, shaders):
        if  shaders is None:
            shaders = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(shaders)
        self.__shaders = shaders
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.acousticProperties or self.backMaterial or self.fillProperties or self.IS or self.lineProperties or self.material or self.metadata or self.pointProperties or self.texture or self.textureTransform or (len(self.shaders) > 0)
    # output function - - - - - - - - - -

class Arc2D(_X3DGeometryNode):
    """
    Arc2D is a line-based geometry node that defines a linear circular arc with center (0,0) in X-Y plane, with angles measured starting at positive x-axis and sweeping towards positive y-axis.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Arc2D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry2D.html#Arc2D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Arc2D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('endAngle', 1.570796, FieldType.SFFloat, AccessType.initializeOnly, 'Arc2D'),
        ('radius', 1, FieldType.SFFloat, AccessType.initializeOnly, 'Arc2D'),
        ('startAngle', 0, FieldType.SFFloat, AccessType.initializeOnly, 'Arc2D'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        endAngle=1.570796,
        radius=1,
        startAngle=0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Arc2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.endAngle = endAngle
        self.radius = radius
        self.startAngle = startAngle
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def endAngle(self):
        """[0,2pi] Arc extends from startAngle counterclockwise to endAngle, in radians."""
        return self.__endAngle
    @endAngle.setter
    def endAngle(self, endAngle):
        if  endAngle is None:
            endAngle = 1.570796  # default
        assertValidSFFloat(endAngle)
        assertGreaterThan('endAngle', endAngle, -6.2832)
        assertLessThan('endAngle', endAngle, 6.2832)
        self.__endAngle = endAngle
    @property # getter - - - - - - - - - -
    def radius(self):
        """(0,+infinity) circle radius, of which the arc is a portion."""
        return self.__radius
    @radius.setter
    def radius(self, radius):
        if  radius is None:
            radius = 1  # default
        assertValidSFFloat(radius)
        assertPositive('radius', radius)
        self.__radius = radius
    @property # getter - - - - - - - - - -
    def startAngle(self):
        """[0,2pi] Arc extends from startAngle counterclockwise to endAngle, in radians."""
        return self.__startAngle
    @startAngle.setter
    def startAngle(self, startAngle):
        if  startAngle is None:
            startAngle = 0  # default
        assertValidSFFloat(startAngle)
        assertGreaterThan('startAngle', startAngle, -6.2832)
        assertLessThan('startAngle', startAngle, 6.2832)
        self.__startAngle = startAngle
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class ArcClose2D(_X3DGeometryNode):
    """
    ArcClose2D is a polygonal geometry node that defines a linear circular arc, closed by PIE or CHORD line segments, with center (0,0) in X-Y plane, with angles measured starting at positive x-axis and sweeping towards positive y-axis.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ArcClose2D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry2D.html#ArcClose2D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ArcClose2D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('closureType', 'PIE', FieldType.SFString, AccessType.initializeOnly, 'ArcClose2D'),
        ('endAngle', 1.570796, FieldType.SFFloat, AccessType.initializeOnly, 'ArcClose2D'),
        ('radius', 1, FieldType.SFFloat, AccessType.initializeOnly, 'ArcClose2D'),
        ('solid', False, FieldType.SFBool, AccessType.initializeOnly, 'ArcClose2D'),
        ('startAngle', 0, FieldType.SFFloat, AccessType.initializeOnly, 'ArcClose2D'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        closureType='PIE',
        endAngle=1.570796,
        radius=1,
        solid=False,
        startAngle=0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ArcClose2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.closureType = closureType
        self.endAngle = endAngle
        self.radius = radius
        self.solid = solid
        self.startAngle = startAngle
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def closureType(self):
        """Defines whether pair of line segments connect to center (PIE), or single line-segment chord connects arc endpoints (CHORD)."""
        return self.__closureType
    @closureType.setter
    def closureType(self, closureType):
        if  closureType is None:
            closureType = 'PIE'  # default
        assertValidSFString(closureType)
        assertValidClosureType('closureType', closureType)
        self.__closureType = closureType
    @property # getter - - - - - - - - - -
    def endAngle(self):
        """[0,2pi] Arc extends from startAngle counterclockwise to endAngle, in radians."""
        return self.__endAngle
    @endAngle.setter
    def endAngle(self, endAngle):
        if  endAngle is None:
            endAngle = 1.570796  # default
        assertValidSFFloat(endAngle)
        assertGreaterThan('endAngle', endAngle, -6.2832)
        assertLessThan('endAngle', endAngle, 6.2832)
        self.__endAngle = endAngle
    @property # getter - - - - - - - - - -
    def radius(self):
        """(0,+infinity) circle radius, of which the arc is a portion."""
        return self.__radius
    @radius.setter
    def radius(self, radius):
        if  radius is None:
            radius = 1  # default
        assertValidSFFloat(radius)
        assertPositive('radius', radius)
        self.__radius = radius
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = False  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def startAngle(self):
        """[0,2pi] Arc extends from startAngle counterclockwise to endAngle, in radians."""
        return self.__startAngle
    @startAngle.setter
    def startAngle(self, startAngle):
        if  startAngle is None:
            startAngle = 0  # default
        assertValidSFFloat(startAngle)
        assertGreaterThan('startAngle', startAngle, -6.2832)
        assertLessThan('startAngle', startAngle, 6.2832)
        self.__startAngle = startAngle
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class AudioClip(_X3DSoundSourceNode, _X3DUrlObject):
    """
    AudioClip provides audio data used by parent Sound nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'AudioClip'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#AudioClip'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#AudioClip'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('autoRefresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('autoRefreshTimeLimit', 3600, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundSourceNode'),
        ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundSourceNode'),
        ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
        ('loop', False, FieldType.SFBool, AccessType.inputOutput, 'AudioClip'),
        ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('pitch', 1.0, FieldType.SFFloat, AccessType.inputOutput, 'AudioClip'),
        ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('url', [], FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        autoRefresh=0,
        autoRefreshTimeLimit=3600,
        description='',
        enabled=True,
        gain=1,
        load=True,
        loop=False,
        pauseTime=0,
        pitch=1.0,
        resumeTime=0,
        startTime=0,
        stopTime=0,
        url=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode AudioClip __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.autoRefresh = autoRefresh
        self.autoRefreshTimeLimit = autoRefreshTimeLimit
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.load = load
        self.loop = loop
        self.pauseTime = pauseTime
        self.pitch = pitch
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
        self.url = url
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def autoRefresh(self):
        """autoRefresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__autoRefresh
    @autoRefresh.setter
    def autoRefresh(self, autoRefresh):
        if  autoRefresh is None:
            autoRefresh = 0  # default
        assertValidSFTime(autoRefresh)
        assertNonNegative('autoRefresh', autoRefresh)
        self.__autoRefresh = autoRefresh
    @property # getter - - - - - - - - - -
    def autoRefreshTimeLimit(self):
        """autoRefreshTimeLimit defines maximum duration that automatic refresh activity can occur."""
        return self.__autoRefreshTimeLimit
    @autoRefreshTimeLimit.setter
    def autoRefreshTimeLimit(self, autoRefreshTimeLimit):
        if  autoRefreshTimeLimit is None:
            autoRefreshTimeLimit = 3600  # default
        assertValidSFTime(autoRefreshTimeLimit)
        assertNonNegative('autoRefreshTimeLimit', autoRefreshTimeLimit)
        self.__autoRefreshTimeLimit = autoRefreshTimeLimit
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1  # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True  # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def loop(self):
        """Repeat indefinitely when loop=true, repeat only once when loop=false."""
        return self.__loop
    @loop.setter
    def loop(self, loop):
        if  loop is None:
            loop = False  # default
        assertValidSFBool(loop)
        self.__loop = loop
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0  # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def pitch(self):
        """(0,+infinity) Multiplier for the rate at which sampled sound is played."""
        return self.__pitch
    @pitch.setter
    def pitch(self, pitch):
        if  pitch is None:
            pitch = 1.0  # default
        assertValidSFFloat(pitch)
        assertPositive('pitch', pitch)
        self.__pitch = pitch
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0  # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0  # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0  # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def url(self):
        """Location and filename of sound file or stream."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class AudioDestination(_X3DSoundDestinationNode):
    """
    AudioDestination node represents the final audio destination and is what user ultimately hears, typically from the speakers of user device.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'AudioDestination'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#AudioDestination'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#AudioDestination'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [

        ('channelCountMode', 'MAX', FieldType.SFString, AccessType.inputOutput, 'X3DSoundDestinationNode'),
        ('channelInterpretation', 'SPEAKERS', FieldType.SFString, AccessType.inputOutput, 'X3DSoundDestinationNode'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSoundNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundNode'),
        ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundDestinationNode'),
        ('maxChannelCount', 2, FieldType.SFInt32, AccessType.inputOutput, 'AudioDestination'),
        ('mediaDeviceID', '', FieldType.SFString, AccessType.inputOutput, 'X3DSoundDestinationNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'AudioDestination'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        channelCountMode='MAX',
        channelInterpretation='SPEAKERS',
        description='',
        enabled=True,
        gain=1,
        maxChannelCount=2,
        mediaDeviceID='',
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode AudioDestination __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.maxChannelCount = maxChannelCount
        self.mediaDeviceID = mediaDeviceID
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'MAX'  # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'SPEAKERS'  # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1  # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def maxChannelCount(self):
        """[0,+infinity) [maxChannelCount."""
        return self.__maxChannelCount
    @maxChannelCount.setter
    def maxChannelCount(self, maxChannelCount):
        if  maxChannelCount is None:
            maxChannelCount = 2  # default
        assertValidSFInt32(maxChannelCount)
        assertNonNegative('maxChannelCount', maxChannelCount)
        self.__maxChannelCount = maxChannelCount
    @property # getter - - - - - - - - - -
    def mediaDeviceID(self):
        """mediaDeviceID field provides ID parameter functionality."""
        return self.__mediaDeviceID
    @mediaDeviceID.setter
    def mediaDeviceID(self, mediaDeviceID):
        if  mediaDeviceID is None:
            mediaDeviceID = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(mediaDeviceID)
        self.__mediaDeviceID = mediaDeviceID
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DSoundChannelNode|X3DSoundProcessingNode|X3DSoundSourceNode] The children field specifies audio-graph sound sources providing input signals for this node."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class Background(_X3DBackgroundNode):
    """
    Background simulates ground and sky, using vertical arrays of wraparound color values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Background'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalEffects.html#Background'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Background'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('backUrl', [], FieldType.MFString, AccessType.inputOutput, 'Background'),
        ('bottomUrl', [], FieldType.MFString, AccessType.inputOutput, 'Background'),
        ('frontUrl', [], FieldType.MFString, AccessType.inputOutput, 'Background'),
        ('groundAngle', [], FieldType.MFFloat, AccessType.inputOutput, 'X3DBackgroundNode'),
        ('groundColor', [], FieldType.MFColor, AccessType.inputOutput, 'X3DBackgroundNode'),
        ('leftUrl', [], FieldType.MFString, AccessType.inputOutput, 'Background'),
        ('rightUrl', [], FieldType.MFString, AccessType.inputOutput, 'Background'),
        ('skyAngle', [], FieldType.MFFloat, AccessType.inputOutput, 'X3DBackgroundNode'),
        ('skyColor', [(0, 0, 0)], FieldType.MFColor, AccessType.inputOutput, 'X3DBackgroundNode'),
        ('topUrl', [], FieldType.MFString, AccessType.inputOutput, 'Background'),
        ('transparency', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DBackgroundNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        backUrl=None,
        bottomUrl=None,
        frontUrl=None,
        groundAngle=None,
        groundColor=None,
        leftUrl=None,
        rightUrl=None,
        skyAngle=None,
        skyColor=None,
        topUrl=None,
        transparency=0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Background __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.backUrl = backUrl
        self.bottomUrl = bottomUrl
        self.frontUrl = frontUrl
        self.groundAngle = groundAngle
        self.groundColor = groundColor
        self.leftUrl = leftUrl
        self.rightUrl = rightUrl
        self.skyAngle = skyAngle
        self.skyColor = skyColor
        self.topUrl = topUrl
        self.transparency = transparency
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def backUrl(self):
        """Image background panorama between ground/sky backdrop and scene's geometry."""
        return self.__backUrl
    @backUrl.setter
    def backUrl(self, backUrl):
        if  backUrl is None:
            backUrl = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(backUrl)
        self.__backUrl = backUrl
    @property # getter - - - - - - - - - -
    def bottomUrl(self):
        """Image background panorama between ground/sky backdrop and scene's geometry."""
        return self.__bottomUrl
    @bottomUrl.setter
    def bottomUrl(self, bottomUrl):
        if  bottomUrl is None:
            bottomUrl = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(bottomUrl)
        self.__bottomUrl = bottomUrl
    @property # getter - - - - - - - - - -
    def frontUrl(self):
        """Image background panorama between ground/sky backdrop and scene's geometry."""
        return self.__frontUrl
    @frontUrl.setter
    def frontUrl(self, frontUrl):
        if  frontUrl is None:
            frontUrl = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(frontUrl)
        self.__frontUrl = frontUrl
    @property # getter - - - - - - - - - -
    def groundAngle(self):
        """[0,pi/2] The angle array values increase from 0."""
        return self.__groundAngle
    @groundAngle.setter
    def groundAngle(self, groundAngle):
        if  groundAngle is None:
            groundAngle = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(groundAngle)
        assertGreaterThanEquals('groundAngle', groundAngle, 0)
        assertLessThanEquals('groundAngle', groundAngle, 1.5708)
        self.__groundAngle = groundAngle
    @property # getter - - - - - - - - - -
    def groundColor(self):
        """Color of the ground at the various angles on the ground partial sphere."""
        return self.__groundColor
    @groundColor.setter
    def groundColor(self, groundColor):
        if  groundColor is None:
            groundColor = MFColor.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFColor.DEFAULT_VALUE()))
        assertValidMFColor(groundColor)
        assertZeroToOne('groundColor', groundColor)
        self.__groundColor = groundColor
    @property # getter - - - - - - - - - -
    def leftUrl(self):
        """Image background panorama between ground/sky backdrop and scene's geometry."""
        return self.__leftUrl
    @leftUrl.setter
    def leftUrl(self, leftUrl):
        if  leftUrl is None:
            leftUrl = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(leftUrl)
        self.__leftUrl = leftUrl
    @property # getter - - - - - - - - - -
    def rightUrl(self):
        """Image background panorama between ground/sky backdrop and scene's geometry."""
        return self.__rightUrl
    @rightUrl.setter
    def rightUrl(self, rightUrl):
        if  rightUrl is None:
            rightUrl = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(rightUrl)
        self.__rightUrl = rightUrl
    @property # getter - - - - - - - - - -
    def skyAngle(self):
        """[0,pi] The angle array values increase from 0."""
        return self.__skyAngle
    @skyAngle.setter
    def skyAngle(self, skyAngle):
        if  skyAngle is None:
            skyAngle = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(skyAngle)
        assertGreaterThanEquals('skyAngle', skyAngle, 0)
        assertLessThanEquals('skyAngle', skyAngle, 3.1416)
        self.__skyAngle = skyAngle
    @property # getter - - - - - - - - - -
    def skyColor(self):
        """Color of the sky at various angles on the sky sphere."""
        return self.__skyColor
    @skyColor.setter
    def skyColor(self, skyColor):
        if  skyColor is None:
            skyColor = [(0, 0, 0)]  # default
        assertValidMFColor(skyColor)
        assertZeroToOne('skyColor', skyColor)
        self.__skyColor = skyColor
    @property # getter - - - - - - - - - -
    def topUrl(self):
        """Image background panorama between ground/sky backdrop and scene's geometry."""
        return self.__topUrl
    @topUrl.setter
    def topUrl(self, topUrl):
        if  topUrl is None:
            topUrl = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(topUrl)
        self.__topUrl = topUrl
    @property # getter - - - - - - - - - -
    def transparency(self):
        """[0,1] how "clear" the background is, allows underlying page to show through: 1."""
        return self.__transparency
    @transparency.setter
    def transparency(self, transparency):
        if  transparency is None:
            transparency = 0  # default
        assertValidSFFloat(transparency)
        assertZeroToOne('transparency', transparency)
        self.__transparency = transparency
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class BallJoint(_X3DRigidJointNode):
    """
    BallJoint represents an unconstrained joint between two bodies that pivot about a common anchor point.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'BallJoint'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#BallJoint'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BallJoint'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('anchorPoint', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'BallJoint'),
        ('forceOutput', ["NONE"], FieldType.MFString, AccessType.inputOutput, 'X3DRigidJointNode'),
        ('body1', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
        ('body2', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        anchorPoint=(0, 0, 0),
        forceOutput=None,
        body1=None,
        body2=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode BallJoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.anchorPoint = anchorPoint
        self.forceOutput = forceOutput
        self.body1 = body1
        self.body2 = body2
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def anchorPoint(self):
        """anchorPoint is joint center, specified in world coordinates."""
        return self.__anchorPoint
    @anchorPoint.setter
    def anchorPoint(self, anchorPoint):
        if  anchorPoint is None:
            anchorPoint = (0, 0, 0)  # default
        assertValidSFVec3f(anchorPoint)
        self.__anchorPoint = anchorPoint
    @property # getter - - - - - - - - - -
    def forceOutput(self):
        """forceOutput controls which output fields are generated for the next frame."""
        return self.__forceOutput
    @forceOutput.setter
    def forceOutput(self, forceOutput):
        if  forceOutput is None:
            forceOutput = ["NONE"]  # default
        assertValidMFString(forceOutput)
        self.__forceOutput = forceOutput
    @property # getter - - - - - - - - - -
    def body1(self):
        """[RigidBody] The body1 and body2 fields indicate the two RigidBody nodes connected by this joint."""
        return self.__body1
    @body1.setter
    def body1(self, body1):
        if  body1 is None:
            body1 = None  # default
        assertValidSFNode(body1)
        if not body1 is None and not isinstance(body1,(RigidBody,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(body1) + ' does not match required node type (RigidBody,ProtoInstance) and is invalid')
        self.__body1 = body1
    @property # getter - - - - - - - - - -
    def body2(self):
        """[RigidBody] The body1 and body2 fields indicate the two RigidBody nodes connected by this joint."""
        return self.__body2
    @body2.setter
    def body2(self, body2):
        if  body2 is None:
            body2 = None  # default
        assertValidSFNode(body2)
        if not body2 is None and not isinstance(body2,(RigidBody,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(body2) + ' does not match required node type (RigidBody,ProtoInstance) and is invalid')
        self.__body2 = body2
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.body1 or self.body2 or self.IS or self.metadata
    # output function - - - - - - - - - -

class Billboard(_X3DGroupingNode):
    """
    Billboard is a Grouping node that can contain most nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Billboard'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/navigation.html#Billboard'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Billboard'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('axisOfRotation', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'Billboard'),
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        axisOfRotation=(0, 1, 0),
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        visible=True,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Billboard __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.axisOfRotation = axisOfRotation
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.visible = visible
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def axisOfRotation(self):
        """axisOfRotation direction is relative to local coordinate system."""
        return self.__axisOfRotation
    @axisOfRotation.setter
    def axisOfRotation(self, axisOfRotation):
        if  axisOfRotation is None:
            axisOfRotation = (0, 1, 0)  # default
        assertValidSFVec3f(axisOfRotation)
        self.__axisOfRotation = axisOfRotation
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class BiquadFilter(_X3DSoundProcessingNode):
    """
    BiquadFilter node is an AudioNode processor implementing common low-order filters.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'BiquadFilter'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#BiquadFilter'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BiquadFilter'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('channelCountMode', 'MAX', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('channelInterpretation', 'SPEAKERS', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('detune', 0, FieldType.SFFloat, AccessType.inputOutput, 'BiquadFilter'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('frequency', 350, FieldType.SFFloat, AccessType.inputOutput, 'BiquadFilter'),
        ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('qualityFactor', 1, FieldType.SFFloat, AccessType.inputOutput, 'BiquadFilter'),
        ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('tailTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('type', 'LOWPASS', FieldType.SFString, AccessType.inputOutput, 'BiquadFilter'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'BiquadFilter'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        channelCountMode='MAX',
        channelInterpretation='SPEAKERS',
        description='',
        detune=0,
        enabled=True,
        frequency=350,
        gain=1,
        pauseTime=0,
        qualityFactor=1,
        resumeTime=0,
        startTime=0,
        stopTime=0,
        tailTime=0,
        type='LOWPASS',
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode BiquadFilter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.detune = detune
        self.enabled = enabled
        self.frequency = frequency
        self.gain = gain
        self.pauseTime = pauseTime
        self.qualityFactor = qualityFactor
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
        self.tailTime = tailTime
        self.type = type
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'MAX'  # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'SPEAKERS'  # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def detune(self):
        """(0,+infinity) The detune field forms a compound field together with playbackRate that together determine a computedPlaybackRate value."""
        return self.__detune
    @detune.setter
    def detune(self, detune):
        if  detune is None:
            detune = 0  # default
        assertValidSFFloat(detune)
        assertNonNegative('detune', detune)
        self.__detune = detune
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def frequency(self):
        """[0,+infinity) frequency at which the BiquadFilterNode operates, in Hz."""
        return self.__frequency
    @frequency.setter
    def frequency(self, frequency):
        if  frequency is None:
            frequency = 350  # default
        assertValidSFFloat(frequency)
        assertNonNegative('frequency', frequency)
        self.__frequency = frequency
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1  # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0  # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def qualityFactor(self):
        """[0,+infinity) qualityFactor is Quality Factor (Q) of the respective filter algorithm."""
        return self.__qualityFactor
    @qualityFactor.setter
    def qualityFactor(self, qualityFactor):
        if  qualityFactor is None:
            qualityFactor = 1  # default
        assertValidSFFloat(qualityFactor)
        assertNonNegative('qualityFactor', qualityFactor)
        self.__qualityFactor = qualityFactor
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0  # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0  # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0  # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def tailTime(self):
        """[0,+infinity) tailTime is duration of time that a node continues to provide output signal after the input signal becomes silent."""
        return self.__tailTime
    @tailTime.setter
    def tailTime(self, tailTime):
        if  tailTime is None:
            tailTime = 0  # default
        assertValidSFTime(tailTime)
        assertNonNegative('tailTime', tailTime)
        self.__tailTime = tailTime
    @property # getter - - - - - - - - - -
    def type(self):
        """type selects which BiquadFilter algorithm is used."""
        return self.__type
    @type.setter
    def type(self, type):
        if  type is None:
            type = 'LOWPASS'  # default
        assertValidSFString(type)
        assertValidBiquadTypeFilter('type', type)
        self.__type = type
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DSoundChannelNode|X3DSoundProcessingNode|X3DSoundSourceNode] The children field specifies audio-graph sound sources providing input signals for this node."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class BlendedVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    BlendedVolumeStyle combines rendering of two voxel data sets into one by blending voxel values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'BlendedVolumeStyle'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#BlendedVolumeStyle'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BlendedVolumeStyle'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeRenderStyleNode'),
        ('weightConstant1', 0.5, FieldType.SFFloat, AccessType.inputOutput, 'BlendedVolumeStyle'),
        ('weightConstant2', 0.5, FieldType.SFFloat, AccessType.inputOutput, 'BlendedVolumeStyle'),
        ('weightFunction1', 'CONSTANT', FieldType.SFString, AccessType.inputOutput, 'BlendedVolumeStyle'),
        ('weightFunction2', 'CONSTANT', FieldType.SFString, AccessType.inputOutput, 'BlendedVolumeStyle'),
        ('renderStyle', None, FieldType.SFNode, AccessType.inputOutput, 'BlendedVolumeStyle'),
        ('voxels', None, FieldType.SFNode, AccessType.inputOutput, 'BlendedVolumeStyle'),
        ('weightTransferFunction1', None, FieldType.SFNode, AccessType.inputOutput, 'BlendedVolumeStyle'),
        ('weightTransferFunction2', None, FieldType.SFNode, AccessType.inputOutput, 'BlendedVolumeStyle'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        enabled=True,
        weightConstant1=0.5,
        weightConstant2=0.5,
        weightFunction1='CONSTANT',
        weightFunction2='CONSTANT',
        renderStyle=None,
        voxels=None,
        weightTransferFunction1=None,
        weightTransferFunction2=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode BlendedVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.weightConstant1 = weightConstant1
        self.weightConstant2 = weightConstant2
        self.weightFunction1 = weightFunction1
        self.weightFunction2 = weightFunction2
        self.renderStyle = renderStyle
        self.voxels = voxels
        self.weightTransferFunction1 = weightTransferFunction1
        self.weightTransferFunction2 = weightTransferFunction2
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def weightConstant1(self):
        """[0,1] weightConstant1 is used when weightFunction1=CONSTANT."""
        return self.__weightConstant1
    @weightConstant1.setter
    def weightConstant1(self, weightConstant1):
        if  weightConstant1 is None:
            weightConstant1 = 0.5  # default
        assertValidSFFloat(weightConstant1)
        assertZeroToOne('weightConstant1', weightConstant1)
        self.__weightConstant1 = weightConstant1
    @property # getter - - - - - - - - - -
    def weightConstant2(self):
        """[0,1] weightConstant2 is used when weightFunction2=CONSTANT."""
        return self.__weightConstant2
    @weightConstant2.setter
    def weightConstant2(self, weightConstant2):
        if  weightConstant2 is None:
            weightConstant2 = 0.5  # default
        assertValidSFFloat(weightConstant2)
        assertZeroToOne('weightConstant2', weightConstant2)
        self.__weightConstant2 = weightConstant2
    @property # getter - - - - - - - - - -
    def weightFunction1(self):
        """specifies 2D textures used to determine weight values when weight function is set to TABLE."""
        return self.__weightFunction1
    @weightFunction1.setter
    def weightFunction1(self, weightFunction1):
        if  weightFunction1 is None:
            weightFunction1 = 'CONSTANT'  # default
        assertValidSFString(weightFunction1)
        assertValidVolumeRenderingWeightFunction('weightFunction1', weightFunction1)
        self.__weightFunction1 = weightFunction1
    @property # getter - - - - - - - - - -
    def weightFunction2(self):
        """specifies 2D textures used to determine weight values when weight function is set to TABLE."""
        return self.__weightFunction2
    @weightFunction2.setter
    def weightFunction2(self, weightFunction2):
        if  weightFunction2 is None:
            weightFunction2 = 'CONSTANT'  # default
        assertValidSFString(weightFunction2)
        assertValidVolumeRenderingWeightFunction('weightFunction2', weightFunction2)
        self.__weightFunction2 = weightFunction2
    @property # getter - - - - - - - - - -
    def renderStyle(self):
        """[X3DComposableVolumeRenderStyleNode] Single contained X3DComposableVolumeRenderStyleNode node that defines specific rendering technique for data in the voxels field, and the result is blended with parent VolumeData or SegmentedVoliumeData node."""
        return self.__renderStyle
    @renderStyle.setter
    def renderStyle(self, renderStyle):
        if  renderStyle is None:
            renderStyle = None  # default
        assertValidSFNode(renderStyle)
        if not renderStyle is None and not isinstance(renderStyle,(_X3DComposableVolumeRenderStyleNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(renderStyle) + ' does not match required node type (_X3DComposableVolumeRenderStyleNode,ProtoInstance) and is invalid')
        self.__renderStyle = renderStyle
    @property # getter - - - - - - - - - -
    def voxels(self):
        """[X3DTexture3DNode] Single contained X3DTexture3DNode (ComposedTexture3D, ImageTexture3D, PixelTexture3D) that provides second set of raw voxel information utilized by corresponding rendering styles."""
        return self.__voxels
    @voxels.setter
    def voxels(self, voxels):
        if  voxels is None:
            voxels = None  # default
        assertValidSFNode(voxels)
        if not voxels is None and not isinstance(voxels,(_X3DTexture3DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(voxels) + ' does not match required node type (_X3DTexture3DNode,ProtoInstance) and is invalid')
        self.__voxels = voxels
    @property # getter - - - - - - - - - -
    def weightTransferFunction1(self):
        """[X3DTexture2DNode] The weightTransferFunction1 and weightTransferFunction2 fields specify two-dimensional textures that are used to determine the weight values when the weight function is set to "TABLE"."""
        return self.__weightTransferFunction1
    @weightTransferFunction1.setter
    def weightTransferFunction1(self, weightTransferFunction1):
        if  weightTransferFunction1 is None:
            weightTransferFunction1 = None  # default
        assertValidSFNode(weightTransferFunction1)
        if not weightTransferFunction1 is None and not isinstance(weightTransferFunction1,(_X3DTexture2DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(weightTransferFunction1) + ' does not match required node type (_X3DTexture2DNode,ProtoInstance) and is invalid')
        self.__weightTransferFunction1 = weightTransferFunction1
    @property # getter - - - - - - - - - -
    def weightTransferFunction2(self):
        """[X3DTexture2DNode] The weightTransferFunction1 and weightTransferFunction2 fields specify two-dimensional textures that are used to determine the weight values when the weight function is set to "TABLE"."""
        return self.__weightTransferFunction2
    @weightTransferFunction2.setter
    def weightTransferFunction2(self, weightTransferFunction2):
        if  weightTransferFunction2 is None:
            weightTransferFunction2 = None  # default
        assertValidSFNode(weightTransferFunction2)
        if not weightTransferFunction2 is None and not isinstance(weightTransferFunction2,(_X3DTexture2DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(weightTransferFunction2) + ' does not match required node type (_X3DTexture2DNode,ProtoInstance) and is invalid')
        self.__weightTransferFunction2 = weightTransferFunction2
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.renderStyle or self.voxels or self.weightTransferFunction1 or self.weightTransferFunction2
    # output function - - - - - - - - - -

class BooleanFilter(_X3DChildNode):
    """
    BooleanFilter selectively passes true, false or negated events.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'BooleanFilter'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/eventUtilities.html#BooleanFilter'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BooleanFilter'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode BooleanFilter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class BooleanSequencer(_X3DSequencerNode):
    """
    BooleanSequencer generates periodic discrete Boolean values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'BooleanSequencer'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/eventUtilities.html#BooleanSequencer'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BooleanSequencer'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('key', [], FieldType.MFFloat, AccessType.inputOutput, 'X3DSequencerNode'),
        ('keyValue', [], FieldType.MFBool, AccessType.inputOutput, 'BooleanSequencer'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        key=None,
        keyValue=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode BooleanSequencer __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear sequencing, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFBool.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFBool.DEFAULT_VALUE()))
        assertValidMFBool(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class BooleanToggle(_X3DChildNode):
    """
    BooleanToggle maintains state and negates output when a true input is provided.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'BooleanToggle'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/eventUtilities.html#BooleanToggle'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BooleanToggle'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('toggle', False, FieldType.SFBool, AccessType.inputOutput, 'BooleanToggle'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        toggle=False,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode BooleanToggle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.toggle = toggle
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def toggle(self):
        """Persistent state value that gets toggled or reset."""
        return self.__toggle
    @toggle.setter
    def toggle(self, toggle):
        if  toggle is None:
            toggle = False  # default
        assertValidSFBool(toggle)
        self.__toggle = toggle
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class BooleanTrigger(_X3DTriggerNode):
    """
    BooleanTrigger converts time events to boolean true events.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'BooleanTrigger'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/eventUtilities.html#BooleanTrigger'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BooleanTrigger'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode BooleanTrigger __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class BoundaryEnhancementVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    BoundaryEnhancementVolumeStyle provides boundary enhancement for the volume rendering style.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'BoundaryEnhancementVolumeStyle'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#BoundaryEnhancementVolumeStyle'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BoundaryEnhancementVolumeStyle'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('boundaryOpacity', 0.9, FieldType.SFFloat, AccessType.inputOutput, 'BoundaryEnhancementVolumeStyle'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeRenderStyleNode'),
        ('opacityFactor', 2, FieldType.SFFloat, AccessType.inputOutput, 'BoundaryEnhancementVolumeStyle'),
        ('retainedOpacity', 0.2, FieldType.SFFloat, AccessType.inputOutput, 'BoundaryEnhancementVolumeStyle'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        boundaryOpacity=0.9,
        enabled=True,
        opacityFactor=2,
        retainedOpacity=0.2,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode BoundaryEnhancementVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.boundaryOpacity = boundaryOpacity
        self.enabled = enabled
        self.opacityFactor = opacityFactor
        self.retainedOpacity = retainedOpacity
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def boundaryOpacity(self):
        """[0,+infinity) boundaryOpacity k_gs is the factored amount of the gradient enhancement to use."""
        return self.__boundaryOpacity
    @boundaryOpacity.setter
    def boundaryOpacity(self, boundaryOpacity):
        if  boundaryOpacity is None:
            boundaryOpacity = 0.9  # default
        assertValidSFFloat(boundaryOpacity)
        assertZeroToOne('boundaryOpacity', boundaryOpacity)
        self.__boundaryOpacity = boundaryOpacity
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def opacityFactor(self):
        """[0,+infinity) opacityFactor k_ge is the power function to control the slope of the opacity curve to highlight the set of data."""
        return self.__opacityFactor
    @opacityFactor.setter
    def opacityFactor(self, opacityFactor):
        if  opacityFactor is None:
            opacityFactor = 2  # default
        assertValidSFFloat(opacityFactor)
        assertNonNegative('opacityFactor', opacityFactor)
        self.__opacityFactor = opacityFactor
    @property # getter - - - - - - - - - -
    def retainedOpacity(self):
        """[0,1] retainedOpacity k_gc is the amount of initial opacity to mix into the output."""
        return self.__retainedOpacity
    @retainedOpacity.setter
    def retainedOpacity(self, retainedOpacity):
        if  retainedOpacity is None:
            retainedOpacity = 0.2  # default
        assertValidSFFloat(retainedOpacity)
        assertZeroToOne('retainedOpacity', retainedOpacity)
        self.__retainedOpacity = retainedOpacity
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class BoundedPhysicsModel(_X3DParticlePhysicsModelNode):
    """
    BoundedPhysicsModel provides user-defined geometrical boundaries for particle motion.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'BoundedPhysicsModel'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#BoundedPhysicsModel'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BoundedPhysicsModel'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DParticlePhysicsModelNode'),
        ('geometry', None, FieldType.SFNode, AccessType.inputOutput, 'BoundedPhysicsModel'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        enabled=True,
        geometry=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode BoundedPhysicsModel __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.geometry = geometry
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def geometry(self):
        """[X3DGeometryNode] Single contained geometry node provides the geometry used for each particle when the parent ParticleSystem node has geometryType=GEOMETRY."""
        return self.__geometry
    @geometry.setter
    def geometry(self, geometry):
        if  geometry is None:
            geometry = None  # default
        assertValidSFNode(geometry)
        if not geometry is None and not isinstance(geometry,(_X3DGeometryNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(geometry) + ' does not match required node type (_X3DGeometryNode,ProtoInstance) and is invalid')
        self.__geometry = geometry
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.geometry or self.IS or self.metadata
    # output function - - - - - - - - - -

class Box(_X3DGeometryNode):
    """
    Box is a geometry node specifying a rectangular cuboid.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Box'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry3D.html#Box'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Box'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('size', (2, 2, 2), FieldType.SFVec3f, AccessType.initializeOnly, 'Box'),
        ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'Box'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        size=(2, 2, 2),
        solid=True,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Box __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.size = size
        self.solid = solid
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def size(self):
        """(0,+infinity) size x y z in meters."""
        return self.__size
    @size.setter
    def size(self, size):
        if  size is None:
            size = (2, 2, 2)  # default
        assertValidSFVec3f(size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class BufferAudioSource(_X3DSoundSourceNode, _X3DUrlObject):
    """
    BufferAudioSource node represents a memory-resident audio asset that can contain one or more channels.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'BufferAudioSource'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#BufferAudioSource'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BufferAudioSource'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('autoRefresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('autoRefreshTimeLimit', 3600, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('buffer', [], FieldType.MFFloat, AccessType.inputOutput, 'BufferAudioSource'),
        ('bufferDuration', 0, FieldType.SFTime, AccessType.inputOutput, 'BufferAudioSource'),
        ('channelCountMode', 'MAX', FieldType.SFString, AccessType.inputOutput, 'BufferAudioSource'),
        ('channelInterpretation', 'SPEAKERS', FieldType.SFString, AccessType.inputOutput, 'BufferAudioSource'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('detune', 0, FieldType.SFFloat, AccessType.inputOutput, 'BufferAudioSource'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundSourceNode'),
        ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundSourceNode'),
        ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
        ('loop', False, FieldType.SFBool, AccessType.inputOutput, 'BufferAudioSource'),
        ('loopEnd', 0, FieldType.SFFloat, AccessType.inputOutput, 'BufferAudioSource'),
        ('loopStart', 0, FieldType.SFFloat, AccessType.inputOutput, 'BufferAudioSource'),
        ('numberOfChannels', 0, FieldType.SFInt32, AccessType.inputOutput, 'BufferAudioSource'),
        ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('playbackRate', 1, FieldType.SFFloat, AccessType.inputOutput, 'BufferAudioSource'),
        ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('sampleRate', 0, FieldType.SFFloat, AccessType.inputOutput, 'BufferAudioSource'),
        ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('url', [], FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        autoRefresh=0,
        autoRefreshTimeLimit=3600,
        buffer=None,
        bufferDuration=0,
        channelCountMode='MAX',
        channelInterpretation='SPEAKERS',
        description='',
        detune=0,
        enabled=True,
        gain=1,
        load=True,
        loop=False,
        loopEnd=0,
        loopStart=0,
        numberOfChannels=0,
        pauseTime=0,
        playbackRate=1,
        resumeTime=0,
        sampleRate=0,
        startTime=0,
        stopTime=0,
        url=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode BufferAudioSource __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.autoRefresh = autoRefresh
        self.autoRefreshTimeLimit = autoRefreshTimeLimit
        self.buffer = buffer
        self.bufferDuration = bufferDuration
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.detune = detune
        self.enabled = enabled
        self.gain = gain
        self.load = load
        self.loop = loop
        self.loopEnd = loopEnd
        self.loopStart = loopStart
        self.numberOfChannels = numberOfChannels
        self.pauseTime = pauseTime
        self.playbackRate = playbackRate
        self.resumeTime = resumeTime
        self.sampleRate = sampleRate
        self.startTime = startTime
        self.stopTime = stopTime
        self.url = url
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def autoRefresh(self):
        """autoRefresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__autoRefresh
    @autoRefresh.setter
    def autoRefresh(self, autoRefresh):
        if  autoRefresh is None:
            autoRefresh = 0  # default
        assertValidSFTime(autoRefresh)
        assertNonNegative('autoRefresh', autoRefresh)
        self.__autoRefresh = autoRefresh
    @property # getter - - - - - - - - - -
    def autoRefreshTimeLimit(self):
        """autoRefreshTimeLimit defines maximum duration that automatic refresh activity can occur."""
        return self.__autoRefreshTimeLimit
    @autoRefreshTimeLimit.setter
    def autoRefreshTimeLimit(self, autoRefreshTimeLimit):
        if  autoRefreshTimeLimit is None:
            autoRefreshTimeLimit = 3600  # default
        assertValidSFTime(autoRefreshTimeLimit)
        assertNonNegative('autoRefreshTimeLimit', autoRefreshTimeLimit)
        self.__autoRefreshTimeLimit = autoRefreshTimeLimit
    @property # getter - - - - - - - - - -
    def buffer(self):
        """buffer is a memory-resident audio asset that can contain one or more channels."""
        return self.__buffer
    @buffer.setter
    def buffer(self, buffer):
        if  buffer is None:
            buffer = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(buffer)
        assertGreaterThanEquals('buffer', buffer, -1)
        assertLessThanEquals('buffer', buffer, 1)
        self.__buffer = buffer
    @property # getter - - - - - - - - - -
    def bufferDuration(self):
        """[0,+infinity) bufferDuration is duration in seconds to use from buffer field."""
        return self.__bufferDuration
    @bufferDuration.setter
    def bufferDuration(self, bufferDuration):
        if  bufferDuration is None:
            bufferDuration = 0  # default
        assertValidSFTime(bufferDuration)
        assertNonNegative('bufferDuration', bufferDuration)
        self.__bufferDuration = bufferDuration
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'MAX'  # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'SPEAKERS'  # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))

        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def detune(self):
        """(0,+infinity) The detune field forms a compound field together with playbackRate that together determine a computedPlaybackRate value."""
        return self.__detune
    @detune.setter
    def detune(self, detune):
        if  detune is None:
            detune = 0  # default
        assertValidSFFloat(detune)
        assertNonNegative('detune', detune)
        self.__detune = detune
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1  # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True  # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def loop(self):
        """Repeat indefinitely when loop=true, repeat only once when loop=false."""
        return self.__loop
    @loop.setter
    def loop(self, loop):
        if  loop is None:
            loop = False  # default
        assertValidSFBool(loop)
        self.__loop = loop
    @property # getter - - - - - - - - - -
    def loopEnd(self):
        """[0,+infinity) loopEnd field is optional playhead position where looping ends if loop=true."""
        return self.__loopEnd
    @loopEnd.setter
    def loopEnd(self, loopEnd):
        if  loopEnd is None:
            loopEnd = 0  # default
        assertValidSFFloat(loopEnd)
        assertNonNegative('loopEnd', loopEnd)
        self.__loopEnd = loopEnd
    @property # getter - - - - - - - - - -
    def loopStart(self):
        """[0,+infinity) loopStart field is optional playhead position where looping begins if loop=true."""
        return self.__loopStart
    @loopStart.setter
    def loopStart(self, loopStart):
        if  loopStart is None:
            loopStart = 0  # default
        assertValidSFFloat(loopStart)
        assertNonNegative('loopStart', loopStart)
        self.__loopStart = loopStart
    @property # getter - - - - - - - - - -
    def numberOfChannels(self):
        """[0,+infinity) numberOfChannels is number of audio channels found in this buffer source."""
        return self.__numberOfChannels
    @numberOfChannels.setter
    def numberOfChannels(self, numberOfChannels):
        if  numberOfChannels is None:
            numberOfChannels = 0  # default
        assertValidSFInt32(numberOfChannels)
        assertNonNegative('numberOfChannels', numberOfChannels)
        self.__numberOfChannels = numberOfChannels
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0  # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def playbackRate(self):
        """(-infinity,+infinity) playbackRate field is speed at which to render the audio stream, and forms a compound field together with detune field Hint: negative values play in reverse."""
        return self.__playbackRate
    @playbackRate.setter
    def playbackRate(self, playbackRate):
        if  playbackRate is None:
            playbackRate = 1  # default
        assertValidSFFloat(playbackRate)
        self.__playbackRate = playbackRate
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0  # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def sampleRate(self):
        """(-infinity,+infinity) sampleRate field is sample-frames per second."""
        return self.__sampleRate
    @sampleRate.setter
    def sampleRate(self, sampleRate):
        if  sampleRate is None:
            sampleRate = 0  # default
        assertValidSFFloat(sampleRate)
        assertNonNegative('sampleRate', sampleRate)
        self.__sampleRate = sampleRate
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0  # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0  # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def url(self):
        """Location and filename of sound file."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class CADAssembly(_X3DGroupingNode, _X3DProductStructureChildNode):
    """
    CADAssembly holds a set of Computer-Aided Design (CAD) assemblies or parts grouped together.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):

        """ Name of this X3D Node class. """
        return 'CADAssembly'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/CADGeometry.html#CADAssembly'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CADAssembly'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'X3DProductStructureChildNode'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        name='',
        visible=True,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode CADAssembly __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.name = name
        self.visible = visible
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def name(self):
        """Optional name for this particular CAD node."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class CADFace(_X3DProductStructureChildNode, _X3DBoundedObject):
    """
    CADFace holds geometry representing one face in a Computer-Aided Design (CAD) CADPart.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'CADFace'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/CADGeometry.html#CADFace'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CADFace'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'X3DProductStructureChildNode'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('shape', None, FieldType.SFNode, AccessType.inputOutput, 'CADFace'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        name='',
        visible=True,
        shape=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode CADFace __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.name = name
        self.visible = visible
        self.shape = shape
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def name(self):
        """Optional name for this particular CAD node."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def shape(self):
        """[X3DShapeNode|LOD|Transform] Contained Shape for this CADPart."""
        return self.__shape
    @shape.setter
    def shape(self, shape):
        if  shape is None:
            shape = None  # default
        assertValidSFNode(shape)
        if not shape is None and not isinstance(shape,(Shape,LOD,Transform,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(shape) + ' does not match required node type (Shape,LOD,Transform,ProtoInstance) and is invalid')
        self.__shape = shape
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.shape
    # output function - - - - - - - - - -

class CADLayer(_X3DGroupingNode):
    """
    CADLayer nodes define a hierarchy that shows layer structure for a Computer-Aided Design (CAD) model.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'CADLayer'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/CADGeometry.html#CADLayer'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CADLayer'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'CADLayer'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        name='',
        visible=True,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode CADLayer __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.name = name
        self.visible = visible
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def name(self):
        """Optional name for this particular CAD node."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class CADPart(_X3DProductStructureChildNode, _X3DGroupingNode):
    """
    CADPart is an atomic part that defines both coordinate-system location and the faces that constitute a part in a Computer-Aided Design (CAD) model.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'CADPart'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/CADGeometry.html#CADPart'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CADPart'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'CADPart'),
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'X3DProductStructureChildNode'),
        ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'CADPart'),
        ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'CADPart'),
        ('scaleOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'CADPart'),
        ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'CADPart'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'CADPart'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        center=(0, 0, 0),
        name='',
        rotation=(0, 0, 1, 0),
        scale=(1, 1, 1),
        scaleOrientation=(0, 0, 1, 0),
        translation=(0, 0, 0),
        visible=True,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode CADPart __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.center = center
        self.name = name
        self.rotation = rotation
        self.scale = scale
        self.scaleOrientation = scaleOrientation
        self.translation = translation
        self.visible = visible
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        """Translation offset from origin of local coordinate system, applied prior to rotation or scaling."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0)  # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def name(self):
        """Optional name for this particular CAD node."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def rotation(self):
        """Orientation (axis, angle in radians) of children relative to local coordinate system."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = (0, 0, 1, 0)  # default
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        """Non-uniform x-y-z scale of child coordinate system, adjusted by center and scaleOrientation."""
        return self.__scale
    @scale.setter
    def scale(self, scale):
        if  scale is None:
            scale = (1, 1, 1)  # default
        assertValidSFVec3f(scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def scaleOrientation(self):
        """Preliminary rotation of coordinate system before scaling (to allow scaling around arbitrary orientations)."""
        return self.__scaleOrientation
    @scaleOrientation.setter
    def scaleOrientation(self, scaleOrientation):
        if  scaleOrientation is None:
            scaleOrientation = (0, 0, 1, 0)  # default
        assertValidSFRotation(scaleOrientation)
        self.__scaleOrientation = scaleOrientation
    @property # getter - - - - - - - - - -
    def translation(self):
        """Position (x, y, z in meters) of children relative to local coordinate system."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0, 0)  # default
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class CartoonVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    CartoonVolumeStyle generates cartoon-style non-photorealistic rendering of associated volumetric data.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'CartoonVolumeStyle'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#CartoonVolumeStyle'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CartoonVolumeStyle'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('colorSteps', 4, FieldType.SFInt32, AccessType.inputOutput, 'CartoonVolumeStyle'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeRenderStyleNode'),
        ('orthogonalColor', (1, 1, 1, 1), FieldType.SFColorRGBA, AccessType.inputOutput, 'CartoonVolumeStyle'),
        ('parallelColor', (0, 0, 0, 1), FieldType.SFColorRGBA, AccessType.inputOutput, 'CartoonVolumeStyle'),
        ('surfaceNormals', None, FieldType.SFNode, AccessType.inputOutput, 'CartoonVolumeStyle'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        colorSteps=4,
        enabled=True,
        orthogonalColor=(1, 1, 1, 1),
        parallelColor=(0, 0, 0, 1),
        surfaceNormals=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode CartoonVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.colorSteps = colorSteps
        self.enabled = enabled
        self.orthogonalColor = orthogonalColor
        self.parallelColor = parallelColor
        self.surfaceNormals = surfaceNormals
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def colorSteps(self):
        """[1,64] Number of distinct colors taken from interpolated colors and used to render the object."""
        return self.__colorSteps
    @colorSteps.setter
    def colorSteps(self, colorSteps):
        if  colorSteps is None:
            colorSteps = 4  # default
        assertValidSFInt32(colorSteps)
        assertGreaterThanEquals('colorSteps', colorSteps, 1)
        assertLessThanEquals('colorSteps', colorSteps, 64)
        self.__colorSteps = colorSteps
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def orthogonalColor(self):
        """[0,1] orthogonalColor is used for surface normals that are orthogonal (perpendicular) to viewer's current location."""
        return self.__orthogonalColor
    @orthogonalColor.setter
    def orthogonalColor(self, orthogonalColor):
        if  orthogonalColor is None:
            orthogonalColor = (1, 1, 1, 1)  # default
        assertValidSFColorRGBA(orthogonalColor)
        assertZeroToOne('orthogonalColor', orthogonalColor)
        self.__orthogonalColor = orthogonalColor
    @property # getter - - - - - - - - - -
    def parallelColor(self):
        """[0,1] parallelColor is used for surface normals that are orthogonal to viewer's current location."""
        return self.__parallelColor
    @parallelColor.setter
    def parallelColor(self, parallelColor):
        if  parallelColor is None:
            parallelColor = (0, 0, 0, 1)  # default
        assertValidSFColorRGBA(parallelColor)
        assertZeroToOne('parallelColor', parallelColor)
        self.__parallelColor = parallelColor
    @property # getter - - - - - - - - - -
    def surfaceNormals(self):
        """[X3DTexture3DNode] The surfaceNormals field contains a 3D texture with at least three component values."""
        return self.__surfaceNormals
    @surfaceNormals.setter
    def surfaceNormals(self, surfaceNormals):
        if  surfaceNormals is None:
            surfaceNormals = None  # default
        assertValidSFNode(surfaceNormals)
        if not surfaceNormals is None and not isinstance(surfaceNormals,(_X3DTexture3DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(surfaceNormals) + ' does not match required node type (_X3DTexture3DNode,ProtoInstance) and is invalid')
        self.__surfaceNormals = surfaceNormals
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.surfaceNormals
    # output function - - - - - - - - - -

class ChannelMerger(_X3DSoundChannelNode):
    """
    ChannelMerger unites different input channels into a single output channel.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ChannelMerger'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#ChannelMerger'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ChannelMerger'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('channelCountMode', 'MAX', FieldType.SFString, AccessType.inputOutput, 'X3DSoundChannelNode'),
        ('channelInterpretation', 'SPEAKERS', FieldType.SFString, AccessType.inputOutput, 'X3DSoundChannelNode'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSoundNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundNode'),
        ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundChannelNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'ChannelMerger'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        channelCountMode='MAX',
        channelInterpretation='SPEAKERS',
        description='',
        enabled=True,
        gain=1,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ChannelMerger __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'MAX'  # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'SPEAKERS'  # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1  # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DSoundChannelNode|X3DSoundProcessingNode|X3DSoundSourceNode] The children field specifies audio-graph sound sources providing input signals for this node."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class ChannelSelector(_X3DSoundChannelNode):
    """
    ChannelSelector selects a single channel output from all input channels.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ChannelSelector'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#ChannelSelector'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ChannelSelector'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('channelCountMode', 'MAX', FieldType.SFString, AccessType.inputOutput, 'X3DSoundChannelNode'),
        ('channelInterpretation', 'SPEAKERS', FieldType.SFString, AccessType.inputOutput, 'X3DSoundChannelNode'),
        ('channelSelection', 0, FieldType.SFInt32, AccessType.inputOutput, 'ChannelSelector'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSoundNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundNode'),
        ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundChannelNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'ChannelSelector'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        channelCountMode='MAX',
        channelInterpretation='SPEAKERS',
        channelSelection=0,
        description='',
        enabled=True,
        gain=1,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ChannelSelector __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.channelSelection = channelSelection
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'MAX'  # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'SPEAKERS'  # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def channelSelection(self):
        """[0,+infinity) channelSelection is single channel of interest from those provided by input nodes."""
        return self.__channelSelection
    @channelSelection.setter
    def channelSelection(self, channelSelection):
        if  channelSelection is None:
            channelSelection = 0  # default
        assertValidSFInt32(channelSelection)
        assertNonNegative('channelSelection', channelSelection)
        self.__channelSelection = channelSelection
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1  # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DSoundChannelNode|X3DSoundProcessingNode|X3DSoundSourceNode] The children field specifies audio-graph sound sources providing input signals for this node."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class ChannelSplitter(_X3DSoundChannelNode):
    """
    ChannelSplitter separates the different channels of a single audio source into a set of monophonic output channels.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ChannelSplitter'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#ChannelSplitter'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ChannelSplitter'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('channelCountMode', 'MAX', FieldType.SFString, AccessType.inputOutput, 'X3DSoundChannelNode'),
        ('channelInterpretation', 'SPEAKERS', FieldType.SFString, AccessType.inputOutput, 'X3DSoundChannelNode'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSoundNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundNode'),
        ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundChannelNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'ChannelSplitter'),
        ('outputs', [], FieldType.MFNode, AccessType.inputOutput, 'ChannelSplitter'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        channelCountMode='MAX',
        channelInterpretation='SPEAKERS',
        description='',
        enabled=True,
        gain=1,
        children=None,
        outputs=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ChannelSplitter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.children = children
        self.outputs = outputs
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'MAX'  # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'SPEAKERS'  # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1  # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DSoundChannelNode|X3DSoundProcessingNode|X3DSoundSourceNode] The children field specifies audio-graph sound sources providing input signals for this node, making up a section of the audio graph."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def outputs(self):
        """[X3DSoundChannelNode|X3DSoundProcessingNode|X3DSoundSourceNode] The outputs field is a set of output nodes receiving the split channels, and making up a section of the audio graph."""
        return self.__outputs
    @outputs.setter
    def outputs(self, outputs):
        if  outputs is None:
            outputs = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(outputs)
        self.__outputs = outputs
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0) or (len(self.outputs) > 0)
    # output function - - - - - - - - - -

class Circle2D(_X3DGeometryNode):
    """
    Circle2D is a geometry node that defines a linear X-Y circle with center (0,0) in X-Y plane.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Circle2D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry2D.html#Circle2D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Circle2D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('radius', 1, FieldType.SFFloat, AccessType.initializeOnly, 'Circle2D'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        radius=1,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Circle2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.radius = radius
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def radius(self):
        """(0,+infinity) circle radius."""
        return self.__radius
    @radius.setter
    def radius(self, radius):
        if  radius is None:
            radius = 1  # default
        assertValidSFFloat(radius)
        assertPositive('radius', radius)
        self.__radius = radius
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class ClipPlane(_X3DChildNode):
    """
    ClipPlane specifies a single plane equation used to clip (i.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ClipPlane'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#ClipPlane'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ClipPlane'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'ClipPlane'),
        ('plane', (0, 1, 0, 0), FieldType.SFVec4f, AccessType.inputOutput, 'ClipPlane'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        enabled=True,
        plane=(0, 1, 0, 0),
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ClipPlane __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.plane = plane
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def plane(self):
        """[0,1] If (a,b,c,d) is the plane, with the first three components being a normalized vector describing the plane's normal direction (and thus the fourth component d being distance from the origin), a point (x,y,z) is visible to the user, with regards to the clipping plane, if a*x+b*y+c*z+d is greater than 0."""
        return self.__plane
    @plane.setter
    def plane(self, plane):
        if  plane is None:
            plane = (0, 1, 0, 0)  # default
        assertValidSFVec4f(plane)
        assertGreaterThanEquals('plane', plane, -1)
        assertLessThanEquals('plane', plane, 1)
        self.__plane = plane
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class CollidableOffset(_X3DNBodyCollidableNode):
    """
    CollidableOffset repositions geometry relative to center of owning body.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'CollidableOffset'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#CollidableOffset'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CollidableOffset'
    @classmethod
    def FIELD_DECLARATIONS(cls):

        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DNBodyCollidableNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DNBodyCollidableNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DNBodyCollidableNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DNBodyCollidableNode'),
        ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'X3DNBodyCollidableNode'),
        ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'X3DNBodyCollidableNode'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DNBodyCollidableNode'),
        ('collidable', None, FieldType.SFNode, AccessType.initializeOnly, 'CollidableOffset'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        enabled=True,
        rotation=(0, 0, 1, 0),
        translation=(0, 0, 0),
        visible=True,
        collidable=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode CollidableOffset __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.enabled = enabled
        self.rotation = rotation
        self.translation = translation
        self.visible = visible
        self.collidable = collidable
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def rotation(self):
        """Orientation (axis, angle in radians) of children relative to local coordinate system."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = (0, 0, 1, 0)  # default
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def translation(self):
        """Position (x, y, z in meters) of children relative to local coordinate system."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0, 0)  # default
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def collidable(self):
        """[X3DNBodyCollidableNode] The collidable field holds a reference to a single nested item of a collidable scene graph."""
        return self.__collidable
    @collidable.setter
    def collidable(self, collidable):
        if  collidable is None:
            collidable = None  # default
        assertValidSFNode(collidable)
        if not collidable is None and not isinstance(collidable,(_X3DNBodyCollidableNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(collidable) + ' does not match required node type (_X3DNBodyCollidableNode,ProtoInstance) and is invalid')
        self.__collidable = collidable
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.collidable or self.IS or self.metadata
    # output function - - - - - - - - - -

class CollidableShape(_X3DNBodyCollidableNode):
    """
    CollidableShape connects the collision detection system, the rigid body model, and the renderable scene graph.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'CollidableShape'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#CollidableShape'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CollidableShape'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DNBodyCollidableNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DNBodyCollidableNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DNBodyCollidableNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DNBodyCollidableNode'),
        ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'X3DNBodyCollidableNode'),
        ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'X3DNBodyCollidableNode'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DNBodyCollidableNode'),
        ('shape', None, FieldType.SFNode, AccessType.initializeOnly, 'CollidableShape'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        enabled=True,
        rotation=(0, 0, 1, 0),
        translation=(0, 0, 0),
        visible=True,
        shape=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode CollidableShape __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.enabled = enabled
        self.rotation = rotation
        self.translation = translation
        self.visible = visible
        self.shape = shape
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def rotation(self):
        """Orientation (axis, angle in radians) of children relative to local coordinate system."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = (0, 0, 1, 0)  # default
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def translation(self):
        """Position (x, y, z in meters) of children relative to local coordinate system."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0, 0)  # default
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def shape(self):
        """[Shape] The shape field provides a geometry proxy for specifying which geometry best represents the collidable object."""
        return self.__shape
    @shape.setter
    def shape(self, shape):
        if  shape is None:
            shape = None  # default
        assertValidSFNode(shape)
        if not shape is None and not isinstance(shape,(Shape,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(shape) + ' does not match required node type (Shape,ProtoInstance) and is invalid')
        self.__shape = shape
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.shape
    # output function - - - - - - - - - -

class Collision(_X3DGroupingNode, _X3DSensorNode):
    """
    Collision detects camera-to-object contact using current view and NavigationInfo avatarSize.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Collision'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/navigation.html#Collision'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Collision'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSensorNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('proxy', None, FieldType.SFNode, AccessType.initializeOnly, 'Collision'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        description='',
        enabled=True,
        visible=True,
        proxy=None,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Collision __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.description = description
        self.enabled = enabled
        self.visible = visible
        self.proxy = proxy
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables collision detection for children and all descendants."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def proxy(self):
        """[X3DChildNode] The proxy node is used as a substitute for Collision children during collision detection, simplifying collision-intersection computations."""
        return self.__proxy
    @proxy.setter
    def proxy(self, proxy):
        if  proxy is None:
            proxy = None  # default
        assertValidSFNode(proxy)
        if not proxy is None and not isinstance(proxy,(_X3DChildNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(proxy) + ' does not match required node type (_X3DChildNode,ProtoInstance) and is invalid')
        self.__proxy = proxy
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.proxy or (len(self.children) > 0)
    # output function - - - - - - - - - -

class CollisionCollection(_X3DChildNode, _X3DBoundedObject):
    """
    CollisionCollection holds a collection of objects that can be managed as a single entity for resolution of inter-object collisions.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'CollisionCollection'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#CollisionCollection'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CollisionCollection'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('appliedParameters', ["BOUNCE"], FieldType.MFString, AccessType.inputOutput, 'CollisionCollection'),
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('bounce', 0, FieldType.SFFloat, AccessType.inputOutput, 'CollisionCollection'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'CollisionCollection'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'CollisionCollection'),
        ('frictionCoefficients', (0, 0), FieldType.SFVec2f, AccessType.inputOutput, 'CollisionCollection'),
        ('minBounceSpeed', 0.1, FieldType.SFFloat, AccessType.inputOutput, 'CollisionCollection'),
        ('slipFactors', (0, 0), FieldType.SFVec2f, AccessType.inputOutput, 'CollisionCollection'),
        ('softnessConstantForceMix', 0.0001, FieldType.SFFloat, AccessType.inputOutput, 'CollisionCollection'),
        ('softnessErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'CollisionCollection'),
        ('surfaceSpeed', (0, 0), FieldType.SFVec2f, AccessType.inputOutput, 'CollisionCollection'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('collidables', [], FieldType.MFNode, AccessType.inputOutput, 'CollisionCollection'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        appliedParameters=None,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        bounce=0,
        description='',
        enabled=True,
        frictionCoefficients=(0, 0),
        minBounceSpeed=0.1,
        slipFactors=(0, 0),
        softnessConstantForceMix=0.0001,
        softnessErrorCorrection=0.8,
        surfaceSpeed=(0, 0),
        visible=True,
        collidables=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode CollisionCollection __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.appliedParameters = appliedParameters
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.bounce = bounce
        self.description = description
        self.enabled = enabled
        self.frictionCoefficients = frictionCoefficients
        self.minBounceSpeed = minBounceSpeed
        self.slipFactors = slipFactors
        self.softnessConstantForceMix = softnessConstantForceMix
        self.softnessErrorCorrection = softnessErrorCorrection
        self.surfaceSpeed = surfaceSpeed
        self.visible = visible
        self.collidables = collidables
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def appliedParameters(self):
        """Default global parameters for collision outputs of rigid body physics system."""
        return self.__appliedParameters
    @appliedParameters.setter
    def appliedParameters(self, appliedParameters):
        if  appliedParameters is None:
            appliedParameters = ["BOUNCE"]  # default
        assertValidMFString(appliedParameters)
        assertValidAppliedParameters('appliedParameters', appliedParameters)
        self.__appliedParameters = appliedParameters
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def bounce(self):
        """[0,1] bounce indicates bounciness (0 = no bounce at all, 1 = maximum bounce)."""
        return self.__bounce
    @bounce.setter
    def bounce(self, bounce):
        if  bounce is None:
            bounce = 0  # default
        assertValidSFFloat(bounce)
        assertZeroToOne('bounce', bounce)
        self.__bounce = bounce
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def frictionCoefficients(self):
        """frictionCoefficients used for computing surface drag."""
        return self.__frictionCoefficients
    @frictionCoefficients.setter
    def frictionCoefficients(self, frictionCoefficients):
        if  frictionCoefficients is None:
            frictionCoefficients = (0, 0)  # default
        assertValidSFVec2f(frictionCoefficients)
        assertNonNegative('frictionCoefficients', frictionCoefficients)
        self.__frictionCoefficients = frictionCoefficients
    @property # getter - - - - - - - - - -
    def minBounceSpeed(self):
        """[0,+infinity) minBounceSpeed m/s needed to bounce."""
        return self.__minBounceSpeed
    @minBounceSpeed.setter
    def minBounceSpeed(self, minBounceSpeed):
        if  minBounceSpeed is None:
            minBounceSpeed = 0.1  # default
        assertValidSFFloat(minBounceSpeed)
        assertNonNegative('minBounceSpeed', minBounceSpeed)
        self.__minBounceSpeed = minBounceSpeed
    @property # getter - - - - - - - - - -
    def slipFactors(self):
        """slipFactors used for computing surface drag."""
        return self.__slipFactors
    @slipFactors.setter
    def slipFactors(self, slipFactors):
        if  slipFactors is None:
            slipFactors = (0, 0)  # default
        assertValidSFVec2f(slipFactors)
        self.__slipFactors = slipFactors
    @property # getter - - - - - - - - - -
    def softnessConstantForceMix(self):
        """[0,1] softnessConstantForceMix value applies a constant force value to make colliding surfaces appear to be somewhat soft."""
        return self.__softnessConstantForceMix
    @softnessConstantForceMix.setter
    def softnessConstantForceMix(self, softnessConstantForceMix):
        if  softnessConstantForceMix is None:
            softnessConstantForceMix = 0.0001  # default
        assertValidSFFloat(softnessConstantForceMix)
        assertZeroToOne('softnessConstantForceMix', softnessConstantForceMix)
        self.__softnessConstantForceMix = softnessConstantForceMix
    @property # getter - - - - - - - - - -
    def softnessErrorCorrection(self):
        """[0,1] softnessErrorCorrection indicates fraction of collision error fixed in a set of evaluations (0 = no error correction, 1 = all errors corrected in single step)."""
        return self.__softnessErrorCorrection
    @softnessErrorCorrection.setter
    def softnessErrorCorrection(self, softnessErrorCorrection):
        if  softnessErrorCorrection is None:
            softnessErrorCorrection = 0.8  # default
        assertValidSFFloat(softnessErrorCorrection)
        assertZeroToOne('softnessErrorCorrection', softnessErrorCorrection)
        self.__softnessErrorCorrection = softnessErrorCorrection
    @property # getter - - - - - - - - - -
    def surfaceSpeed(self):
        """surfaceSpeed defines speed vectors for computing surface drag, if contact surfaces move independently of bodies."""
        return self.__surfaceSpeed
    @surfaceSpeed.setter
    def surfaceSpeed(self, surfaceSpeed):
        if  surfaceSpeed is None:
            surfaceSpeed = (0, 0)  # default
        assertValidSFVec2f(surfaceSpeed)
        self.__surfaceSpeed = surfaceSpeed
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def collidables(self):
        """[CollisionSpace|CollidableShape|CollidableOffset] CollisionCollection node holds a collection of objects in the collidables field that can be managed as a single entity for resolution of inter-object collisions with other groups of collidable objects."""
        return self.__collidables
    @collidables.setter
    def collidables(self, collidables):
        if  collidables is None:
            collidables = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(collidables)
        self.__collidables = collidables
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.collidables) > 0)
    # output function - - - - - - - - - -

class CollisionSensor(_X3DSensorNode):
    """
    CollisionSensor generates collision-detection events.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'CollisionSensor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#CollisionSensor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CollisionSensor'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSensorNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('collider', None, FieldType.SFNode, AccessType.inputOutput, 'CollisionSensor'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        description='',
        enabled=True,
        collider=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode CollisionSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.enabled = enabled
        self.collider = collider
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def collider(self):
        """[CollisionCollection] The collider field specifies a CollisionCollection node that holds a collidables field of nodes and spaces that are to be included in collision-detection computations."""
        return self.__collider
    @collider.setter
    def collider(self, collider):
        if  collider is None:
            collider = None  # default
        assertValidSFNode(collider)
        if not collider is None and not isinstance(collider,(CollisionCollection,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(collider) + ' does not match required node type (CollisionCollection,ProtoInstance) and is invalid')
        self.__collider = collider
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.collider or self.IS or self.metadata
    # output function - - - - - - - - - -

class CollisionSpace(_X3DNBodyCollisionSpaceNode):
    """
    CollisionSpace holds collection of objects considered together for resolution of inter-object collisions.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'CollisionSpace'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#CollisionSpace'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CollisionSpace'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DNBodyCollisionSpaceNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DNBodyCollisionSpaceNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DNBodyCollisionSpaceNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DNBodyCollisionSpaceNode'),
        ('useGeometry', False, FieldType.SFBool, AccessType.inputOutput, 'CollisionSpace'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DNBodyCollisionSpaceNode'),
        ('collidables', [], FieldType.MFNode, AccessType.inputOutput, 'CollisionSpace'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        enabled=True,
        useGeometry=False,
        visible=True,
        collidables=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode CollisionSpace __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.enabled = enabled
        self.useGeometry = useGeometry
        self.visible = visible
        self.collidables = collidables
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def useGeometry(self):
        """useGeometry indicates whether collision-detection code checks down to level of geometry, or only make approximations using geometry bounds."""
        return self.__useGeometry
    @useGeometry.setter
    def useGeometry(self, useGeometry):
        if  useGeometry is None:
            useGeometry = False  # default
        assertValidSFBool(useGeometry)
        self.__useGeometry = useGeometry
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def collidables(self):
        """[X3DNBodyCollisionSpaceNode,X3DNBodyCollidableNode] Collection of collidable objects as well as nested CollisionSpace collections."""
        return self.__collidables
    @collidables.setter
    def collidables(self, collidables):
        if  collidables is None:
            collidables = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(collidables)
        self.__collidables = collidables
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.collidables) > 0)
    # output function - - - - - - - - - -

class Color(_X3DColorNode):
    """
    Color node defines a set of RGB color values that apply either to a sibling Coordinate|CoordinateDouble node, or else to a parent ElevationGrid node.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Color'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#Color'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Color'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('color', [], FieldType.MFColor, AccessType.inputOutput, 'Color'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        color=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Color __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.color = color
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def color(self):
        """The color field defines an array of 3-tuple RGB colors."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = MFColor.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFColor.DEFAULT_VALUE()))
        assertValidMFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class ColorChaser(_X3DChaserNode):
    """
    ColorChaser generates a series of SFColor values that progressively change from initial value to destination value.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ColorChaser'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#ColorChaser'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ColorChaser'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('duration', 1, FieldType.SFTime, AccessType.initializeOnly, 'X3DChaserNode'),
        ('initialDestination', (0.8, 0.8, 0.8), FieldType.SFColor, AccessType.initializeOnly, 'ColorChaser'),
        ('initialValue', (0.8, 0.8, 0.8), FieldType.SFColor, AccessType.initializeOnly, 'ColorChaser'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        duration=1,
        initialDestination=(0.8, 0.8, 0.8),
        initialValue=(0.8, 0.8, 0.8),
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ColorChaser __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.duration = duration
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def duration(self):
        """[0,+infinity) duration is the time interval for filter response in seconds."""
        return self.__duration
    @duration.setter
    def duration(self, duration):
        if  duration is None:
            duration = 1  # default
        assertValidSFTime(duration)
        assertNonNegative('duration', duration)
        self.__duration = duration
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = (0.8, 0.8, 0.8)  # default
        assertValidSFColor(initialDestination)
        assertZeroToOne('initialDestination', initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = (0.8, 0.8, 0.8)  # default
        assertValidSFColor(initialValue)
        assertZeroToOne('initialValue', initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class ColorDamper(_X3DDamperNode):
    """
    ColorDamper generates a series of RGB color values that progressively change from initial value to destination value.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ColorDamper'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#ColorDamper'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ColorDamper'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('initialDestination', (0.8, 0.8, 0.8), FieldType.SFColor, AccessType.initializeOnly, 'ColorDamper'),
        ('initialValue', (0.8, 0.8, 0.8), FieldType.SFColor, AccessType.initializeOnly, 'ColorDamper'),
        ('order', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DDamperNode'),
        ('tau', 0.3, FieldType.SFTime, AccessType.inputOutput, 'X3DDamperNode'),
        ('tolerance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DDamperNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        initialDestination=(0.8, 0.8, 0.8),
        initialValue=(0.8, 0.8, 0.8),
        order=3,
        tau=0.3,
        tolerance=-1,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ColorDamper __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.order = order
        self.tau = tau
        self.tolerance = tolerance
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = (0.8, 0.8, 0.8)  # default
        assertValidSFColor(initialDestination)
        assertZeroToOne('initialDestination', initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = (0.8, 0.8, 0.8)  # default
        assertValidSFColor(initialValue)
        assertZeroToOne('initialValue', initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def order(self):
        """[0,5] order defines the number of internal filters (larger means smoother response, longer delay)."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3  # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 0)
        assertLessThanEquals('order', order, 5)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tau(self):
        """[0,+infinity) tau is the exponential-decay time constant for filter response in seconds."""
        return self.__tau
    @tau.setter
    def tau(self, tau):
        if  tau is None:
            tau = 0.3  # default
        assertValidSFTime(tau)
        assertNonNegative('tau', tau)
        self.__tau = tau
    @property # getter - - - - - - - - - -
    def tolerance(self):
        """[0,+infinity) or -1."""
        return self.__tolerance
    @tolerance.setter
    def tolerance(self, tolerance):
        if  tolerance is None:
            tolerance = -1  # default
        assertValidSFFloat(tolerance)
        self.__tolerance = tolerance
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class ColorInterpolator(_X3DInterpolatorNode):
    """
    ColorInterpolator generates a range of color values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ColorInterpolator'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#ColorInterpolator'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ColorInterpolator'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('key', [], FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
        ('keyValue', [], FieldType.MFColor, AccessType.inputOutput, 'ColorInterpolator'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        key=None,
        keyValue=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ColorInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFColor.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFColor.DEFAULT_VALUE()))
        assertValidMFColor(keyValue)
        assertZeroToOne('keyValue', keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class ColorRGBA(_X3DColorNode):
    """
    ColorRGBA node defines a set of RGBA color values that apply either to a sibling Coordinate|CoordinateDouble node, or else to a parent ElevationGrid node.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ColorRGBA'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#ColorRGBA'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ColorRGBA'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('color', [], FieldType.MFColorRGBA, AccessType.inputOutput, 'ColorRGBA'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        color=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ColorRGBA __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.color = color
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def color(self):
        """[0,1] The color field defines an array of 4-tuple RGBA colors."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = MFColorRGBA.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFColorRGBA.DEFAULT_VALUE()))
        assertValidMFColorRGBA(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class ComposedCubeMapTexture(_X3DEnvironmentTextureNode):
    """
    ComposedCubeMapTexture is a texture node that defines a cubic environment map source as an explicit set of images drawn from individual 2D texture nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ComposedCubeMapTexture'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalTexturing.html#ComposedCubeMapTexture'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ComposedCubeMapTexture'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureNode'),
        ('backTexture', None, FieldType.SFNode, AccessType.inputOutput, 'ComposedCubeMapTexture'),
        ('bottomTexture', None, FieldType.SFNode, AccessType.inputOutput, 'ComposedCubeMapTexture'),
        ('frontTexture', None, FieldType.SFNode, AccessType.inputOutput, 'ComposedCubeMapTexture'),
        ('leftTexture', None, FieldType.SFNode, AccessType.inputOutput, 'ComposedCubeMapTexture'),
        ('rightTexture', None, FieldType.SFNode, AccessType.inputOutput, 'ComposedCubeMapTexture'),
        ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly, 'ComposedCubeMapTexture'),
        ('topTexture', None, FieldType.SFNode, AccessType.inputOutput, 'ComposedCubeMapTexture'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        description='',
        backTexture=None,
        bottomTexture=None,
        frontTexture=None,
        leftTexture=None,
        rightTexture=None,
        textureProperties=None,
        topTexture=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ComposedCubeMapTexture __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.backTexture = backTexture
        self.bottomTexture = bottomTexture
        self.frontTexture = frontTexture
        self.leftTexture = leftTexture
        self.rightTexture = rightTexture
        self.textureProperties = textureProperties
        self.topTexture = topTexture
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def backTexture(self):
        """[X3DTexture2DNode] Parent ComposedCubeMapTexture element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture, other texture nodes)."""
        return self.__backTexture
    @backTexture.setter
    def backTexture(self, backTexture):
        if  backTexture is None:
            backTexture = None  # default
        assertValidSFNode(backTexture)
        if not backTexture is None and not isinstance(backTexture,(_X3DTexture2DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(backTexture) + ' does not match required node type (_X3DTexture2DNode,ProtoInstance) and is invalid')
        self.__backTexture = backTexture
    @property # getter - - - - - - - - - -
    def bottomTexture(self):
        """[X3DTexture2DNode] Parent ComposedCubeMapTexture element can contain up to six image nodes (ImageTexture PixelTexture, other texture nodes)."""
        return self.__bottomTexture
    @bottomTexture.setter
    def bottomTexture(self, bottomTexture):
        if  bottomTexture is None:
            bottomTexture = None  # default
        assertValidSFNode(bottomTexture)
        if not bottomTexture is None and not isinstance(bottomTexture,(_X3DTexture2DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(bottomTexture) + ' does not match required node type (_X3DTexture2DNode,ProtoInstance) and is invalid')
        self.__bottomTexture = bottomTexture
    @property # getter - - - - - - - - - -
    def frontTexture(self):
        """[X3DTexture2DNode] Parent ComposedCubeMapTexture element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture, other texture nodes)."""
        return self.__frontTexture
    @frontTexture.setter
    def frontTexture(self, frontTexture):
        if  frontTexture is None:
            frontTexture = None  # default
        assertValidSFNode(frontTexture)
        if not frontTexture is None and not isinstance(frontTexture,(_X3DTexture2DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(frontTexture) + ' does not match required node type (_X3DTexture2DNode,ProtoInstance) and is invalid')
        self.__frontTexture = frontTexture
    @property # getter - - - - - - - - - -
    def leftTexture(self):
        """[X3DTexture2DNode] Parent ComposedCubeMapTexture element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture, other texture nodese)."""
        return self.__leftTexture
    @leftTexture.setter
    def leftTexture(self, leftTexture):
        if  leftTexture is None:
            leftTexture = None  # default
        assertValidSFNode(leftTexture)
        if not leftTexture is None and not isinstance(leftTexture,(_X3DTexture2DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(leftTexture) + ' does not match required node type (_X3DTexture2DNode,ProtoInstance) and is invalid')
        self.__leftTexture = leftTexture
    @property # getter - - - - - - - - - -
    def rightTexture(self):
        """[X3DTexture2DNode] Parent ComposedCubeMapTexture element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture, other texture nodes)."""
        return self.__rightTexture
    @rightTexture.setter
    def rightTexture(self, rightTexture):
        if  rightTexture is None:
            rightTexture = None  # default
        assertValidSFNode(rightTexture)
        if not rightTexture is None and not isinstance(rightTexture,(_X3DTexture2DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(rightTexture) + ' does not match required node type (_X3DTexture2DNode,ProtoInstance) and is invalid')
        self.__rightTexture = rightTexture
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        """[TextureProperties] Single contained TextureProperties node that can specify additional visual attributes applied to corresponding texture images."""
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties):
        if  textureProperties is None:
            textureProperties = None  # default
        assertValidSFNode(textureProperties)
        if not textureProperties is None and not isinstance(textureProperties,(TextureProperties,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(textureProperties) + ' does not match required node type (TextureProperties,ProtoInstance) and is invalid')
        self.__textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def topTexture(self):
        """[X3DTexture2DNode] Parent ComposedCubeMapTexture element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture, other texture nodes)."""
        return self.__topTexture
    @topTexture.setter
    def topTexture(self, topTexture):
        if  topTexture is None:
            topTexture = None  # default
        assertValidSFNode(topTexture)
        if not topTexture is None and not isinstance(topTexture,(_X3DTexture2DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(topTexture) + ' does not match required node type (_X3DTexture2DNode,ProtoInstance) and is invalid')
        self.__topTexture = topTexture
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.backTexture or self.bottomTexture or self.frontTexture or self.IS or self.leftTexture or self.metadata or self.rightTexture or self.textureProperties or self.topTexture
    # output function - - - - - - - - - -

class ComposedShader(_X3DShaderNode):  # , _X3DProgrammableShaderObject  # TODO fix additional inheritance method resolution order (MRO)
    """
    ComposedShader can contain field declarations, but no CDATA section of plain-text source code, since programs are composed from child ShaderPart nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ComposedShader'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shaders.html#ComposedShader'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ComposedShader'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('language', '', FieldType.SFString, AccessType.initializeOnly, 'X3DShaderNode'),
        ('field', [], FieldType.MFNode, AccessType.inputOutput, 'ComposedShader'),
        ('parts', [], FieldType.MFNode, AccessType.inputOutput, 'ComposedShader'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'ComposedShader'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'ComposedShader'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        language='',
        field=None,
        parts=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ComposedShader __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.language = language
        self.field = field
        self.parts = parts
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def language(self):
        """The language field indicates to the X3D player which shading language is used."""
        return self.__language
    @language.setter
    def language(self, language):
        if  language is None:
            language = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(language)
        self.__language = language
    @property # getter - - - - - - - - - -
    def field(self):
        """Include a field statement for each field declaration in the ComposedShader node."""
        return self.__field
    @field.setter
    def field(self, field):
        if  field is None:
            field = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        # TODO type-aware checks for field
        if field: # walk each child in list, if any (avoid empty list recursion)
            for each in field:
                assertValidFieldInitializationValue(each.name, each.type, each.value, parent='ComposedShader')
        self.__field = field
    @property # getter - - - - - - - - - -
    def parts(self):
        """[ShaderPart] ComposedShader can contain multiple ShaderPart nodes in the parts field."""
        return self.__parts
    @parts.setter
    def parts(self, parts):
        if  parts is None:
            parts = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(parts)
        self.__parts = parts
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.field) > 0) or (len(self.parts) > 0)
    # output function - - - - - - - - - -

class ComposedTexture3D(_X3DTexture3DNode):
    """
    ComposedTexture3D defines a 3D image-based texture map as a collection of 2D texture sources at various depths.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ComposedTexture3D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texture3D.html#ComposedTexture3D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ComposedTexture3D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureNode'),
        ('repeatR', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture3DNode'),
        ('repeatS', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture3DNode'),
        ('repeatT', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture3DNode'),
        ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly, 'X3DTexture3DNode'),
        ('texture', [], FieldType.MFNode, AccessType.inputOutput, 'ComposedTexture3D'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        description='',
        repeatR=False,
        repeatS=False,
        repeatT=False,
        textureProperties=None,
        texture=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ComposedTexture3D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.repeatR = repeatR
        self.repeatS = repeatS
        self.repeatT = repeatT
        self.textureProperties = textureProperties
        self.texture = texture
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def repeatR(self):
        """Whether to repeat texture along R axis from front to back."""
        return self.__repeatR
    @repeatR.setter
    def repeatR(self, repeatR):
        if  repeatR is None:
            repeatR = False  # default
        assertValidSFBool(repeatR)
        self.__repeatR = repeatR
    @property # getter - - - - - - - - - -
    def repeatS(self):
        """Whether to repeat texture along S axis horizontally from left to right."""
        return self.__repeatS
    @repeatS.setter
    def repeatS(self, repeatS):
        if  repeatS is None:
            repeatS = False  # default
        assertValidSFBool(repeatS)
        self.__repeatS = repeatS
    @property # getter - - - - - - - - - -
    def repeatT(self):
        """Whether to repeat texture along T axis vertically from top to bottom."""
        return self.__repeatT
    @repeatT.setter
    def repeatT(self, repeatT):
        if  repeatT is None:
            repeatT = False  # default
        assertValidSFBool(repeatT)
        self.__repeatT = repeatT
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        """[TextureProperties] Single contained TextureProperties node that can specify additional visual attributes applied to corresponding texture images."""
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties):
        if  textureProperties is None:
            textureProperties = None  # default
        assertValidSFNode(textureProperties)
        if not textureProperties is None and not isinstance(textureProperties,(TextureProperties,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(textureProperties) + ' does not match required node type (TextureProperties,ProtoInstance) and is invalid')
        self.__textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def texture(self):
        """[X3DTexture2DNode] collection of 2D texture sources."""
        return self.__texture
    @texture.setter
    def texture(self, texture):
        if  texture is None:
            texture = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(texture)
        self.__texture = texture
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.textureProperties or (len(self.texture) > 0)
    # output function - - - - - - - - - -

class ComposedVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    ComposedVolumeStyle allows compositing multiple rendering styles into single rendering pass.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ComposedVolumeStyle'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#ComposedVolumeStyle'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ComposedVolumeStyle'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeRenderStyleNode'),
        ('renderStyle', [], FieldType.MFNode, AccessType.inputOutput, 'ComposedVolumeStyle'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        enabled=True,
        renderStyle=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ComposedVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.renderStyle = renderStyle
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def renderStyle(self):
        """[X3DComposableVolumeRenderStyleNode] List of contributing rendering style nodes or node references that can be applied to the object."""
        return self.__renderStyle
    @renderStyle.setter
    def renderStyle(self, renderStyle):
        if  renderStyle is None:
            renderStyle = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(renderStyle)
        self.__renderStyle = renderStyle
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.renderStyle) > 0)
    # output function - - - - - - - - - -

class Cone(_X3DGeometryNode):
    """
    Cone is a geometry node.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Cone'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry3D.html#Cone'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Cone'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bottom', True, FieldType.SFBool, AccessType.inputOutput, 'Cone'),
        ('bottomRadius', 1, FieldType.SFFloat, AccessType.initializeOnly, 'Cone'),
        ('height', 2, FieldType.SFFloat, AccessType.initializeOnly, 'Cone'),
        ('side', True, FieldType.SFBool, AccessType.inputOutput, 'Cone'),
        ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'Cone'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bottom=True,
        bottomRadius=1,
        height=2,
        side=True,
        solid=True,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Cone __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bottom = bottom
        self.bottomRadius = bottomRadius
        self.height = height
        self.side = side
        self.solid = solid
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bottom(self):
        """Whether to draw bottom (other inside faces are not drawn)."""
        return self.__bottom
    @bottom.setter
    def bottom(self, bottom):
        if  bottom is None:
            bottom = True  # default
        assertValidSFBool(bottom)
        self.__bottom = bottom
    @property # getter - - - - - - - - - -
    def bottomRadius(self):
        """(0,+infinity) Size in meters."""
        return self.__bottomRadius
    @bottomRadius.setter
    def bottomRadius(self, bottomRadius):
        if  bottomRadius is None:
            bottomRadius = 1  # default
        assertValidSFFloat(bottomRadius)
        assertPositive('bottomRadius', bottomRadius)
        self.__bottomRadius = bottomRadius
    @property # getter - - - - - - - - - -
    def height(self):
        """(0,+infinity) Size in meters."""
        return self.__height
    @height.setter
    def height(self, height):
        if  height is None:
            height = 2  # default
        assertValidSFFloat(height)
        assertPositive('height', height)
        self.__height = height
    @property # getter - - - - - - - - - -
    def side(self):
        """Whether to draw sides (other inside faces are not drawn)."""
        return self.__side
    @side.setter
    def side(self, side):
        if  side is None:
            side = True  # default
        assertValidSFBool(side)
        self.__side = side
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class ConeEmitter(_X3DParticleEmitterNode):
    """
    ConeEmitter generates all available particles from a specific point in space.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ConeEmitter'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#ConeEmitter'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ConeEmitter'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('angle', 0.7854, FieldType.SFFloat, AccessType.inputOutput, 'ConeEmitter'),
        ('direction', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'ConeEmitter'),
        ('mass', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('on', True, FieldType.SFBool, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('position', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'ConeEmitter'),
        ('speed', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('surfaceArea', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('variation', 0.25, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        angle=0.7854,
        direction=(0, 1, 0),
        mass=0,
        on=True,
        position=(0, 0, 0),
        speed=0,
        surfaceArea=0,
        variation=0.25,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ConeEmitter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.angle = angle
        self.direction = direction
        self.mass = mass
        self.on = on
        self.position = position
        self.speed = speed
        self.surfaceArea = surfaceArea
        self.variation = variation
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def angle(self):
        """[0,+infinity) Cone boundary for random distribution of particles about initial direction."""
        return self.__angle
    @angle.setter
    def angle(self, angle):
        if  angle is None:
            angle = 0.7854  # default
        assertValidSFFloat(angle)
        assertGreaterThanEquals('angle', angle, 0)
        assertLessThanEquals('angle', angle, 3.1416)
        self.__angle = angle
    @property # getter - - - - - - - - - -
    def direction(self):
        """Initial direction from which particles emanate."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (0, 1, 0)  # default
        assertValidSFVec3f(direction)
        assertGreaterThanEquals('direction', direction, -1)
        assertLessThanEquals('direction', direction, 1)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def mass(self):
        """[0,+infinity) Basic mass of each particle, defined in mass base units (default is kilograms)."""
        return self.__mass
    @mass.setter
    def mass(self, mass):
        if  mass is None:
            mass = 0  # default
        assertValidSFFloat(mass)
        assertNonNegative('mass', mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def on(self):
        """Enables/disables production of particles from this emitter node."""
        return self.__on
    @on.setter
    def on(self, on):
        if  on is None:
            on = True  # default
        assertValidSFBool(on)
        self.__on = on
    @property # getter - - - - - - - - - -
    def position(self):
        """Point from which particles emanate."""
        return self.__position
    @position.setter
    def position(self, position):
        if  position is None:
            position = (0, 0, 0)  # default
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def speed(self):
        """[0,+infinity) Initial linear speed (default is m/s) imparted to all particles along their direction of movement."""
        return self.__speed
    @speed.setter
    def speed(self, speed):
        if  speed is None:
            speed = 0  # default
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def surfaceArea(self):
        """[0,+infinity) Particle surface area in area base units (default is meters squared)."""
        return self.__surfaceArea
    @surfaceArea.setter
    def surfaceArea(self, surfaceArea):
        if  surfaceArea is None:
            surfaceArea = 0  # default
        assertValidSFFloat(surfaceArea)
        assertNonNegative('surfaceArea', surfaceArea)
        self.__surfaceArea = surfaceArea
    @property # getter - - - - - - - - - -
    def variation(self):
        """[0,+infinity) Multiplier for the randomness used to control the range of possible output values."""
        return self.__variation
    @variation.setter
    def variation(self, variation):
        if  variation is None:
            variation = 0.25  # default
        assertValidSFFloat(variation)
        assertNonNegative('variation', variation)
        self.__variation = variation
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class Contact(_X3DNode):
    """
    Contact nodes are produced as output events when two collidable objects or spaces make contact.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Contact'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#Contact'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Contact'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('appliedParameters', ["BOUNCE"], FieldType.MFString, AccessType.inputOutput, 'Contact'),
        ('bounce', 0, FieldType.SFFloat, AccessType.inputOutput, 'Contact'),
        ('contactNormal', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'Contact'),
        ('depth', 0, FieldType.SFFloat, AccessType.inputOutput, 'Contact'),
        ('frictionCoefficients', (0, 0), FieldType.SFVec2f, AccessType.inputOutput, 'Contact'),
        ('frictionDirection', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'Contact'),
        ('minBounceSpeed', 0, FieldType.SFFloat, AccessType.inputOutput, 'Contact'),
        ('position', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'Contact'),
        ('slipCoefficients', (0, 0), FieldType.SFVec2f, AccessType.inputOutput, 'Contact'),
        ('softnessConstantForceMix', 0.0001, FieldType.SFFloat, AccessType.inputOutput, 'Contact'),
        ('softnessErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'Contact'),
        ('surfaceSpeed', (0, 0), FieldType.SFVec2f, AccessType.inputOutput, 'Contact'),
        ('body1', None, FieldType.SFNode, AccessType.inputOutput, 'Contact'),
        ('body2', None, FieldType.SFNode, AccessType.inputOutput, 'Contact'),
        ('geometry1', None, FieldType.SFNode, AccessType.inputOutput, 'Contact'),
        ('geometry2', None, FieldType.SFNode, AccessType.inputOutput, 'Contact'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        appliedParameters=None,
        bounce=0,
        contactNormal=(0, 1, 0),
        depth=0,
        frictionCoefficients=(0, 0),
        frictionDirection=(0, 1, 0),
        minBounceSpeed=0,
        position=(0, 0, 0),
        slipCoefficients=(0, 0),
        softnessConstantForceMix=0.0001,
        softnessErrorCorrection=0.8,
        surfaceSpeed=(0, 0),
        body1=None,
        body2=None,
        geometry1=None,
        geometry2=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Contact __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.appliedParameters = appliedParameters
        self.bounce = bounce
        self.contactNormal = contactNormal
        self.depth = depth
        self.frictionCoefficients = frictionCoefficients
        self.frictionDirection = frictionDirection
        self.minBounceSpeed = minBounceSpeed
        self.position = position
        self.slipCoefficients = slipCoefficients
        self.softnessConstantForceMix = softnessConstantForceMix
        self.softnessErrorCorrection = softnessErrorCorrection
        self.surfaceSpeed = surfaceSpeed
        self.body1 = body1
        self.body2 = body2
        self.geometry1 = geometry1
        self.geometry2 = geometry2
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def appliedParameters(self):
        """Default global parameters for collision outputs of rigid body physics system."""
        return self.__appliedParameters
    @appliedParameters.setter
    def appliedParameters(self, appliedParameters):
        if  appliedParameters is None:
            appliedParameters = ["BOUNCE"]  # default
        assertValidMFString(appliedParameters)
        assertValidAppliedParameters('appliedParameters', appliedParameters)
        self.__appliedParameters = appliedParameters
    @property # getter - - - - - - - - - -
    def bounce(self):
        """[0,1] bounce indicates bounciness (0 = no bounce at all, 1 = maximum bounce)."""
        return self.__bounce
    @bounce.setter
    def bounce(self, bounce):
        if  bounce is None:
            bounce = 0  # default
        assertValidSFFloat(bounce)
        assertZeroToOne('bounce', bounce)
        self.__bounce = bounce
    @property # getter - - - - - - - - - -
    def contactNormal(self):
        """contactNormal is unit vector describing normal between two colliding bodies."""
        return self.__contactNormal
    @contactNormal.setter
    def contactNormal(self, contactNormal):
        if  contactNormal is None:
            contactNormal = (0, 1, 0)  # default
        assertValidSFVec3f(contactNormal)
        self.__contactNormal = contactNormal
    @property # getter - - - - - - - - - -
    def depth(self):
        """[0,1] depth indicates how deep the current intersection is along normal vector."""
        return self.__depth
    @depth.setter
    def depth(self, depth):
        if  depth is None:
            depth = 0  # default
        assertValidSFFloat(depth)
        self.__depth = depth
    @property # getter - - - - - - - - - -
    def frictionCoefficients(self):
        """frictionCoefficients used for computing surface drag."""
        return self.__frictionCoefficients
    @frictionCoefficients.setter
    def frictionCoefficients(self, frictionCoefficients):
        if  frictionCoefficients is None:
            frictionCoefficients = (0, 0)  # default
        assertValidSFVec2f(frictionCoefficients)
        assertNonNegative('frictionCoefficients', frictionCoefficients)
        self.__frictionCoefficients = frictionCoefficients
    @property # getter - - - - - - - - - -
    def frictionDirection(self):
        """frictionDirection controls friction vector."""
        return self.__frictionDirection
    @frictionDirection.setter
    def frictionDirection(self, frictionDirection):
        if  frictionDirection is None:
            frictionDirection = (0, 1, 0)  # default
        assertValidSFVec3f(frictionDirection)
        self.__frictionDirection = frictionDirection
    @property # getter - - - - - - - - - -
    def minBounceSpeed(self):
        """[0,+infinity) minBounceSpeed m/s needed to bounce."""
        return self.__minBounceSpeed
    @minBounceSpeed.setter
    def minBounceSpeed(self, minBounceSpeed):
        if  minBounceSpeed is None:
            minBounceSpeed = 0  # default
        assertValidSFFloat(minBounceSpeed)
        assertNonNegative('minBounceSpeed', minBounceSpeed)
        self.__minBounceSpeed = minBounceSpeed
    @property # getter - - - - - - - - - -
    def position(self):
        """position (x, y, z in meters) of exact location of collision."""
        return self.__position
    @position.setter
    def position(self, position):
        if  position is None:
            position = (0, 0, 0)  # default
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def slipCoefficients(self):
        """slipCoefficients used for computing surface drag."""
        return self.__slipCoefficients
    @slipCoefficients.setter
    def slipCoefficients(self, slipCoefficients):
        if  slipCoefficients is None:
            slipCoefficients = (0, 0)  # default
        assertValidSFVec2f(slipCoefficients)
        self.__slipCoefficients = slipCoefficients
    @property # getter - - - - - - - - - -
    def softnessConstantForceMix(self):
        """[0,1] softnessConstantForceMix value applies a constant force value to make colliding surfaces appear to be somewhat soft."""
        return self.__softnessConstantForceMix
    @softnessConstantForceMix.setter
    def softnessConstantForceMix(self, softnessConstantForceMix):
        if  softnessConstantForceMix is None:
            softnessConstantForceMix = 0.0001  # default
        assertValidSFFloat(softnessConstantForceMix)
        assertZeroToOne('softnessConstantForceMix', softnessConstantForceMix)
        self.__softnessConstantForceMix = softnessConstantForceMix
    @property # getter - - - - - - - - - -
    def softnessErrorCorrection(self):
        """[0,1] softnessErrorCorrection indicates fraction of collision error fixed in a set of evaluations (0 = no error correction, 1 = all errors corrected in single step)."""
        return self.__softnessErrorCorrection
    @softnessErrorCorrection.setter
    def softnessErrorCorrection(self, softnessErrorCorrection):
        if  softnessErrorCorrection is None:
            softnessErrorCorrection = 0.8  # default
        assertValidSFFloat(softnessErrorCorrection)
        assertZeroToOne('softnessErrorCorrection', softnessErrorCorrection)
        self.__softnessErrorCorrection = softnessErrorCorrection
    @property # getter - - - - - - - - - -
    def surfaceSpeed(self):
        """surfaceSpeed defines speed vectors for computing surface drag, if contact surfaces move independently of bodies."""
        return self.__surfaceSpeed
    @surfaceSpeed.setter
    def surfaceSpeed(self, surfaceSpeed):
        if  surfaceSpeed is None:
            surfaceSpeed = (0, 0)  # default
        assertValidSFVec2f(surfaceSpeed)
        self.__surfaceSpeed = surfaceSpeed
    @property # getter - - - - - - - - - -
    def body1(self):
        """[RigidBody] The body1 and body2 fields specify two top-level nodes that should be evaluated in the physics model as a single set of interactions with respect to each other."""
        return self.__body1
    @body1.setter
    def body1(self, body1):
        if  body1 is None:
            body1 = None  # default
        assertValidSFNode(body1)
        if not body1 is None and not isinstance(body1,(RigidBody,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(body1) + ' does not match required node type (RigidBody,ProtoInstance) and is invalid')
        self.__body1 = body1
    @property # getter - - - - - - - - - -
    def body2(self):
        """[RigidBody] The body1 and body2 fields specify two top-level nodes that should be evaluated in the physics model as a single set of interactions with respect to each other."""
        return self.__body2
    @body2.setter
    def body2(self, body2):
        if  body2 is None:
            body2 = None  # default
        assertValidSFNode(body2)
        if not body2 is None and not isinstance(body2,(RigidBody,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(body2) + ' does not match required node type (RigidBody,ProtoInstance) and is invalid')
        self.__body2 = body2
    @property # getter - - - - - - - - - -
    def geometry1(self):
        """[X3DNBodyCollidableNode] The geometry1 and geometry2 fields specify collision-related information about body1 and body2."""
        return self.__geometry1
    @geometry1.setter
    def geometry1(self, geometry1):
        if  geometry1 is None:
            geometry1 = None  # default
        assertValidSFNode(geometry1)
        if not geometry1 is None and not isinstance(geometry1,(_X3DNBodyCollidableNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(geometry1) + ' does not match required node type (_X3DNBodyCollidableNode,ProtoInstance) and is invalid')
        self.__geometry1 = geometry1
    @property # getter - - - - - - - - - -
    def geometry2(self):
        """[X3DNBodyCollidableNode] The geometry1 and geometry2 fields specify collision-related information about body1 and body2."""
        return self.__geometry2
    @geometry2.setter
    def geometry2(self, geometry2):
        if  geometry2 is None:
            geometry2 = None  # default
        assertValidSFNode(geometry2)
        if not geometry2 is None and not isinstance(geometry2,(_X3DNBodyCollidableNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(geometry2) + ' does not match required node type (_X3DNBodyCollidableNode,ProtoInstance) and is invalid')
        self.__geometry2 = geometry2
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.body1 or self.body2 or self.geometry1 or self.geometry2 or self.IS or self.metadata
    # output function - - - - - - - - - -

class Contour2D(_X3DNode):
    """
    Contour2D groups a set of curve segments into a composite contour.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Contour2D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#Contour2D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Contour2D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'Contour2D'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Contour2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def children(self):
        """[NurbsCurve2D|ContourPolyline2D] The children form a closed loop with first point of first child repeated as last point of last child, and the last point of a segment repeated as first point of the consecutive one."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class ContourPolyline2D(_X3DNurbsControlCurveNode):
    """
    ContourPolyline2D defines a linear curve segment as part of a trimming contour in the u-v domain of a NURBS surface.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ContourPolyline2D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#ContourPolyline2D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ContourPolyline2D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('controlPoint', [], FieldType.MFVec2d, AccessType.inputOutput, 'X3DNurbsControlCurveNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        controlPoint=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ContourPolyline2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.controlPoint = controlPoint
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        """controlPoint specifies the end points of each segment of the piecewise linear curve."""
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint):
        if  controlPoint is None:
            controlPoint = MFVec2d.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec2d.DEFAULT_VALUE()))
        assertValidMFVec2d(controlPoint)
        self.__controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class Convolver(_X3DSoundProcessingNode):
    """
    Convolver performs a linear convolution on a given AudioBuffer, often used to achieve a reverberation effect.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Convolver'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#Convolver'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Convolver'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('buffer', [], FieldType.MFFloat, AccessType.inputOutput, 'Convolver'),
        ('channelCountMode', 'MAX', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('channelInterpretation', 'SPEAKERS', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('normalize', False, FieldType.SFBool, AccessType.inputOutput, 'Convolver'),
        ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('tailTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'Convolver'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        buffer=None,
        channelCountMode='MAX',
        channelInterpretation='SPEAKERS',
        description='',
        enabled=True,
        gain=1,
        normalize=False,
        pauseTime=0,
        resumeTime=0,
        startTime=0,
        stopTime=0,
        tailTime=0,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Convolver __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.buffer = buffer
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.normalize = normalize
        self.pauseTime = pauseTime
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
        self.tailTime = tailTime
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def buffer(self):
        """buffer is a memory-resident audio asset that can contain one or more channels."""
        return self.__buffer
    @buffer.setter
    def buffer(self, buffer):
        if  buffer is None:
            buffer = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(buffer)
        assertGreaterThanEquals('buffer', buffer, -1)
        assertLessThanEquals('buffer', buffer, 1)
        self.__buffer = buffer
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'MAX'  # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'SPEAKERS'  # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1  # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def normalize(self):
        """normalize controls whether or not the impulse response from the buffer is scaled by an equal-power normalization when the buffer field is set."""
        return self.__normalize
    @normalize.setter
    def normalize(self, normalize):
        if  normalize is None:
            normalize = False  # default
        assertValidSFBool(normalize)
        self.__normalize = normalize
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0  # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0  # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0  # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0  # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def tailTime(self):
        """[0,+infinity) tailTime is duration of time that a node continues to provide output signal after the input signal becomes silent."""
        return self.__tailTime
    @tailTime.setter
    def tailTime(self, tailTime):
        if  tailTime is None:
            tailTime = 0  # default
        assertValidSFTime(tailTime)
        assertNonNegative('tailTime', tailTime)
        self.__tailTime = tailTime
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DSoundChannelNode|X3DSoundProcessingNode|X3DSoundSourceNode] The children field specifies audio-graph sound sources providing input signals for this node."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class Coordinate(_X3DCoordinateNode):
    """
    Coordinate builds geometry by defining a set of 3D coordinate (triplet) point values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Coordinate'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#Coordinate'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Coordinate'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('point', [], FieldType.MFVec3f, AccessType.inputOutput, 'Coordinate'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        point=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Coordinate __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.point = point
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def point(self):
        """point contains a set of 3D coordinate (triplet) point values."""
        return self.__point
    @point.setter
    def point(self, point):
        if  point is None:
            point = MFVec3f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec3f.DEFAULT_VALUE()))
        assertValidMFVec3f(point)
        self.__point = point
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class CoordinateChaser(_X3DChaserNode):
    """
    CoordinateChaser generates a series of coordinate arrays that progressively change from initial value to destination value.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'CoordinateChaser'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#CoordinateChaser'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CoordinateChaser'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('duration', 1, FieldType.SFTime, AccessType.initializeOnly, 'X3DChaserNode'),
        ('initialDestination', [(0, 0, 0)], FieldType.MFVec3f, AccessType.initializeOnly, 'CoordinateChaser'),
        ('initialValue', [(0, 0, 0)], FieldType.MFVec3f, AccessType.initializeOnly, 'CoordinateChaser'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        duration=1,
        initialDestination=None,
        initialValue=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode CoordinateChaser __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.duration = duration
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def duration(self):
        """[0,+infinity) duration is the time interval for filter response in seconds."""
        return self.__duration
    @duration.setter
    def duration(self, duration):
        if  duration is None:
            duration = 1  # default
        assertValidSFTime(duration)
        assertNonNegative('duration', duration)
        self.__duration = duration
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = [(0, 0, 0)]  # default
        assertValidMFVec3f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = [(0, 0, 0)]  # default
        assertValidMFVec3f(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class CoordinateDamper(_X3DDamperNode):
    """
    CoordinateDamper generates a series of coordinate arrays that progressively change from initial value to destination value.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'CoordinateDamper'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#CoordinateDamper'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CoordinateDamper'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('initialDestination', [(0, 0, 0)], FieldType.MFVec3f, AccessType.initializeOnly, 'CoordinateDamper'),
        ('initialValue', [(0, 0, 0)], FieldType.MFVec3f, AccessType.initializeOnly, 'CoordinateDamper'),
        ('order', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DDamperNode'),
        ('tau', 0.3, FieldType.SFTime, AccessType.inputOutput, 'X3DDamperNode'),
        ('tolerance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DDamperNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        initialDestination=None,
        initialValue=None,
        order=3,
        tau=0.3,
        tolerance=-1,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode CoordinateDamper __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.order = order
        self.tau = tau
        self.tolerance = tolerance
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = [(0, 0, 0)]  # default
        assertValidMFVec3f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = [(0, 0, 0)]  # default
        assertValidMFVec3f(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def order(self):
        """[0,5] order defines the number of internal filters (larger means smoother response, longer delay)."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3  # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 0)
        assertLessThanEquals('order', order, 5)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tau(self):
        """[0,+infinity) tau is the exponential-decay time constant for filter response in seconds."""
        return self.__tau
    @tau.setter
    def tau(self, tau):
        if  tau is None:
            tau = 0.3  # default
        assertValidSFTime(tau)
        assertNonNegative('tau', tau)
        self.__tau = tau
    @property # getter - - - - - - - - - -
    def tolerance(self):
        """[0,+infinity) or -1."""
        return self.__tolerance
    @tolerance.setter
    def tolerance(self, tolerance):
        if  tolerance is None:
            tolerance = -1  # default
        assertValidSFFloat(tolerance)
        self.__tolerance = tolerance
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class CoordinateDouble(_X3DCoordinateNode):
    """
    CoordinateDouble builds geometry by defining a set of 3D coordinate (triplet) point values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'CoordinateDouble'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#CoordinateDouble'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CoordinateDouble'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('point', [], FieldType.MFVec3d, AccessType.inputOutput, 'CoordinateDouble'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        point=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode CoordinateDouble __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.point = point
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def point(self):
        """point contains a set of 3D coordinate (triplet) point values."""
        return self.__point
    @point.setter
    def point(self, point):
        if  point is None:
            point = MFVec3d.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec3d.DEFAULT_VALUE()))
        assertValidMFVec3d(point)
        self.__point = point
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class CoordinateInterpolator(_X3DInterpolatorNode):
    """
    CoordinateInterpolator linearly interpolates among a list of 3-tuple MFVec3f arrays, producing a single MFVec3f array that is fractional average between two nearest arrays in the list.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'CoordinateInterpolator'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#CoordinateInterpolator'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CoordinateInterpolator'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('key', [], FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
        ('keyValue', [], FieldType.MFVec3f, AccessType.inputOutput, 'CoordinateInterpolator'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        key=None,
        keyValue=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode CoordinateInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFVec3f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec3f.DEFAULT_VALUE()))
        assertValidMFVec3f(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class CoordinateInterpolator2D(_X3DInterpolatorNode):
    """
    CoordinateInterpolator2D generates a series of SFVec2f or MFVec2f 2-tuple float values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'CoordinateInterpolator2D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#CoordinateInterpolator2D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CoordinateInterpolator2D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('key', [], FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
        ('keyValue', [], FieldType.MFVec2f, AccessType.inputOutput, 'CoordinateInterpolator2D'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        key=None,
        keyValue=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode CoordinateInterpolator2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFVec2f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec2f.DEFAULT_VALUE()))
        assertValidMFVec2f(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class Cylinder(_X3DGeometryNode):
    """
    Cylinder is a geometry node.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Cylinder'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry3D.html#Cylinder'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Cylinder'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bottom', True, FieldType.SFBool, AccessType.inputOutput, 'Cylinder'),
        ('height', 2, FieldType.SFFloat, AccessType.initializeOnly, 'Cylinder'),
        ('radius', 1, FieldType.SFFloat, AccessType.initializeOnly, 'Cylinder'),
        ('side', True, FieldType.SFBool, AccessType.inputOutput, 'Cylinder'),
        ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'Cylinder'),
        ('top', True, FieldType.SFBool, AccessType.inputOutput, 'Cylinder'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bottom=True,
        height=2,
        radius=1,
        side=True,
        solid=True,
        top=True,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Cylinder __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bottom = bottom
        self.height = height
        self.radius = radius
        self.side = side
        self.solid = solid
        self.top = top
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bottom(self):
        """Whether to draw bottom (inside faces are never drawn)."""
        return self.__bottom
    @bottom.setter
    def bottom(self, bottom):
        if  bottom is None:
            bottom = True  # default
        assertValidSFBool(bottom)
        self.__bottom = bottom
    @property # getter - - - - - - - - - -
    def height(self):
        """(0,+infinity) Size in meters."""
        return self.__height
    @height.setter
    def height(self, height):
        if  height is None:
            height = 2  # default
        assertValidSFFloat(height)
        assertPositive('height', height)
        self.__height = height
    @property # getter - - - - - - - - - -
    def radius(self):
        """(0,+infinity) Size in meters."""
        return self.__radius
    @radius.setter
    def radius(self, radius):
        if  radius is None:
            radius = 1  # default
        assertValidSFFloat(radius)
        assertPositive('radius', radius)
        self.__radius = radius
    @property # getter - - - - - - - - - -
    def side(self):
        """Whether to draw sides (inside faces are never drawn)."""
        return self.__side
    @side.setter
    def side(self, side):
        if  side is None:
            side = True  # default
        assertValidSFBool(side)
        self.__side = side
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def top(self):
        """Whether to draw top (inside faces are never drawn)."""
        return self.__top
    @top.setter
    def top(self, top):
        if  top is None:
            top = True  # default
        assertValidSFBool(top)
        self.__top = top
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class CylinderSensor(_X3DDragSensorNode):
    """
    CylinderSensor converts pointer motion (for example, a mouse or wand) into rotation values using an invisible cylinder aligned with local Y-axis.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'CylinderSensor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/pointingDeviceSensor.html#CylinderSensor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CylinderSensor'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('autoOffset', True, FieldType.SFBool, AccessType.inputOutput, 'X3DDragSensorNode'),
        ('axisRotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'CylinderSensor'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSensorNode'),
        ('diskAngle', 0.26179167, FieldType.SFFloat, AccessType.inputOutput, 'CylinderSensor'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('maxAngle', -1, FieldType.SFFloat, AccessType.inputOutput, 'CylinderSensor'),
        ('minAngle', 0, FieldType.SFFloat, AccessType.inputOutput, 'CylinderSensor'),
        ('offset', 0, FieldType.SFFloat, AccessType.inputOutput, 'CylinderSensor'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        autoOffset=True,
        axisRotation=(0, 0, 1, 0),
        description='',
        diskAngle=0.26179167,
        enabled=True,
        maxAngle=-1,
        minAngle=0,
        offset=0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode CylinderSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.autoOffset = autoOffset
        self.axisRotation = axisRotation
        self.description = description
        self.diskAngle = diskAngle
        self.enabled = enabled
        self.maxAngle = maxAngle
        self.minAngle = minAngle
        self.offset = offset
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def autoOffset(self):
        """determines whether previous offset values are remembered/accumulated."""
        return self.__autoOffset
    @autoOffset.setter
    def autoOffset(self, autoOffset):
        if  autoOffset is None:
            autoOffset = True  # default
        assertValidSFBool(autoOffset)
        self.__autoOffset = autoOffset
    @property # getter - - - - - - - - - -
    def axisRotation(self):
        """axisRotation determines local sensor coordinate system by rotating the local coordinate system."""
        return self.__axisRotation
    @axisRotation.setter
    def axisRotation(self, axisRotation):
        if  axisRotation is None:
            axisRotation = (0, 0, 1, 0)  # default
        assertValidSFRotation(axisRotation)
        self.__axisRotation = axisRotation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def diskAngle(self):
        """Help decide rotation behavior from initial relative bearing of pointer drag: acute angle whether cylinder sides or end-cap disks of virtual-geometry sensor are used for manipulation."""
        return self.__diskAngle
    @diskAngle.setter
    def diskAngle(self, diskAngle):
        if  diskAngle is None:
            diskAngle = 0.26179167  # default
        assertValidSFFloat(diskAngle)
        assertGreaterThanEquals('diskAngle', diskAngle, 0)
        assertLessThanEquals('diskAngle', diskAngle, 1.5708)
        self.__diskAngle = diskAngle
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def maxAngle(self):
        """clamps rotation_changed events within range of min/max values Hint: if minAngle > maxAngle, rotation is not clamped."""
        return self.__maxAngle
    @maxAngle.setter
    def maxAngle(self, maxAngle):
        if  maxAngle is None:
            maxAngle = -1  # default
        assertValidSFFloat(maxAngle)
        assertGreaterThan('maxAngle', maxAngle, -6.2832)
        assertLessThan('maxAngle', maxAngle, 6.2832)
        self.__maxAngle = maxAngle
    @property # getter - - - - - - - - - -
    def minAngle(self):
        """clamps rotation_changed events within range of min/max values Hint: if minAngle > maxAngle, rotation is not clamped."""
        return self.__minAngle
    @minAngle.setter
    def minAngle(self, minAngle):
        if  minAngle is None:
            minAngle = 0  # default
        assertValidSFFloat(minAngle)
        assertGreaterThan('minAngle', minAngle, -6.2832)
        assertLessThan('minAngle', minAngle, 6.2832)
        self.__minAngle = minAngle
    @property # getter - - - - - - - - - -
    def offset(self):
        """Sends event and remembers last value sensed."""
        return self.__offset
    @offset.setter
    def offset(self, offset):
        if  offset is None:
            offset = 0  # default
        assertValidSFFloat(offset)
        self.__offset = offset
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class Delay(_X3DSoundProcessingNode):
    """
    Delay causes a time delay between the arrival of input data and subsequent propagation to the output.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Delay'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#Delay'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Delay'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('channelCountMode', 'MAX', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('channelInterpretation', 'SPEAKERS', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('delayTime', 0, FieldType.SFTime, AccessType.inputOutput, 'Delay'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('maxDelayTime', 1, FieldType.SFTime, AccessType.inputOutput, 'Delay'),
        ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('tailTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'Delay'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        channelCountMode='MAX',
        channelInterpretation='SPEAKERS',
        delayTime=0,
        description='',
        enabled=True,
        gain=1,
        maxDelayTime=1,
        pauseTime=0,
        resumeTime=0,
        startTime=0,
        stopTime=0,
        tailTime=0,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Delay __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.delayTime = delayTime
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.maxDelayTime = maxDelayTime
        self.pauseTime = pauseTime
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
        self.tailTime = tailTime
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'MAX'  # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'SPEAKERS'  # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def delayTime(self):
        """[0,+infinity) delayTime is duration of delay (in seconds) to apply."""
        return self.__delayTime
    @delayTime.setter
    def delayTime(self, delayTime):
        if  delayTime is None:
            delayTime = 0  # default
        assertValidSFTime(delayTime)
        assertNonNegative('delayTime', delayTime)
        self.__delayTime = delayTime
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1  # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def maxDelayTime(self):
        """[0,+infinity) maxDelayTime is duration of maximum amount of delay (in seconds) that can be applied."""
        return self.__maxDelayTime
    @maxDelayTime.setter
    def maxDelayTime(self, maxDelayTime):
        if  maxDelayTime is None:
            maxDelayTime = 1  # default
        assertValidSFTime(maxDelayTime)
        assertNonNegative('maxDelayTime', maxDelayTime)
        self.__maxDelayTime = maxDelayTime
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0  # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0  # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0  # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0  # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def tailTime(self):
        """[0,+infinity) tailTime is duration of time that a node continues to provide output signal after the input signal becomes silent."""
        return self.__tailTime
    @tailTime.setter
    def tailTime(self, tailTime):
        if  tailTime is None:
            tailTime = 0  # default
        assertValidSFTime(tailTime)
        assertNonNegative('tailTime', tailTime)
        self.__tailTime = tailTime
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DSoundChannelNode|X3DSoundProcessingNode|X3DSoundSourceNode] The children field specifies audio-graph sound sources providing input signals for this node."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class DirectionalLight(_X3DLightNode):
    """
    DirectionalLight might not be scoped by parent Group or Transform at levels 1 or 2.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'DirectionalLight'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/lighting.html#DirectionalLight'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#DirectionalLight'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('ambientIntensity', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
        ('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'X3DLightNode'),
        ('direction', (0, 0, -1), FieldType.SFVec3f, AccessType.inputOutput, 'DirectionalLight'),
        ('global_', False, FieldType.SFBool, AccessType.inputOutput, 'DirectionalLight'),
        ('intensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
        ('on', True, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
        ('shadowIntensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
        ('shadows', False, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        ambientIntensity=0,
        color=(1, 1, 1),
        direction=(0, 0, -1),
        global_=False,
        intensity=1,
        on=True,
        shadowIntensity=1,
        shadows=False,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode DirectionalLight __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ambientIntensity = ambientIntensity
        self.color = color
        self.direction = direction
        self.global_ = global_
        self.intensity = intensity
        self.on = on
        self.shadowIntensity = shadowIntensity
        self.shadows = shadows
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def ambientIntensity(self):
        """[0,1] Brightness of ambient (nondirectional background) emission from the light."""
        return self.__ambientIntensity
    @ambientIntensity.setter
    def ambientIntensity(self, ambientIntensity):
        if  ambientIntensity is None:
            ambientIntensity = 0  # default
        assertValidSFFloat(ambientIntensity)
        assertZeroToOne('ambientIntensity', ambientIntensity)
        self.__ambientIntensity = ambientIntensity
    @property # getter - - - - - - - - - -
    def color(self):
        """[0,1] color of light, applied to colors of objects."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = (1, 1, 1)  # default
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def direction(self):
        """Orientation vector of light relative to local coordinate system."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (0, 0, -1)  # default
        assertValidSFVec3f(direction)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def global_(self):
        """Global lights illuminate all objects within their volume of lighting influence."""
        return self.__global_
    @global_.setter
    def global_(self, global_):
        if  global_ is None:
            global_ = False  # default
        assertValidSFBool(global_)
        self.__global_ = global_
    @property # getter - - - - - - - - - -
    def intensity(self):
        """[0,+infinity] Brightness of direct emission from the light."""
        return self.__intensity
    @intensity.setter
    def intensity(self, intensity):
        if  intensity is None:
            intensity = 1  # default
        assertValidSFFloat(intensity)
        assertNonNegative('intensity', intensity)
        self.__intensity = intensity
    @property # getter - - - - - - - - - -
    def on(self):
        """Enables/disables this light source."""
        return self.__on
    @on.setter
    def on(self, on):
        if  on is None:
            on = True  # default
        assertValidSFBool(on)
        self.__on = on
    @property # getter - - - - - - - - - -
    def shadowIntensity(self):
        """[0,1] shadowIntensity field defines how much light is obscured by shapes that cast shadows, ranging from 0 (light not obscured, no visible shadows) to 1 (light completely obscured, full-intensity shadows)."""
        return self.__shadowIntensity
    @shadowIntensity.setter
    def shadowIntensity(self, shadowIntensity):
        if  shadowIntensity is None:
            shadowIntensity = 1  # default
        assertValidSFFloat(shadowIntensity)
        assertZeroToOne('shadowIntensity', shadowIntensity)
        self.__shadowIntensity = shadowIntensity
    @property # getter - - - - - - - - - -
    def shadows(self):
        """shadows field indicates whether or not this light casts a shadow behind illuminated X3DShapeNode geometry."""
        return self.__shadows
    @shadows.setter
    def shadows(self, shadows):
        if  shadows is None:
            shadows = False  # default
        assertValidSFBool(shadows)
        self.__shadows = shadows
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class DISEntityManager(_X3DChildNode):
    """
    DISEntityManager notifies a scene when new DIS ESPDU entities arrive or current entities leave.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'DISEntityManager'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/dis.html#DISEntityManager'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#DISEntityManager'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('address', 'localhost', FieldType.SFString, AccessType.inputOutput, 'DISEntityManager'),
        ('applicationID', 0, FieldType.SFInt32, AccessType.inputOutput, 'DISEntityManager'),
        ('port', 0, FieldType.SFInt32, AccessType.inputOutput, 'DISEntityManager'),
        ('siteID', 0, FieldType.SFInt32, AccessType.inputOutput, 'DISEntityManager'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'DISEntityManager'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        address='localhost',
        applicationID=0,
        port=0,
        siteID=0,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode DISEntityManager __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.address = address
        self.applicationID = applicationID
        self.port = port
        self.siteID = siteID
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def address(self):
        """Multicast network address, or else 'localhost'."""
        return self.__address
    @address.setter
    def address(self, address):
        if  address is None:
            address = 'localhost'  # default
        assertValidSFString(address)
        self.__address = address
    @property # getter - - - - - - - - - -
    def applicationID(self):
        """Each simulation application that can respond to simulation management PDUs needs to have a unique applicationID."""
        return self.__applicationID
    @applicationID.setter
    def applicationID(self, applicationID):
        if  applicationID is None:
            applicationID = 0  # default
        assertValidSFInt32(applicationID)
        self.__applicationID = applicationID
    @property # getter - - - - - - - - - -
    def port(self):
        """Multicast network port, for example: 3000."""
        return self.__port
    @port.setter
    def port(self, port):
        if  port is None:
            port = 0  # default
        assertValidSFInt32(port)
        self.__port = port
    @property # getter - - - - - - - - - -
    def siteID(self):
        """Simulation/exercise siteID of the participating LAN or organization."""
        return self.__siteID
    @siteID.setter
    def siteID(self, siteID):
        if  siteID is None:
            siteID = 0  # default
        assertValidSFInt32(siteID)
        self.__siteID = siteID
    @property # getter - - - - - - - - - -
    def children(self):
        """[DISEntityTypeMapping] mapping field provides a mechanism for automatically creating an X3D model when a new entity arrives over the network."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class DISEntityTypeMapping(_X3DInfoNode, _X3DUrlObject):
    """
    DISEntityTypeMapping provides a best-match mapping from DIS ESPDU entity type information to a specific X3D model, thus providing a visual and behavioral representation that best matches the entity type.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'DISEntityTypeMapping'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/dis.html#DISEntityTypeMapping'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#DISEntityTypeMapping'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('autoRefresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('autoRefreshTimeLimit', 3600, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('category', 0, FieldType.SFInt32, AccessType.initializeOnly, 'DISEntityTypeMapping'),
        ('country', 0, FieldType.SFInt32, AccessType.initializeOnly, 'DISEntityTypeMapping'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DUrlObject'),
        ('domain', 0, FieldType.SFInt32, AccessType.initializeOnly, 'DISEntityTypeMapping'),
        ('extra', 0, FieldType.SFInt32, AccessType.initializeOnly, 'DISEntityTypeMapping'),
        ('kind', 0, FieldType.SFInt32, AccessType.initializeOnly, 'DISEntityTypeMapping'),
        ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
        ('specific', 0, FieldType.SFInt32, AccessType.initializeOnly, 'DISEntityTypeMapping'),
        ('subcategory', 0, FieldType.SFInt32, AccessType.initializeOnly, 'DISEntityTypeMapping'),
        ('url', [], FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        autoRefresh=0,
        autoRefreshTimeLimit=3600,
        category=0,
        country=0,
        description='',
        domain=0,
        extra=0,
        kind=0,
        load=True,
        specific=0,
        subcategory=0,
        url=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode DISEntityTypeMapping __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.autoRefresh = autoRefresh
        self.autoRefreshTimeLimit = autoRefreshTimeLimit
        self.category = category
        self.country = country
        self.description = description
        self.domain = domain
        self.extra = extra
        self.kind = kind
        self.load = load
        self.specific = specific
        self.subcategory = subcategory
        self.url = url
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def autoRefresh(self):
        """autoRefresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__autoRefresh
    @autoRefresh.setter
    def autoRefresh(self, autoRefresh):
        if  autoRefresh is None:
            autoRefresh = 0  # default
        assertValidSFTime(autoRefresh)
        assertNonNegative('autoRefresh', autoRefresh)
        self.__autoRefresh = autoRefresh
    @property # getter - - - - - - - - - -
    def autoRefreshTimeLimit(self):
        """autoRefreshTimeLimit defines maximum duration that automatic refresh activity can occur."""
        return self.__autoRefreshTimeLimit
    @autoRefreshTimeLimit.setter
    def autoRefreshTimeLimit(self, autoRefreshTimeLimit):
        if  autoRefreshTimeLimit is None:
            autoRefreshTimeLimit = 3600  # default
        assertValidSFTime(autoRefreshTimeLimit)
        assertNonNegative('autoRefreshTimeLimit', autoRefreshTimeLimit)
        self.__autoRefreshTimeLimit = autoRefreshTimeLimit
    @property # getter - - - - - - - - - -
    def category(self):
        """Integer enumerations value for main category that describes the entity, semantics of each code varies according to domain."""
        return self.__category
    @category.setter
    def category(self, category):
        if  category is None:
            category = 0  # default
        assertValidSFInt32(category)
        assertGreaterThanEquals('category', category, 0)
        assertLessThanEquals('category', category, 255)
        self.__category = category
    @property # getter - - - - - - - - - -
    def country(self):
        """Integer enumerations value for country to which the design of the entity or its design specification is attributed."""
        return self.__country
    @country.setter
    def country(self, country):
        if  country is None:
            country = 0  # default
        assertValidSFInt32(country)
        assertGreaterThanEquals('country', country, 0)
        assertLessThanEquals('country', country, 65535)
        self.__country = country
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def domain(self):
        """Integer enumerations value for domain in which the entity operates: LAND, AIR, SURFACE, SUBSURFACE, SPACE or OTHER."""
        return self.__domain
    @domain.setter
    def domain(self, domain):
        if  domain is None:
            domain = 0  # default
        assertValidSFInt32(domain)
        assertGreaterThanEquals('domain', domain, 0)
        assertLessThanEquals('domain', domain, 255)
        self.__domain = domain
    @property # getter - - - - - - - - - -
    def extra(self):
        """Any extra information required to describe a particular entity."""
        return self.__extra
    @extra.setter
    def extra(self, extra):
        if  extra is None:
            extra = 0  # default
        assertValidSFInt32(extra)
        assertGreaterThanEquals('extra', extra, 0)
        assertLessThanEquals('extra', extra, 255)
        self.__extra = extra
    @property # getter - - - - - - - - - -
    def kind(self):
        """Integer enumerations value for whether entity is a PLATFORM, MUNITION, LIFE_FORM, ENVIRONMENTAL, CULTURAL_FEATURE, SUPPLY, RADIO, EXPENDABLE, SENSOR_EMITTER or OTHER."""
        return self.__kind
    @kind.setter
    def kind(self, kind):
        if  kind is None:
            kind = 0  # default
        assertValidSFInt32(kind)
        assertGreaterThanEquals('kind', kind, 0)
        assertLessThanEquals('kind', kind, 255)
        self.__kind = kind
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True  # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def specific(self):
        """Specific information about an entity based on the subcategory field."""
        return self.__specific
    @specific.setter
    def specific(self, specific):
        if  specific is None:
            specific = 0  # default
        assertValidSFInt32(specific)
        assertGreaterThanEquals('specific', specific, 0)
        assertLessThanEquals('specific', specific, 255)
        self.__specific = specific
    @property # getter - - - - - - - - - -
    def subcategory(self):
        """Integer enumerations value for particular subcategory to which an entity belongs based on the category field."""
        return self.__subcategory
    @subcategory.setter
    def subcategory(self, subcategory):
        if  subcategory is None:
            subcategory = 0  # default
        assertValidSFInt32(subcategory)
        assertGreaterThanEquals('subcategory', subcategory, 0)
        assertLessThanEquals('subcategory', subcategory, 255)
        self.__subcategory = subcategory
    @property # getter - - - - - - - - - -
    def url(self):
        """Local and/or online addresses of X3D model of interest, for example: "ExtrusionExampleShip."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class Disk2D(_X3DGeometryNode):
    """
    Disk2D is a geometry node that defines a filled (or partially filled) planar circle with center (0,0).
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Disk2D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry2D.html#Disk2D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Disk2D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('innerRadius', 0, FieldType.SFFloat, AccessType.initializeOnly, 'Disk2D'),
        ('outerRadius', 1, FieldType.SFFloat, AccessType.initializeOnly, 'Disk2D'),
        ('solid', False, FieldType.SFBool, AccessType.initializeOnly, 'Disk2D'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        innerRadius=0,
        outerRadius=1,
        solid=False,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Disk2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.innerRadius = innerRadius
        self.outerRadius = outerRadius
        self.solid = solid
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def innerRadius(self):
        """[0,+infinity) Inner circle radius, greater than or equal to 0."""
        return self.__innerRadius
    @innerRadius.setter
    def innerRadius(self, innerRadius):
        if  innerRadius is None:
            innerRadius = 0  # default
        assertValidSFFloat(innerRadius)
        assertNonNegative('innerRadius', innerRadius)
        self.__innerRadius = innerRadius
    @property # getter - - - - - - - - - -
    def outerRadius(self):
        """(0,+infinity) Outer radius of circle, greater than or equal to inner radius."""
        return self.__outerRadius
    @outerRadius.setter
    def outerRadius(self, outerRadius):
        if  outerRadius is None:
            outerRadius = 1  # default
        assertValidSFFloat(outerRadius)
        assertPositive('outerRadius', outerRadius)
        self.__outerRadius = outerRadius
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = False  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class DoubleAxisHingeJoint(_X3DRigidJointNode):
    """
    DoubleAxisHingeJoint has two independent axes located around a common anchor point.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'DoubleAxisHingeJoint'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#DoubleAxisHingeJoint'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#DoubleAxisHingeJoint'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('anchorPoint', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
        ('axis1', (1, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
        ('axis2', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
        ('desiredAngularVelocity1', 0, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
        ('desiredAngularVelocity2', 0, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
        ('forceOutput', ["NONE"], FieldType.MFString, AccessType.inputOutput, 'X3DRigidJointNode'),
        ('maxAngle1', 3.141592653, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
        ('maxTorque1', 0, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
        ('maxTorque2', 0, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
        ('minAngle1', -3.141592653, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
        ('stop1Bounce', 0, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
        ('stop1ConstantForceMix', 0.001, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
        ('stop1ErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
        ('suspensionErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
        ('suspensionForce', 0, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
        ('body1', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
        ('body2', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        anchorPoint=(0, 0, 0),
        axis1=(1, 0, 0),
        axis2=(0, 1, 0),
        desiredAngularVelocity1=0,
        desiredAngularVelocity2=0,
        forceOutput=None,
        maxAngle1=3.141592653,
        maxTorque1=0,
        maxTorque2=0,
        minAngle1=-3.141592653,
        stop1Bounce=0,
        stop1ConstantForceMix=0.001,
        stop1ErrorCorrection=0.8,
        suspensionErrorCorrection=0.8,
        suspensionForce=0,
        body1=None,
        body2=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode DoubleAxisHingeJoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.anchorPoint = anchorPoint
        self.axis1 = axis1
        self.axis2 = axis2
        self.desiredAngularVelocity1 = desiredAngularVelocity1
        self.desiredAngularVelocity2 = desiredAngularVelocity2
        self.forceOutput = forceOutput
        self.maxAngle1 = maxAngle1
        self.maxTorque1 = maxTorque1
        self.maxTorque2 = maxTorque2
        self.minAngle1 = minAngle1
        self.stop1Bounce = stop1Bounce
        self.stop1ConstantForceMix = stop1ConstantForceMix
        self.stop1ErrorCorrection = stop1ErrorCorrection
        self.suspensionErrorCorrection = suspensionErrorCorrection
        self.suspensionForce = suspensionForce
        self.body1 = body1
        self.body2 = body2
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def anchorPoint(self):
        """anchorPoint is joint center, specified in world coordinates."""
        return self.__anchorPoint
    @anchorPoint.setter
    def anchorPoint(self, anchorPoint):
        if  anchorPoint is None:
            anchorPoint = (0, 0, 0)  # default
        assertValidSFVec3f(anchorPoint)
        self.__anchorPoint = anchorPoint
    @property # getter - - - - - - - - - -
    def axis1(self):
        """axis1 defines axis vector of joint connection to body1."""
        return self.__axis1
    @axis1.setter
    def axis1(self, axis1):
        if  axis1 is None:
            axis1 = (1, 0, 0)  # default
        assertValidSFVec3f(axis1)
        self.__axis1 = axis1
    @property # getter - - - - - - - - - -
    def axis2(self):
        """axis2 defines axis vector of joint connection to body2."""
        return self.__axis2
    @axis2.setter
    def axis2(self, axis2):
        if  axis2 is None:
            axis2 = (0, 1, 0)  # default
        assertValidSFVec3f(axis2)
        self.__axis2 = axis2
    @property # getter - - - - - - - - - -
    def desiredAngularVelocity1(self):
        """desiredAngularVelocity1 is goal rotation rate for hinge connection to body1."""
        return self.__desiredAngularVelocity1
    @desiredAngularVelocity1.setter
    def desiredAngularVelocity1(self, desiredAngularVelocity1):
        if  desiredAngularVelocity1 is None:
            desiredAngularVelocity1 = 0  # default
        assertValidSFFloat(desiredAngularVelocity1)
        self.__desiredAngularVelocity1 = desiredAngularVelocity1
    @property # getter - - - - - - - - - -
    def desiredAngularVelocity2(self):
        """desiredAngularVelocity2 is goal rotation rate for hinge connection to body2."""
        return self.__desiredAngularVelocity2
    @desiredAngularVelocity2.setter
    def desiredAngularVelocity2(self, desiredAngularVelocity2):
        if  desiredAngularVelocity2 is None:
            desiredAngularVelocity2 = 0  # default
        assertValidSFFloat(desiredAngularVelocity2)
        self.__desiredAngularVelocity2 = desiredAngularVelocity2
    @property # getter - - - - - - - - - -
    def forceOutput(self):
        """forceOutput controls which output fields are generated for the next frame."""
        return self.__forceOutput
    @forceOutput.setter
    def forceOutput(self, forceOutput):
        if  forceOutput is None:
            forceOutput = ["NONE"]  # default
        assertValidMFString(forceOutput)
        self.__forceOutput = forceOutput
    @property # getter - - - - - - - - - -
    def maxAngle1(self):
        """[-pi,pi] maxAngle1 is maximum rotation angle for hinge."""
        return self.__maxAngle1
    @maxAngle1.setter
    def maxAngle1(self, maxAngle1):
        if  maxAngle1 is None:
            maxAngle1 = 3.141592653  # default
        assertValidSFFloat(maxAngle1)
        self.__maxAngle1 = maxAngle1
    @property # getter - - - - - - - - - -
    def maxTorque1(self):
        """maxTorque1 is maximum rotational torque applied by corresponding motor axis to achieve desiredAngularVelocity1."""
        return self.__maxTorque1
    @maxTorque1.setter
    def maxTorque1(self, maxTorque1):
        if  maxTorque1 is None:
            maxTorque1 = 0  # default
        assertValidSFFloat(maxTorque1)
        self.__maxTorque1 = maxTorque1
    @property # getter - - - - - - - - - -
    def maxTorque2(self):
        """maxTorque2 is maximum rotational torque applied by corresponding motor axis to achieve desiredAngularVelocity2."""
        return self.__maxTorque2
    @maxTorque2.setter
    def maxTorque2(self, maxTorque2):
        if  maxTorque2 is None:
            maxTorque2 = 0  # default
        assertValidSFFloat(maxTorque2)
        self.__maxTorque2 = maxTorque2
    @property # getter - - - - - - - - - -
    def minAngle1(self):
        """[-pi,pi] minAngle1 is minimum rotation angle for hinge."""
        return self.__minAngle1
    @minAngle1.setter
    def minAngle1(self, minAngle1):
        if  minAngle1 is None:
            minAngle1 = -3.141592653  # default
        assertValidSFFloat(minAngle1)
        self.__minAngle1 = minAngle1
    @property # getter - - - - - - - - - -
    def stop1Bounce(self):
        """[0,1] stop1Bounce is velocity factor for bounce back once stop point is reached."""
        return self.__stop1Bounce
    @stop1Bounce.setter
    def stop1Bounce(self, stop1Bounce):
        if  stop1Bounce is None:
            stop1Bounce = 0  # default
        assertValidSFFloat(stop1Bounce)
        self.__stop1Bounce = stop1Bounce
    @property # getter - - - - - - - - - -
    def stop1ConstantForceMix(self):
        """[0,1] stop1ConstantForceMix value applies a constant force value to make colliding surfaces appear to be somewhat soft."""
        return self.__stop1ConstantForceMix
    @stop1ConstantForceMix.setter
    def stop1ConstantForceMix(self, stop1ConstantForceMix):
        if  stop1ConstantForceMix is None:
            stop1ConstantForceMix = 0.001  # default
        assertValidSFFloat(stop1ConstantForceMix)
        self.__stop1ConstantForceMix = stop1ConstantForceMix
    @property # getter - - - - - - - - - -
    def stop1ErrorCorrection(self):
        """[0,1] stop1ErrorCorrection is fraction of error correction performed during time step once stop point is reached."""
        return self.__stop1ErrorCorrection
    @stop1ErrorCorrection.setter
    def stop1ErrorCorrection(self, stop1ErrorCorrection):
        if  stop1ErrorCorrection is None:
            stop1ErrorCorrection = 0.8  # default
        assertValidSFFloat(stop1ErrorCorrection)
        self.__stop1ErrorCorrection = stop1ErrorCorrection
    @property # getter - - - - - - - - - -
    def suspensionErrorCorrection(self):
        """[0,1] suspensionErrorCorrection describes how quickly the system resolves intersection errors due to floating-point inaccuracies."""
        return self.__suspensionErrorCorrection
    @suspensionErrorCorrection.setter
    def suspensionErrorCorrection(self, suspensionErrorCorrection):
        if  suspensionErrorCorrection is None:
            suspensionErrorCorrection = 0.8  # default
        assertValidSFFloat(suspensionErrorCorrection)
        self.__suspensionErrorCorrection = suspensionErrorCorrection
    @property # getter - - - - - - - - - -
    def suspensionForce(self):
        """[0,1] suspensionForce describes how quickly the system resolves intersection errors due to floating-point inaccuracies."""
        return self.__suspensionForce
    @suspensionForce.setter
    def suspensionForce(self, suspensionForce):
        if  suspensionForce is None:
            suspensionForce = 0  # default
        assertValidSFFloat(suspensionForce)
        self.__suspensionForce = suspensionForce
    @property # getter - - - - - - - - - -
    def body1(self):
        """[RigidBody] The body1 and body2 fields indicate the two RigidBody nodes connected by this joint."""
        return self.__body1
    @body1.setter
    def body1(self, body1):
        if  body1 is None:
            body1 = None  # default
        assertValidSFNode(body1)
        if not body1 is None and not isinstance(body1,(RigidBody,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(body1) + ' does not match required node type (RigidBody,ProtoInstance) and is invalid')
        self.__body1 = body1
    @property # getter - - - - - - - - - -
    def body2(self):
        """[RigidBody] The body1 and body2 fields indicate the two RigidBody nodes connected by this joint."""
        return self.__body2
    @body2.setter
    def body2(self, body2):
        if  body2 is None:
            body2 = None  # default
        assertValidSFNode(body2)
        if not body2 is None and not isinstance(body2,(RigidBody,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(body2) + ' does not match required node type (RigidBody,ProtoInstance) and is invalid')
        self.__body2 = body2
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.body1 or self.body2 or self.IS or self.metadata
    # output function - - - - - - - - - -

class DynamicsCompressor(_X3DSoundProcessingNode):
    """
    DynamicsCompressor node implements a dynamics compression effect, lowering volume of loudest parts of signal and raising volume of softest parts.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'DynamicsCompressor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#DynamicsCompressor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#DynamicsCompressor'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('attack', 0.003, FieldType.SFTime, AccessType.inputOutput, 'DynamicsCompressor'),
        ('channelCountMode', 'MAX', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('channelInterpretation', 'SPEAKERS', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('knee', 30, FieldType.SFFloat, AccessType.inputOutput, 'DynamicsCompressor'),
        ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('ratio', 12, FieldType.SFFloat, AccessType.inputOutput, 'DynamicsCompressor'),
        ('release', 0.25, FieldType.SFTime, AccessType.inputOutput, 'DynamicsCompressor'),
        ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('tailTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('threshold', -24, FieldType.SFFloat, AccessType.inputOutput, 'DynamicsCompressor'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'DynamicsCompressor'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        attack=0.003,
        channelCountMode='MAX',
        channelInterpretation='SPEAKERS',
        description='',
        enabled=True,
        gain=1,
        knee=30,
        pauseTime=0,
        ratio=12,
        release=0.25,
        resumeTime=0,
        startTime=0,
        stopTime=0,
        tailTime=0,
        threshold=-24,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode DynamicsCompressor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.attack = attack
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.knee = knee
        self.pauseTime = pauseTime
        self.ratio = ratio
        self.release = release
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
        self.tailTime = tailTime
        self.threshold = threshold
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def attack(self):
        """[0,+infinity) The attack field is the duration of time (in seconds) to reduce the gain by 10dB."""
        return self.__attack
    @attack.setter
    def attack(self, attack):
        if  attack is None:
            attack = 0.003  # default
        assertValidSFTime(attack)
        assertNonNegative('attack', attack)
        self.__attack = attack
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'MAX'  # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'SPEAKERS'  # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1  # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def knee(self):
        """[0,+infinity) knee field contains a decibel value representing range above threshold where the curve smoothly transitions to compressed portion."""
        return self.__knee
    @knee.setter
    def knee(self, knee):
        if  knee is None:
            knee = 30  # default
        assertValidSFFloat(knee)
        assertNonNegative('knee', knee)
        self.__knee = knee
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0  # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def ratio(self):
        """[0,+infinity) ratio field represents amount of input change, in dB, needed for 1 dB change in output."""
        return self.__ratio
    @ratio.setter
    def ratio(self, ratio):
        if  ratio is None:
            ratio = 12  # default
        assertValidSFFloat(ratio)
        assertGreaterThanEquals('ratio', ratio, 1)
        assertLessThanEquals('ratio', ratio, 20)
        self.__ratio = ratio
    @property # getter - - - - - - - - - -
    def release(self):
        """[0,+infinity) release field represents amount of time (in seconds) to increase gain by 10dB."""
        return self.__release
    @release.setter
    def release(self, release):
        if  release is None:
            release = 0.25  # default
        assertValidSFTime(release)
        assertNonNegative('release', release)
        self.__release = release
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0  # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0  # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0  # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def tailTime(self):
        """[0,+infinity) tailTime is duration of time that a node continues to provide output signal after the input signal becomes silent."""
        return self.__tailTime
    @tailTime.setter
    def tailTime(self, tailTime):
        if  tailTime is None:
            tailTime = 0  # default
        assertValidSFTime(tailTime)
        assertNonNegative('tailTime', tailTime)
        self.__tailTime = tailTime
    @property # getter - - - - - - - - - -
    def threshold(self):
        """[0,+infinity) threshold field represents decibel value above which compression starts taking effect."""
        return self.__threshold
    @threshold.setter
    def threshold(self, threshold):
        if  threshold is None:
            threshold = -24  # default
        assertValidSFFloat(threshold)
        assertGreaterThanEquals('threshold', threshold, -100)
        assertLessThanEquals('threshold', threshold, 0)
        self.__threshold = threshold
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DSoundChannelNode|X3DSoundProcessingNode|X3DSoundSourceNode] The children field specifies audio-graph sound sources providing input signals for this node."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class EaseInEaseOut(_X3DChildNode):
    """
    EaseInEaseOut enables gradual animation transitions by modifying TimeSensor fraction outputs.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'EaseInEaseOut'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#EaseInEaseOut'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#EaseInEaseOut'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('easeInEaseOut', [], FieldType.MFVec2f, AccessType.inputOutput, 'EaseInEaseOut'),
        ('key', [], FieldType.MFFloat, AccessType.inputOutput, 'EaseInEaseOut'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        easeInEaseOut=None,
        key=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode EaseInEaseOut __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.easeInEaseOut = easeInEaseOut
        self.key = key
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def easeInEaseOut(self):
        """Array of paired values for easeOut fraction and easeIn fraction within each key interval."""
        return self.__easeInEaseOut
    @easeInEaseOut.setter
    def easeInEaseOut(self, easeInEaseOut):
        if  easeInEaseOut is None:
            easeInEaseOut = MFVec2f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec2f.DEFAULT_VALUE()))
        assertValidMFVec2f(easeInEaseOut)
        self.__easeInEaseOut = easeInEaseOut
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to easeInEaseOut array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class EdgeEnhancementVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    EdgeEnhancementVolumeStyle specifies edge enhancement for the volume rendering style.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'EdgeEnhancementVolumeStyle'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#EdgeEnhancementVolumeStyle'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#EdgeEnhancementVolumeStyle'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('edgeColor', (0, 0, 0, 1), FieldType.SFColorRGBA, AccessType.inputOutput, 'EdgeEnhancementVolumeStyle'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeRenderStyleNode'),
        ('gradientThreshold', 0.4, FieldType.SFFloat, AccessType.inputOutput, 'EdgeEnhancementVolumeStyle'),
        ('surfaceNormals', None, FieldType.SFNode, AccessType.inputOutput, 'EdgeEnhancementVolumeStyle'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        edgeColor=(0, 0, 0, 1),
        enabled=True,
        gradientThreshold=0.4,
        surfaceNormals=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode EdgeEnhancementVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.edgeColor = edgeColor
        self.enabled = enabled
        self.gradientThreshold = gradientThreshold
        self.surfaceNormals = surfaceNormals
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def edgeColor(self):
        """[0,1] color used to highlight edges."""
        return self.__edgeColor
    @edgeColor.setter
    def edgeColor(self, edgeColor):
        if  edgeColor is None:
            edgeColor = (0, 0, 0, 1)  # default
        assertValidSFColorRGBA(edgeColor)
        assertZeroToOne('edgeColor', edgeColor)
        self.__edgeColor = edgeColor
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gradientThreshold(self):
        """[0,1] minimum angle (in radians) away from view-direction vector for surface normal before applying enhancement."""
        return self.__gradientThreshold
    @gradientThreshold.setter
    def gradientThreshold(self, gradientThreshold):
        if  gradientThreshold is None:
            gradientThreshold = 0.4  # default
        assertValidSFFloat(gradientThreshold)
        assertGreaterThanEquals('gradientThreshold', gradientThreshold, 0)
        assertLessThanEquals('gradientThreshold', gradientThreshold, 3.1416)
        self.__gradientThreshold = gradientThreshold
    @property # getter - - - - - - - - - -
    def surfaceNormals(self):
        """[X3DTexture3DNode] The surfaceNormals field contains a 3D texture with at least three component values."""
        return self.__surfaceNormals
    @surfaceNormals.setter
    def surfaceNormals(self, surfaceNormals):
        if  surfaceNormals is None:
            surfaceNormals = None  # default
        assertValidSFNode(surfaceNormals)
        if not surfaceNormals is None and not isinstance(surfaceNormals,(_X3DTexture3DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(surfaceNormals) + ' does not match required node type (_X3DTexture3DNode,ProtoInstance) and is invalid')
        self.__surfaceNormals = surfaceNormals
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.surfaceNormals
    # output function - - - - - - - - - -

class ElevationGrid(_X3DGeometryNode):
    """
    ElevationGrid is a geometry node defining a rectangular height field, with default values for a 1m by 1m square at height 0.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ElevationGrid'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry3D.html#ElevationGrid'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ElevationGrid'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'ElevationGrid'),
        ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'ElevationGrid'),
        ('creaseAngle', 0, FieldType.SFFloat, AccessType.initializeOnly, 'ElevationGrid'),
        ('height', [], FieldType.MFFloat, AccessType.initializeOnly, 'ElevationGrid'),
        ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'ElevationGrid'),
        ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'ElevationGrid'),
        ('xDimension', 0, FieldType.SFInt32, AccessType.initializeOnly, 'ElevationGrid'),
        ('xSpacing', 1.0, FieldType.SFFloat, AccessType.initializeOnly, 'ElevationGrid'),
        ('zDimension', 0, FieldType.SFInt32, AccessType.initializeOnly, 'ElevationGrid'),
        ('zSpacing', 1.0, FieldType.SFFloat, AccessType.initializeOnly, 'ElevationGrid'),
        ('color', None, FieldType.SFNode, AccessType.inputOutput, 'ElevationGrid'),
        ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'ElevationGrid'),
        ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'ElevationGrid'),
        ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'ElevationGrid'),
        ('attrib', [], FieldType.MFNode, AccessType.inputOutput, 'ElevationGrid'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        ccw=True,
        colorPerVertex=True,
        creaseAngle=0,
        height=None,
        normalPerVertex=True,
        solid=True,
        xDimension=0,
        xSpacing=1.0,
        zDimension=0,
        zSpacing=1.0,
        color=None,
        fogCoord=None,
        normal=None,
        texCoord=None,
        attrib=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ElevationGrid __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.creaseAngle = creaseAngle
        self.height = height
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.xDimension = xDimension
        self.xSpacing = xSpacing
        self.zDimension = zDimension
        self.zSpacing = zSpacing
        self.color = color
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True  # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color node color values are applied to each point vertex (true) or per quadrilateral (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True  # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def creaseAngle(self):
        """[0,+infinity) creaseAngle defines angle (in radians) for determining whether adjacent polygons are drawn with sharp edges or smooth shading."""
        return self.__creaseAngle
    @creaseAngle.setter
    def creaseAngle(self, creaseAngle):
        if  creaseAngle is None:
            creaseAngle = 0  # default
        assertValidSFFloat(creaseAngle)
        assertNonNegative('creaseAngle', creaseAngle)
        self.__creaseAngle = creaseAngle
    @property # getter - - - - - - - - - -
    def height(self):
        """Grid array of height vertices with upward direction along +Y axis, with xDimension rows and zDimension columns."""
        return self.__height
    @height.setter
    def height(self, height):
        if  height is None:
            height = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(height)
        self.__height = height
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or per quadrilateral (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True  # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def xDimension(self):
        """(0,+infinity) Number of elements in the height array along X direction."""
        return self.__xDimension
    @xDimension.setter
    def xDimension(self, xDimension):
        if  xDimension is None:
            xDimension = 0  # default
        assertValidSFInt32(xDimension)
        assertNonNegative('xDimension', xDimension)
        self.__xDimension = xDimension
    @property # getter - - - - - - - - - -
    def xSpacing(self):
        """(0,+infinity) Meters distance between grid-array vertices along X direction."""
        return self.__xSpacing
    @xSpacing.setter
    def xSpacing(self, xSpacing):
        if  xSpacing is None:
            xSpacing = 1.0  # default
        assertValidSFFloat(xSpacing)
        assertPositive('xSpacing', xSpacing)
        self.__xSpacing = xSpacing
    @property # getter - - - - - - - - - -
    def zDimension(self):
        """(0,+infinity) Number of elements in the height array along Z direction."""
        return self.__zDimension
    @zDimension.setter
    def zDimension(self, zDimension):
        if  zDimension is None:
            zDimension = 0  # default
        assertValidSFInt32(zDimension)
        assertNonNegative('zDimension', zDimension)
        self.__zDimension = zDimension
    @property # getter - - - - - - - - - -
    def zSpacing(self):
        """(0,+infinity) Meters distance between grid-array vertices along Z direction."""
        return self.__zSpacing
    @zSpacing.setter
    def zSpacing(self, zSpacing):
        if  zSpacing is None:
            zSpacing = 1.0  # default
        assertValidSFFloat(zSpacing)
        assertPositive('zSpacing', zSpacing)
        self.__zSpacing = zSpacing
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that can specify color values applied to corresponding vertices according to colorPerVertex field."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None  # default
        assertValidSFNode(color)
        if not color is None and not isinstance(color,(_X3DColorNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not match required node type (_X3DColorNode,ProtoInstance) and is invalid')
        self.__color = color
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that can specify depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None  # default
        assertValidSFNode(fogCoord)
        if not fogCoord is None and not isinstance(fogCoord,(FogCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not match required node type (FogCoordinate,ProtoInstance) and is invalid')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that can specify perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None  # default
        assertValidSFNode(normal)
        if not normal is None and not isinstance(normal,(_X3DNormalNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not match required node type (_X3DNormalNode,ProtoInstance) and is invalid')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that can specify coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None  # default
        assertValidSFNode(texCoord)
        if not texCoord is None and not isinstance(texCoord,(_X3DSingleTextureCoordinateNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not match required node type (_X3DSingleTextureCoordinateNode,ProtoInstance) and is invalid')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that can specify list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE()

            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(attrib)
        self.__attrib = attrib
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.color or self.fogCoord or self.IS or self.metadata or self.normal or self.texCoord or (len(self.attrib) > 0)
    # output function - - - - - - - - - -

class EspduTransform(_X3DGroupingNode, _X3DNetworkSensorNode):
    """
    EspduTransform is a networked Transform node that can contain most nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'EspduTransform'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/dis.html#EspduTransform'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#EspduTransform'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('address', 'localhost', FieldType.SFString, AccessType.inputOutput, 'EspduTransform'),
        ('applicationID', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('articulationParameterArray', [], FieldType.MFFloat, AccessType.inputOutput, 'EspduTransform'),
        ('articulationParameterChangeIndicatorArray', [], FieldType.MFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('articulationParameterCount', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('articulationParameterDesignatorArray', [], FieldType.MFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('articulationParameterIdPartAttachedToArray', [], FieldType.MFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('articulationParameterTypeArray', [], FieldType.MFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'EspduTransform'),
        ('collisionType', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('deadReckoning', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'EspduTransform'),
        ('detonationLocation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'EspduTransform'),
        ('detonationRelativeLocation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'EspduTransform'),
        ('detonationResult', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'EspduTransform'),
        ('entityCategory', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('entityCountry', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('entityDomain', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('entityExtra', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('entityID', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('entityKind', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('entitySpecific', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('entitySubcategory', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('eventApplicationID', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('eventEntityID', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('eventNumber', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('eventSiteID', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('fired1', False, FieldType.SFBool, AccessType.inputOutput, 'EspduTransform'),
        ('fired2', False, FieldType.SFBool, AccessType.inputOutput, 'EspduTransform'),
        ('fireMissionIndex', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('firingRange', 0, FieldType.SFFloat, AccessType.inputOutput, 'EspduTransform'),
        ('firingRate', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('forceID', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('fuse', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('geoCoords', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput, 'EspduTransform'),
        ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'EspduTransform'),
        ('linearAcceleration', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'EspduTransform'),
        ('linearVelocity', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'EspduTransform'),
        ('marking', '', FieldType.SFString, AccessType.inputOutput, 'EspduTransform'),
        ('multicastRelayHost', '', FieldType.SFString, AccessType.inputOutput, 'EspduTransform'),
        ('multicastRelayPort', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('munitionApplicationID', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('munitionEndPoint', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'EspduTransform'),
        ('munitionEntityID', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('munitionQuantity', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('munitionSiteID', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('munitionStartPoint', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'EspduTransform'),
        ('networkMode', 'standAlone', FieldType.SFString, AccessType.inputOutput, 'EspduTransform'),
        ('port', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('readInterval', 0.1, FieldType.SFTime, AccessType.inputOutput, 'EspduTransform'),
        ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'EspduTransform'),
        ('rtpHeaderExpected', False, FieldType.SFBool, AccessType.inputOutput, 'EspduTransform'),
        ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'EspduTransform'),
        ('scaleOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'EspduTransform'),
        ('siteID', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'EspduTransform'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('warhead', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
        ('writeInterval', 1.0, FieldType.SFTime, AccessType.inputOutput, 'EspduTransform'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        address='localhost',
        applicationID=0,
        articulationParameterArray=None,
        articulationParameterChangeIndicatorArray=None,
        articulationParameterCount=0,
        articulationParameterDesignatorArray=None,
        articulationParameterIdPartAttachedToArray=None,
        articulationParameterTypeArray=None,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        center=(0, 0, 0),
        collisionType=0,
        deadReckoning=0,
        description='',
        detonationLocation=(0, 0, 0),
        detonationRelativeLocation=(0, 0, 0),
        detonationResult=0,
        enabled=True,
        entityCategory=0,
        entityCountry=0,
        entityDomain=0,
        entityExtra=0,
        entityID=0,
        entityKind=0,
        entitySpecific=0,
        entitySubcategory=0,
        eventApplicationID=0,
        eventEntityID=0,
        eventNumber=0,
        eventSiteID=0,
        fired1=False,
        fired2=False,
        fireMissionIndex=0,
        firingRange=0,
        firingRate=0,
        forceID=0,
        fuse=0,
        geoCoords=(0, 0, 0),
        geoSystem=None,
        linearAcceleration=(0, 0, 0),
        linearVelocity=(0, 0, 0),
        marking='',
        multicastRelayHost='',
        multicastRelayPort=0,
        munitionApplicationID=0,
        munitionEndPoint=(0, 0, 0),
        munitionEntityID=0,
        munitionQuantity=0,
        munitionSiteID=0,
        munitionStartPoint=(0, 0, 0),
        networkMode='standAlone',
        port=0,
        readInterval=0.1,
        rotation=(0, 0, 1, 0),
        rtpHeaderExpected=False,
        scale=(1, 1, 1),
        scaleOrientation=(0, 0, 1, 0),
        siteID=0,
        translation=(0, 0, 0),
        visible=True,
        warhead=0,
        writeInterval=1.0,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode EspduTransform __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.address = address
        self.applicationID = applicationID
        self.articulationParameterArray = articulationParameterArray
        self.articulationParameterChangeIndicatorArray = articulationParameterChangeIndicatorArray
        self.articulationParameterCount = articulationParameterCount
        self.articulationParameterDesignatorArray = articulationParameterDesignatorArray
        self.articulationParameterIdPartAttachedToArray = articulationParameterIdPartAttachedToArray
        self.articulationParameterTypeArray = articulationParameterTypeArray
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.center = center
        self.collisionType = collisionType
        self.deadReckoning = deadReckoning
        self.description = description
        self.detonationLocation = detonationLocation
        self.detonationRelativeLocation = detonationRelativeLocation
        self.detonationResult = detonationResult
        self.enabled = enabled
        self.entityCategory = entityCategory
        self.entityCountry = entityCountry
        self.entityDomain = entityDomain
        self.entityExtra = entityExtra
        self.entityID = entityID
        self.entityKind = entityKind
        self.entitySpecific = entitySpecific
        self.entitySubcategory = entitySubcategory
        self.eventApplicationID = eventApplicationID
        self.eventEntityID = eventEntityID
        self.eventNumber = eventNumber
        self.eventSiteID = eventSiteID
        self.fired1 = fired1
        self.fired2 = fired2
        self.fireMissionIndex = fireMissionIndex
        self.firingRange = firingRange
        self.firingRate = firingRate
        self.forceID = forceID
        self.fuse = fuse
        self.geoCoords = geoCoords
        self.geoSystem = geoSystem
        self.linearAcceleration = linearAcceleration
        self.linearVelocity = linearVelocity
        self.marking = marking
        self.multicastRelayHost = multicastRelayHost
        self.multicastRelayPort = multicastRelayPort
        self.munitionApplicationID = munitionApplicationID
        self.munitionEndPoint = munitionEndPoint
        self.munitionEntityID = munitionEntityID
        self.munitionQuantity = munitionQuantity
        self.munitionSiteID = munitionSiteID
        self.munitionStartPoint = munitionStartPoint
        self.networkMode = networkMode
        self.port = port
        self.readInterval = readInterval
        self.rotation = rotation
        self.rtpHeaderExpected = rtpHeaderExpected
        self.scale = scale
        self.scaleOrientation = scaleOrientation
        self.siteID = siteID
        self.translation = translation
        self.visible = visible
        self.warhead = warhead
        self.writeInterval = writeInterval
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def address(self):
        """Multicast network address, or else 'localhost'; Example: 224."""
        return self.__address
    @address.setter
    def address(self, address):
        if  address is None:
            address = 'localhost'  # default
        assertValidSFString(address)
        self.__address = address
    @property # getter - - - - - - - - - -
    def applicationID(self):
        """Simulation/exercise applicationID is unique for application at that site."""
        return self.__applicationID
    @applicationID.setter
    def applicationID(self, applicationID):
        if  applicationID is None:
            applicationID = 0  # default
        assertValidSFInt32(applicationID)
        self.__applicationID = applicationID
    @property # getter - - - - - - - - - -
    def articulationParameterArray(self):
        """Information required for representation of the entity's visual appearance and position of its articulated parts."""
        return self.__articulationParameterArray
    @articulationParameterArray.setter
    def articulationParameterArray(self, articulationParameterArray):
        if  articulationParameterArray is None:
            articulationParameterArray = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(articulationParameterArray)
        self.__articulationParameterArray = articulationParameterArray
    @property # getter - - - - - - - - - -
    def articulationParameterChangeIndicatorArray(self):
        """Array of change counters, each incremented when an articulated parameter is updated."""
        return self.__articulationParameterChangeIndicatorArray
    @articulationParameterChangeIndicatorArray.setter
    def articulationParameterChangeIndicatorArray(self, articulationParameterChangeIndicatorArray):
        if  articulationParameterChangeIndicatorArray is None:
            articulationParameterChangeIndicatorArray = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(articulationParameterChangeIndicatorArray)
        self.__articulationParameterChangeIndicatorArray = articulationParameterChangeIndicatorArray
    @property # getter - - - - - - - - - -
    def articulationParameterCount(self):
        """Number of articulated parameters attached to this entity state PDU."""
        return self.__articulationParameterCount
    @articulationParameterCount.setter
    def articulationParameterCount(self, articulationParameterCount):
        if  articulationParameterCount is None:
            articulationParameterCount = 0  # default
        assertValidSFInt32(articulationParameterCount)
        self.__articulationParameterCount = articulationParameterCount
    @property # getter - - - - - - - - - -
    def articulationParameterDesignatorArray(self):
        """Array of designators for each articulated parameter."""
        return self.__articulationParameterDesignatorArray
    @articulationParameterDesignatorArray.setter
    def articulationParameterDesignatorArray(self, articulationParameterDesignatorArray):
        if  articulationParameterDesignatorArray is None:
            articulationParameterDesignatorArray = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(articulationParameterDesignatorArray)
        self.__articulationParameterDesignatorArray = articulationParameterDesignatorArray
    @property # getter - - - - - - - - - -
    def articulationParameterIdPartAttachedToArray(self):
        """Array of ID parts that each articulated parameter is attached to."""
        return self.__articulationParameterIdPartAttachedToArray
    @articulationParameterIdPartAttachedToArray.setter
    def articulationParameterIdPartAttachedToArray(self, articulationParameterIdPartAttachedToArray):
        if  articulationParameterIdPartAttachedToArray is None:
            articulationParameterIdPartAttachedToArray = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(articulationParameterIdPartAttachedToArray)
        self.__articulationParameterIdPartAttachedToArray = articulationParameterIdPartAttachedToArray
    @property # getter - - - - - - - - - -
    def articulationParameterTypeArray(self):
        """Array of type enumerations for each articulated parameter element."""
        return self.__articulationParameterTypeArray
    @articulationParameterTypeArray.setter
    def articulationParameterTypeArray(self, articulationParameterTypeArray):
        if  articulationParameterTypeArray is None:
            articulationParameterTypeArray = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(articulationParameterTypeArray)
        self.__articulationParameterTypeArray = articulationParameterTypeArray
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        """Translation offset from origin of local coordinate system."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0)  # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def collisionType(self):
        """Integer enumeration for type of collision: ELASTIC or INELASTIC."""
        return self.__collisionType
    @collisionType.setter
    def collisionType(self, collisionType):
        if  collisionType is None:
            collisionType = 0  # default
        assertValidSFInt32(collisionType)
        self.__collisionType = collisionType
    @property # getter - - - - - - - - - -
    def deadReckoning(self):
        """Dead reckoning algorithm being used to project position/orientation with velocities/accelerations."""
        return self.__deadReckoning
    @deadReckoning.setter
    def deadReckoning(self, deadReckoning):
        if  deadReckoning is None:
            deadReckoning = 0  # default
        assertValidSFInt32(deadReckoning)
        self.__deadReckoning = deadReckoning
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def detonationLocation(self):
        """World coordinates for detonationLocation."""
        return self.__detonationLocation
    @detonationLocation.setter
    def detonationLocation(self, detonationLocation):
        if  detonationLocation is None:
            detonationLocation = (0, 0, 0)  # default
        assertValidSFVec3f(detonationLocation)
        self.__detonationLocation = detonationLocation
    @property # getter - - - - - - - - - -
    def detonationRelativeLocation(self):
        """Relative coordinates for detonation location."""
        return self.__detonationRelativeLocation
    @detonationRelativeLocation.setter
    def detonationRelativeLocation(self, detonationRelativeLocation):
        if  detonationRelativeLocation is None:
            detonationRelativeLocation = (0, 0, 0)  # default
        assertValidSFVec3f(detonationRelativeLocation)
        self.__detonationRelativeLocation = detonationRelativeLocation
    @property # getter - - - - - - - - - -
    def detonationResult(self):
        """Integer enumeration for type of detonation and result that occurred."""
        return self.__detonationResult
    @detonationResult.setter
    def detonationResult(self, detonationResult):
        if  detonationResult is None:
            detonationResult = 0  # default
        assertValidSFInt32(detonationResult)
        self.__detonationResult = detonationResult
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables the sensor node."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def entityCategory(self):
        """Integer enumerations value for main category that describes the entity, semantics of each code varies according to domain."""
        return self.__entityCategory
    @entityCategory.setter
    def entityCategory(self, entityCategory):
        if  entityCategory is None:
            entityCategory = 0  # default
        assertValidSFInt32(entityCategory)
        self.__entityCategory = entityCategory
    @property # getter - - - - - - - - - -
    def entityCountry(self):
        """Integer enumerations value for country to which the design of the entity or its design specification is attributed."""
        return self.__entityCountry
    @entityCountry.setter
    def entityCountry(self, entityCountry):
        if  entityCountry is None:
            entityCountry = 0  # default
        assertValidSFInt32(entityCountry)
        self.__entityCountry = entityCountry
    @property # getter - - - - - - - - - -
    def entityDomain(self):
        """Integer enumerations value for domain in which the entity operates: LAND, AIR, SURFACE, SUBSURFACE, SPACE or OTHER."""
        return self.__entityDomain
    @entityDomain.setter
    def entityDomain(self, entityDomain):
        if  entityDomain is None:
            entityDomain = 0  # default
        assertValidSFInt32(entityDomain)
        self.__entityDomain = entityDomain
    @property # getter - - - - - - - - - -
    def entityExtra(self):
        """Any extra information required to describe a particular entity."""
        return self.__entityExtra
    @entityExtra.setter
    def entityExtra(self, entityExtra):
        if  entityExtra is None:
            entityExtra = 0  # default
        assertValidSFInt32(entityExtra)
        self.__entityExtra = entityExtra
    @property # getter - - - - - - - - - -
    def entityID(self):
        """Simulation/exercise entityID is a unique ID for a single entity within that application."""
        return self.__entityID
    @entityID.setter
    def entityID(self, entityID):
        if  entityID is None:
            entityID = 0  # default
        assertValidSFInt32(entityID)
        self.__entityID = entityID
    @property # getter - - - - - - - - - -
    def entityKind(self):
        """Integer enumerations value for whether entity is a PLATFORM, MUNITION, LIFE_FORM, ENVIRONMENTAL, CULTURAL_FEATURE, SUPPLY, RADIO, EXPENDABLE, SENSOR_EMITTER or OTHER."""
        return self.__entityKind
    @entityKind.setter
    def entityKind(self, entityKind):
        if  entityKind is None:
            entityKind = 0  # default
        assertValidSFInt32(entityKind)
        self.__entityKind = entityKind
    @property # getter - - - - - - - - - -
    def entitySpecific(self):
        """Specific information about an entity based on the Subcategory field."""
        return self.__entitySpecific
    @entitySpecific.setter
    def entitySpecific(self, entitySpecific):
        if  entitySpecific is None:
            entitySpecific = 0  # default
        assertValidSFInt32(entitySpecific)
        self.__entitySpecific = entitySpecific
    @property # getter - - - - - - - - - -
    def entitySubcategory(self):
        """Integer enumerations value for particular subcategory to which an entity belongs based on the category field."""
        return self.__entitySubcategory
    @entitySubcategory.setter
    def entitySubcategory(self, entitySubcategory):
        if  entitySubcategory is None:
            entitySubcategory = 0  # default
        assertValidSFInt32(entitySubcategory)
        self.__entitySubcategory = entitySubcategory
    @property # getter - - - - - - - - - -
    def eventApplicationID(self):
        """Simulation/exercise eventApplicationID is unique for events generated from application at that site."""
        return self.__eventApplicationID
    @eventApplicationID.setter
    def eventApplicationID(self, eventApplicationID):
        if  eventApplicationID is None:
            eventApplicationID = 0  # default
        assertValidSFInt32(eventApplicationID)
        self.__eventApplicationID = eventApplicationID
    @property # getter - - - - - - - - - -
    def eventEntityID(self):
        """For a given event, simulation/exercise entityID is a unique ID for a single entity within that application."""
        return self.__eventEntityID
    @eventEntityID.setter
    def eventEntityID(self, eventEntityID):
        if  eventEntityID is None:
            eventEntityID = 0  # default
        assertValidSFInt32(eventEntityID)
        self.__eventEntityID = eventEntityID
    @property # getter - - - - - - - - - -
    def eventNumber(self):
        """Sequential number of each event issued by an application."""
        return self.__eventNumber
    @eventNumber.setter
    def eventNumber(self, eventNumber):
        if  eventNumber is None:
            eventNumber = 0  # default
        assertValidSFInt32(eventNumber)
        self.__eventNumber = eventNumber
    @property # getter - - - - - - - - - -
    def eventSiteID(self):
        """Simulation/exercise siteID of the participating LAN or organization."""
        return self.__eventSiteID
    @eventSiteID.setter
    def eventSiteID(self, eventSiteID):
        if  eventSiteID is None:
            eventSiteID = 0  # default
        assertValidSFInt32(eventSiteID)
        self.__eventSiteID = eventSiteID
    @property # getter - - - - - - - - - -
    def fired1(self):
        """Has the primary weapon (Fire PDU) been fired?."""
        return self.__fired1
    @fired1.setter
    def fired1(self, fired1):
        if  fired1 is None:
            fired1 = False  # default
        assertValidSFBool(fired1)
        self.__fired1 = fired1
    @property # getter - - - - - - - - - -
    def fired2(self):
        """Has the secondary weapon (Fire PDU) been fired?."""
        return self.__fired2
    @fired2.setter
    def fired2(self, fired2):
        if  fired2 is None:
            fired2 = False  # default
        assertValidSFBool(fired2)
        self.__fired2 = fired2
    @property # getter - - - - - - - - - -
    def fireMissionIndex(self):
        """."""
        return self.__fireMissionIndex
    @fireMissionIndex.setter
    def fireMissionIndex(self, fireMissionIndex):
        if  fireMissionIndex is None:
            fireMissionIndex = 0  # default
        assertValidSFInt32(fireMissionIndex)
        self.__fireMissionIndex = fireMissionIndex
    @property # getter - - - - - - - - - -
    def firingRange(self):
        """Range (three dimension, straight-line distance) that the firing entity's fire control system has assumed for computing the fire control solution if a weapon and if the value is known."""
        return self.__firingRange
    @firingRange.setter
    def firingRange(self, firingRange):
        if  firingRange is None:
            firingRange = 0  # default
        assertValidSFFloat(firingRange)
        self.__firingRange = firingRange
    @property # getter - - - - - - - - - -
    def firingRate(self):
        """Rate at which munitions are fired."""
        return self.__firingRate
    @firingRate.setter
    def firingRate(self, firingRate):
        if  firingRate is None:
            firingRate = 0  # default
        assertValidSFInt32(firingRate)
        self.__firingRate = firingRate
    @property # getter - - - - - - - - - -
    def forceID(self):
        """forceID determines the team membership of the issuing entity, and whether FRIENDLY OPPOSING or NEUTRAL or OTHER."""
        return self.__forceID
    @forceID.setter
    def forceID(self, forceID):
        if  forceID is None:
            forceID = 0  # default
        assertValidSFInt32(forceID)
        self.__forceID = forceID
    @property # getter - - - - - - - - - -
    def fuse(self):
        """Integer enumerations value for type of fuse on the munition."""
        return self.__fuse
    @fuse.setter
    def fuse(self, fuse):
        if  fuse is None:
            fuse = 0  # default
        assertValidSFInt32(fuse)
        self.__fuse = fuse
    @property # getter - - - - - - - - - -
    def geoCoords(self):
        """Geographic location (specified in current geoSystem coordinates) for children geometry (specified in relative coordinate system, in meters)."""
        return self.__geoCoords
    @geoCoords.setter
    def geoCoords(self, geoCoords):
        if  geoCoords is None:
            geoCoords = (0, 0, 0)  # default
        assertValidSFVec3d(geoCoords)
        self.__geoCoords = geoCoords
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"]  # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def linearAcceleration(self):
        """Acceleration of the entity relative to the rotating Earth in either world or entity coordinates, depending on the dead reckoning algorithm used."""
        return self.__linearAcceleration
    @linearAcceleration.setter
    def linearAcceleration(self, linearAcceleration):
        if  linearAcceleration is None:
            linearAcceleration = (0, 0, 0)  # default
        assertValidSFVec3f(linearAcceleration)
        self.__linearAcceleration = linearAcceleration
    @property # getter - - - - - - - - - -
    def linearVelocity(self):
        """Velocity of the entity relative to the rotating Earth in either world or entity coordinates, depending on the dead reckoning algorithm used."""
        return self.__linearVelocity
    @linearVelocity.setter
    def linearVelocity(self, linearVelocity):
        if  linearVelocity is None:
            linearVelocity = (0, 0, 0)  # default
        assertValidSFVec3f(linearVelocity)
        self.__linearVelocity = linearVelocity
    @property # getter - - - - - - - - - -
    def marking(self):
        """Maximum of 11 characters for simple entity label."""
        return self.__marking
    @marking.setter
    def marking(self, marking):
        if  marking is None:
            marking = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(marking)
        self.__marking = marking
    @property # getter - - - - - - - - - -
    def multicastRelayHost(self):
        """Fallback server address if multicast not available locally."""
        return self.__multicastRelayHost
    @multicastRelayHost.setter
    def multicastRelayHost(self, multicastRelayHost):
        if  multicastRelayHost is None:
            multicastRelayHost = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(multicastRelayHost)
        self.__multicastRelayHost = multicastRelayHost
    @property # getter - - - - - - - - - -
    def multicastRelayPort(self):
        """Fallback server port if multicast not available locally."""
        return self.__multicastRelayPort
    @multicastRelayPort.setter
    def multicastRelayPort(self, multicastRelayPort):
        if  multicastRelayPort is None:
            multicastRelayPort = 0  # default
        assertValidSFInt32(multicastRelayPort)
        self.__multicastRelayPort = multicastRelayPort
    @property # getter - - - - - - - - - -
    def munitionApplicationID(self):
        """munitionApplicationID, unique for application at that site."""
        return self.__munitionApplicationID
    @munitionApplicationID.setter
    def munitionApplicationID(self, munitionApplicationID):
        if  munitionApplicationID is None:
            munitionApplicationID = 0  # default
        assertValidSFInt32(munitionApplicationID)
        self.__munitionApplicationID = munitionApplicationID
    @property # getter - - - - - - - - - -
    def munitionEndPoint(self):
        """Final point of the munition path from firing weapon to detonation or impact, in exercise coordinates."""
        return self.__munitionEndPoint
    @munitionEndPoint.setter
    def munitionEndPoint(self, munitionEndPoint):
        if  munitionEndPoint is None:
            munitionEndPoint = (0, 0, 0)  # default
        assertValidSFVec3f(munitionEndPoint)
        self.__munitionEndPoint = munitionEndPoint
    @property # getter - - - - - - - - - -
    def munitionEntityID(self):
        """munitionEntityID is unique ID for entity firing munition within that application."""
        return self.__munitionEntityID
    @munitionEntityID.setter
    def munitionEntityID(self, munitionEntityID):
        if  munitionEntityID is None:
            munitionEntityID = 0  # default
        assertValidSFInt32(munitionEntityID)
        self.__munitionEntityID = munitionEntityID
    @property # getter - - - - - - - - - -
    def munitionQuantity(self):
        """Quantity of munitions fired."""
        return self.__munitionQuantity
    @munitionQuantity.setter
    def munitionQuantity(self, munitionQuantity):
        if  munitionQuantity is None:
            munitionQuantity = 0  # default
        assertValidSFInt32(munitionQuantity)
        self.__munitionQuantity = munitionQuantity
    @property # getter - - - - - - - - - -
    def munitionSiteID(self):
        """Munition siteID of the participating LAN or organization."""
        return self.__munitionSiteID
    @munitionSiteID.setter
    def munitionSiteID(self, munitionSiteID):
        if  munitionSiteID is None:
            munitionSiteID = 0  # default
        assertValidSFInt32(munitionSiteID)
        self.__munitionSiteID = munitionSiteID
    @property # getter - - - - - - - - - -
    def munitionStartPoint(self):
        """Initial point of the munition path from firing weapon to detonation or impact, in exercise coordinates."""
        return self.__munitionStartPoint
    @munitionStartPoint.setter
    def munitionStartPoint(self, munitionStartPoint):
        if  munitionStartPoint is None:
            munitionStartPoint = (0, 0, 0)  # default
        assertValidSFVec3f(munitionStartPoint)
        self.__munitionStartPoint = munitionStartPoint
    @property # getter - - - - - - - - - -
    def networkMode(self):
        """Whether this entity is ignoring the network, sending DIS packets to the network, or receiving DIS packets from the network."""
        return self.__networkMode
    @networkMode.setter
    def networkMode(self, networkMode):
        if  networkMode is None:
            networkMode = 'standAlone'  # default
        assertValidSFString(networkMode)
        assertValidNetworkMode('networkMode', networkMode)
        self.__networkMode = networkMode
    @property # getter - - - - - - - - - -
    def port(self):
        """Network connection port number (EXAMPLE 3000) for sending or receiving DIS messages."""
        return self.__port
    @port.setter
    def port(self, port):
        if  port is None:
            port = 0  # default
        assertValidSFInt32(port)
        self.__port = port
    @property # getter - - - - - - - - - -
    def readInterval(self):
        """[0,+infinity) Seconds between read updates, 0 means no reading."""
        return self.__readInterval
    @readInterval.setter
    def readInterval(self, readInterval):
        if  readInterval is None:
            readInterval = 0.1  # default
        assertValidSFTime(readInterval)
        assertNonNegative('readInterval', readInterval)
        self.__readInterval = readInterval
    @property # getter - - - - - - - - - -
    def rotation(self):
        """Orientation of children relative to local coordinate system, usually read from (or written to) remote, networked EspduTransform nodes."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = (0, 0, 1, 0)  # default
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def rtpHeaderExpected(self):
        """Whether RTP headers are prepended to DIS PDUs."""
        return self.__rtpHeaderExpected
    @rtpHeaderExpected.setter
    def rtpHeaderExpected(self, rtpHeaderExpected):
        if  rtpHeaderExpected is None:
            rtpHeaderExpected = False  # default
        assertValidSFBool(rtpHeaderExpected)
        self.__rtpHeaderExpected = rtpHeaderExpected
    @property # getter - - - - - - - - - -
    def scale(self):
        """Non-uniform x-y-z scale of child coordinate system, adjusted by center and scaleOrientation."""
        return self.__scale
    @scale.setter
    def scale(self, scale):
        if  scale is None:
            scale = (1, 1, 1)  # default
        assertValidSFVec3f(scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def scaleOrientation(self):
        """Preliminary rotation of coordinate system before scaling (to allow scaling around arbitrary orientations)."""
        return self.__scaleOrientation
    @scaleOrientation.setter
    def scaleOrientation(self, scaleOrientation):
        if  scaleOrientation is None:
            scaleOrientation = (0, 0, 1, 0)  # default
        assertValidSFRotation(scaleOrientation)
        self.__scaleOrientation = scaleOrientation
    @property # getter - - - - - - - - - -
    def siteID(self):
        """Simulation/exercise siteID of the participating LAN or organization."""
        return self.__siteID
    @siteID.setter
    def siteID(self, siteID):
        if  siteID is None:
            siteID = 0  # default
        assertValidSFInt32(siteID)
        self.__siteID = siteID
    @property # getter - - - - - - - - - -
    def translation(self):
        """Position of children relative to local coordinate system, usually read from (or written to) remote, networked EspduTransform nodes."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0, 0)  # default
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def warhead(self):
        """Integer enumerations value for type of warhead on the munition."""
        return self.__warhead
    @warhead.setter
    def warhead(self, warhead):
        if  warhead is None:
            warhead = 0  # default
        assertValidSFInt32(warhead)
        self.__warhead = warhead
    @property # getter - - - - - - - - - -
    def writeInterval(self):
        """[0,+infinity) Seconds between write updates, 0 means no writing (sending)."""
        return self.__writeInterval
    @writeInterval.setter
    def writeInterval(self, writeInterval):
        if  writeInterval is None:
            writeInterval = 1.0  # default
        assertValidSFTime(writeInterval)
        assertNonNegative('writeInterval', writeInterval)
        self.__writeInterval = writeInterval
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class ExplosionEmitter(_X3DParticleEmitterNode):
    """
    ExplosionEmitter generates all particles from a specific point in space at the initial time enabled.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ExplosionEmitter'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#ExplosionEmitter'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ExplosionEmitter'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('mass', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('on', True, FieldType.SFBool, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('position', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'ExplosionEmitter'),
        ('speed', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('surfaceArea', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('variation', 0.25, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        mass=0,
        on=True,
        position=(0, 0, 0),
        speed=0,
        surfaceArea=0,
        variation=0.25,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ExplosionEmitter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.mass = mass
        self.on = on
        self.position = position
        self.speed = speed
        self.surfaceArea = surfaceArea
        self.variation = variation
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def mass(self):
        """[0,+infinity) Basic mass of each particle, defined in mass base units (default is kilograms)."""
        return self.__mass
    @mass.setter
    def mass(self, mass):
        if  mass is None:
            mass = 0  # default
        assertValidSFFloat(mass)
        assertNonNegative('mass', mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def on(self):
        """Enables/disables production of particles from this emitter node."""
        return self.__on
    @on.setter
    def on(self, on):
        if  on is None:
            on = True  # default
        assertValidSFBool(on)
        self.__on = on
    @property # getter - - - - - - - - - -
    def position(self):
        """Point from which particles emanate."""
        return self.__position
    @position.setter
    def position(self, position):
        if  position is None:
            position = (0, 0, 0)  # default
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def speed(self):
        """[0,+infinity) Initial linear speed (default is m/s) imparted to all particles along their direction of movement."""
        return self.__speed
    @speed.setter
    def speed(self, speed):
        if  speed is None:
            speed = 0  # default
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def surfaceArea(self):
        """[0,+infinity) Particle surface area in area base units (default is meters squared)."""
        return self.__surfaceArea
    @surfaceArea.setter
    def surfaceArea(self, surfaceArea):
        if  surfaceArea is None:
            surfaceArea = 0  # default
        assertValidSFFloat(surfaceArea)
        assertNonNegative('surfaceArea', surfaceArea)
        self.__surfaceArea = surfaceArea
    @property # getter - - - - - - - - - -
    def variation(self):
        """[0,+infinity) Multiplier for the randomness used to control the range of possible output values."""
        return self.__variation
    @variation.setter
    def variation(self, variation):
        if  variation is None:
            variation = 0.25  # default
        assertValidSFFloat(variation)
        assertNonNegative('variation', variation)
        self.__variation = variation
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class Extrusion(_X3DGeometryNode):
    """
    Extrusion is a geometry node that sequentially stretches a 2D cross section along a 3D-spine path in the local coordinate system, creating an outer hull.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Extrusion'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry3D.html#Extrusion'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Extrusion'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('beginCap', True, FieldType.SFBool, AccessType.initializeOnly, 'Extrusion'),
        ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'Extrusion'),
        ('convex', True, FieldType.SFBool, AccessType.initializeOnly, 'Extrusion'),
        ('creaseAngle', 0, FieldType.SFFloat, AccessType.initializeOnly, 'Extrusion'),
        ('crossSection', [(1, 1), (1, -1), (-1, -1), (-1, 1), (1, 1)], FieldType.MFVec2f, AccessType.initializeOnly, 'Extrusion'),
        ('endCap', True, FieldType.SFBool, AccessType.initializeOnly, 'Extrusion'),
        ('orientation', [(0, 0, 1, 0)], FieldType.MFRotation, AccessType.initializeOnly, 'Extrusion'),
        ('scale', [(1, 1)], FieldType.MFVec2f, AccessType.initializeOnly, 'Extrusion'),
        ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'Extrusion'),
        ('spine', [(0, 0, 0), (0, 1, 0)], FieldType.MFVec3f, AccessType.initializeOnly, 'Extrusion'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        beginCap=True,
        ccw=True,
        convex=True,
        creaseAngle=0,
        crossSection=None,
        endCap=True,
        orientation=None,
        scale=None,
        solid=True,
        spine=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Extrusion __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.beginCap = beginCap
        self.ccw = ccw
        self.convex = convex
        self.creaseAngle = creaseAngle
        self.crossSection = crossSection
        self.endCap = endCap
        self.orientation = orientation
        self.scale = scale
        self.solid = solid
        self.spine = spine
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def beginCap(self):
        """Whether beginning cap is drawn (similar to Cylinder top cap)."""
        return self.__beginCap
    @beginCap.setter
    def beginCap(self, beginCap):
        if  beginCap is None:
            beginCap = True  # default
        assertValidSFBool(beginCap)
        self.__beginCap = beginCap
    @property # getter - - - - - - - - - -
    def ccw(self):
        """The ccw field indicates counterclockwise ordering of vertex-coordinates orientation."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True  # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def convex(self):
        """The convex field is a hint to renderers whether all polygons in a shape are convex (true), or possibly concave (false)."""
        return self.__convex
    @convex.setter
    def convex(self, convex):
        if  convex is None:
            convex = True  # default
        assertValidSFBool(convex)
        self.__convex = convex
    @property # getter - - - - - - - - - -
    def creaseAngle(self):
        """[0,+infinity) creaseAngle defines angle (in radians) where adjacent polygons are drawn with sharp edges or smooth shading."""
        return self.__creaseAngle
    @creaseAngle.setter
    def creaseAngle(self, creaseAngle):
        if  creaseAngle is None:
            creaseAngle = 0  # default
        assertValidSFFloat(creaseAngle)
        assertNonNegative('creaseAngle', creaseAngle)
        self.__creaseAngle = creaseAngle
    @property # getter - - - - - - - - - -
    def crossSection(self):
        """The crossSection array defines a silhouette outline of the outer Extrusion surface."""
        return self.__crossSection
    @crossSection.setter
    def crossSection(self, crossSection):
        if  crossSection is None:
            crossSection = [(1, 1), (1, -1), (-1, -1), (-1, 1), (1, 1)]  # default
        assertValidMFVec2f(crossSection)
        self.__crossSection = crossSection
    @property # getter - - - - - - - - - -
    def endCap(self):
        """Whether end cap is drawn (similar to Cylinder bottom cap)."""
        return self.__endCap
    @endCap.setter
    def endCap(self, endCap):
        if  endCap is None:
            endCap = True  # default
        assertValidSFBool(endCap)
        self.__endCap = endCap
    @property # getter - - - - - - - - - -
    def orientation(self):
        """The orientation array is a list of axis-angle 4-tuple values applied at each spine-aligned cross-section plane."""
        return self.__orientation
    @orientation.setter
    def orientation(self, orientation):
        if  orientation is None:
            orientation = [(0, 0, 1, 0)]  # default
        assertValidMFRotation(orientation)
        self.__orientation = orientation
    @property # getter - - - - - - - - - -
    def scale(self):
        """(0,+infinity) scale is a list of 2D-scale parameters applied at each spine-aligned cross-section plane."""
        return self.__scale
    @scale.setter
    def scale(self, scale):
        if  scale is None:
            scale = [(1, 1)]  # default
        assertValidMFVec2f(scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def spine(self):
        """The spine array defines a center-line sequence of 3D points that define a piecewise-linear curve forming a series of connected vertices."""
        return self.__spine
    @spine.setter
    def spine(self, spine):
        if  spine is None:
            spine = [(0, 0, 0), (0, 1, 0)]  # default
        assertValidMFVec3f(spine)
        self.__spine = spine
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class FillProperties(_X3DAppearanceChildNode):
    """
    FillProperties indicates whether appearance is filled or hatched for associated geometry nodes inside the same Shape.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'FillProperties'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#FillProperties'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#FillProperties'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('filled', True, FieldType.SFBool, AccessType.inputOutput, 'FillProperties'),
        ('hatchColor', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'FillProperties'),
        ('hatched', True, FieldType.SFBool, AccessType.inputOutput, 'FillProperties'),
        ('hatchStyle', 1, FieldType.SFInt32, AccessType.inputOutput, 'FillProperties'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        filled=True,
        hatchColor=(1, 1, 1),
        hatched=True,
        hatchStyle=1,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode FillProperties __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.filled = filled
        self.hatchColor = hatchColor
        self.hatched = hatched
        self.hatchStyle = hatchStyle
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def filled(self):
        """Whether or not associated geometry is filled."""
        return self.__filled
    @filled.setter
    def filled(self, filled):
        if  filled is None:
            filled = True  # default
        assertValidSFBool(filled)
        self.__filled = filled
    @property # getter - - - - - - - - - -
    def hatchColor(self):
        """[0,1] Color of the hatch pattern."""
        return self.__hatchColor
    @hatchColor.setter
    def hatchColor(self, hatchColor):
        if  hatchColor is None:
            hatchColor = (1, 1, 1)  # default
        assertValidSFColor(hatchColor)
        assertZeroToOne('hatchColor', hatchColor)
        self.__hatchColor = hatchColor
    @property # getter - - - - - - - - - -
    def hatched(self):
        """Whether or not associated geometry is hatched."""
        return self.__hatched
    @hatched.setter
    def hatched(self, hatched):
        if  hatched is None:
            hatched = True  # default
        assertValidSFBool(hatched)
        self.__hatched = hatched
    @property # getter - - - - - - - - - -
    def hatchStyle(self):
        """hatchStyle selects a hatch pattern from ISO/IEC 9973 International Register of Graphical Items."""
        return self.__hatchStyle
    @hatchStyle.setter
    def hatchStyle(self, hatchStyle):
        if  hatchStyle is None:
            hatchStyle = 1  # default
        assertValidSFInt32(hatchStyle)
        assertNonNegative('hatchStyle', hatchStyle)
        self.__hatchStyle = hatchStyle
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class FloatVertexAttribute(_X3DVertexAttributeNode):
    """
    FloatVertexAttribute defines a set of per-vertex single-precision floating-point attributes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'FloatVertexAttribute'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shaders.html#FloatVertexAttribute'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#FloatVertexAttribute'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('name', '', FieldType.SFString, AccessType.initializeOnly, 'X3DVertexAttributeNode'),
        ('numComponents', 4, FieldType.SFInt32, AccessType.initializeOnly, 'FloatVertexAttribute'),
        ('value', [], FieldType.MFFloat, AccessType.inputOutput, 'FloatVertexAttribute'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        name='',
        numComponents=4,
        value=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode FloatVertexAttribute __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.numComponents = numComponents
        self.value = value
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def name(self):
        """Required name for this particular VertexAttribute instance."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def numComponents(self):
        """numComponents specifies how many consecutive floating-point values should be grouped together per vertex."""
        return self.__numComponents
    @numComponents.setter
    def numComponents(self, numComponents):
        if  numComponents is None:
            numComponents = 4  # default
        assertValidSFInt32(numComponents)
        assertGreaterThanEquals('numComponents', numComponents, 1)
        assertLessThanEquals('numComponents', numComponents, 4)
        self.__numComponents = numComponents
    @property # getter - - - - - - - - - -
    def value(self):
        """value specifies an arbitrary collection of floating-point values that will be passed to the shader as per-vertex information."""
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(value)
        self.__value = value
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class Fog(_X3DBindableNode, _X3DFogObject):
    """
    Fog simulates atmospheric effects by blending distant objects with fog color.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Fog'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalEffects.html#Fog'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Fog'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'X3DFogObject'),
        ('fogType', 'LINEAR', FieldType.SFString, AccessType.inputOutput, 'X3DFogObject'),
        ('visibilityRange', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DFogObject'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        color=(1, 1, 1),
        fogType='LINEAR',
        visibilityRange=0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Fog __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.color = color
        self.fogType = fogType
        self.visibilityRange = visibilityRange
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def color(self):
        """[0,1] Fog color."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = (1, 1, 1)  # default
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def fogType(self):
        """Specifies algorithm for rate of increasing Fog, either LINEAR or EXPONENTIAL."""
        return self.__fogType
    @fogType.setter
    def fogType(self, fogType):
        if  fogType is None:
            fogType = 'LINEAR'  # default
        assertValidSFString(fogType)
        assertValidFogType('fogType', fogType)
        self.__fogType = fogType
    @property # getter - - - - - - - - - -
    def visibilityRange(self):
        """Distance in meters where objects are totally obscured by the fog, using local coordinate system."""
        return self.__visibilityRange
    @visibilityRange.setter
    def visibilityRange(self, visibilityRange):
        if  visibilityRange is None:
            visibilityRange = 0  # default
        assertValidSFFloat(visibilityRange)
        assertNonNegative('visibilityRange', visibilityRange)
        self.__visibilityRange = visibilityRange
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class FogCoordinate(_X3DGeometricPropertyNode):
    """
    FogCoordinate defines a set of explicit fog depths on a per-vertex basis, overriding Fog visibilityRange.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'FogCoordinate'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalEffects.html#FogCoordinate'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#FogCoordinate'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('depth', [], FieldType.MFFloat, AccessType.inputOutput, 'FogCoordinate'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        depth=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode FogCoordinate __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.depth = depth
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def depth(self):
        """depth contains a set of 3D coordinate (triplet) point values."""
        return self.__depth
    @depth.setter
    def depth(self, depth):
        if  depth is None:
            depth = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(depth)
        assertZeroToOne('depth', depth)
        self.__depth = depth
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class FontStyle(_X3DFontStyleNode):
    """
    FontStyle is an X3DFontStyleNode that defines the size, family, justification, and other styles used by Text nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'FontStyle'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/text.html#FontStyle'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#FontStyle'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('family', ["SERIF"], FieldType.MFString, AccessType.inputOutput, 'FontStyle'),
        ('horizontal', True, FieldType.SFBool, AccessType.inputOutput, 'FontStyle'),
        ('justify', ["BEGIN"], FieldType.MFString, AccessType.inputOutput, 'FontStyle'),
        ('language', '', FieldType.SFString, AccessType.inputOutput, 'FontStyle'),
        ('leftToRight', True, FieldType.SFBool, AccessType.inputOutput, 'FontStyle'),
        ('size', 1.0, FieldType.SFFloat, AccessType.inputOutput, 'FontStyle'),
        ('spacing', 1.0, FieldType.SFFloat, AccessType.inputOutput, 'FontStyle'),
        ('topToBottom', True, FieldType.SFBool, AccessType.inputOutput, 'FontStyle'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', 'PLAIN', FieldType.SFString, AccessType.inputOutput, 'FontStyle')]
    def __init__(self,
        family=None,
        horizontal=True,
        justify=None,
        language='',
        leftToRight=True,
        size=1.0,
        spacing=1.0,
        topToBottom=True,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_='PLAIN'):
        # if _DEBUG: print('...DEBUG... in ConcreteNode FontStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.family = family
        self.horizontal = horizontal
        self.justify = justify
        self.language = language
        self.leftToRight = leftToRight
        self.size = size
        self.spacing = spacing
        self.topToBottom = topToBottom
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def family(self):
        """Array of quoted font family names in preference order, browsers use the first supported family."""
        return self.__family
    @family.setter
    def family(self, family):
        if  family is None:
            family = ["SERIF"]  # default
        assertValidMFString(family)
        self.__family = family
    @property # getter - - - - - - - - - -
    def horizontal(self):
        """Whether text direction is horizontal (true) or vertical (false)."""
        return self.__horizontal
    @horizontal.setter
    def horizontal(self, horizontal):
        if  horizontal is None:
            horizontal = True  # default
        assertValidSFBool(horizontal)
        self.__horizontal = horizontal
    @property # getter - - - - - - - - - -
    def justify(self):
        """The justify field determines horizontal and vertical alignment of text layout, relative to the origin of the object coordinate system."""
        return self.__justify
    @justify.setter
    def justify(self, justify):
        if  justify is None:
            justify = ["BEGIN"]  # default
        assertValidMFString(justify)
        assertValidJustify('justify', justify)
        self.__justify = justify
    @property # getter - - - - - - - - - -
    def language(self):
        """Language codes consist of a primary code and a (possibly empty) series of subcodes."""
        return self.__language
    @language.setter
    def language(self, language):
        if  language is None:
            language = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(language)
        self.__language = language
    @property # getter - - - - - - - - - -
    def leftToRight(self):
        """Whether text direction is left-to-right (true) or right-to-left (false)."""
        return self.__leftToRight
    @leftToRight.setter
    def leftToRight(self, leftToRight):
        if  leftToRight is None:
            leftToRight = True  # default
        assertValidSFBool(leftToRight)
        self.__leftToRight = leftToRight
    @property # getter - - - - - - - - - -
    def size(self):
        """(0,+infinity) Nominal height (in local coordinate system) of text glyphs, also sets default spacing between adjacent lines of text."""
        return self.__size
    @size.setter
    def size(self, size):
        if  size is None:
            size = 1.0  # default
        assertValidSFFloat(size)
        assertPositive('size', size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def spacing(self):
        """[0,+infinity) Adjustment factor for line spacing between adjacent lines of text."""
        return self.__spacing
    @spacing.setter
    def spacing(self, spacing):
        if  spacing is None:
            spacing = 1.0  # default
        assertValidSFFloat(spacing)
        assertNonNegative('spacing', spacing)
        self.__spacing = spacing
    @property # getter - - - - - - - - - -
    def topToBottom(self):
        """Whether text direction is top-to-bottom (true) or bottom-to-top (false)."""
        return self.__topToBottom
    @topToBottom.setter
    def topToBottom(self, topToBottom):
        if  topToBottom is None:
            topToBottom = True  # default
        assertValidSFBool(topToBottom)
        self.__topToBottom = topToBottom
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = 'PLAIN'  # default
        assertValidSFString(style_)
        assertValidFontStyle('style_', style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class ForcePhysicsModel(_X3DParticlePhysicsModelNode):
    """
    ForcePhysicsModel applies a constant force value to the particles.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ForcePhysicsModel'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#ForcePhysicsModel'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ForcePhysicsModel'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DParticlePhysicsModelNode'),
        ('force', (0, -9.8, 0), FieldType.SFVec3f, AccessType.inputOutput, 'ForcePhysicsModel'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        enabled=True,
        force=(0, -9.8, 0),
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ForcePhysicsModel __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.force = force
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def force(self):
        """(-infinity,+infinity) force field indicates strength and direction of the propelling force on the particles (for example, default is Earth's gravity)."""
        return self.__force
    @force.setter
    def force(self, force):
        if  force is None:
            force = (0, -9.8, 0)  # default
        assertValidSFVec3f(force)
        self.__force = force
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class Gain(_X3DSoundProcessingNode):
    """
    The Gain node amplifies or deamplifies the input signal.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Gain'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#Gain'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Gain'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('channelCountMode', 'MAX', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('channelInterpretation', 'SPEAKERS', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('tailTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'Gain'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        channelCountMode='MAX',
        channelInterpretation='SPEAKERS',
        description='',
        enabled=True,
        gain=1,
        pauseTime=0,
        resumeTime=0,
        startTime=0,
        stopTime=0,
        tailTime=0,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Gain __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.pauseTime = pauseTime
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
        self.tailTime = tailTime
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'MAX'  # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'SPEAKERS'  # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1  # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0  # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0  # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0  # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0  # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def tailTime(self):
        """[0,+infinity) tailTime is duration of time that a node continues to provide output signal after the input signal becomes silent."""
        return self.__tailTime
    @tailTime.setter
    def tailTime(self, tailTime):
        if  tailTime is None:
            tailTime = 0  # default
        assertValidSFTime(tailTime)
        assertNonNegative('tailTime', tailTime)
        self.__tailTime = tailTime
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DSoundChannelNode|X3DSoundProcessingNode|X3DSoundSourceNode] The children field specifies audio-graph sound sources providing input signals for this node."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class GeneratedCubeMapTexture(_X3DEnvironmentTextureNode):
    """
    GeneratedCubeMapTexture is a texture node that defines a cubic environment map that sources its data from internally generated images.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'GeneratedCubeMapTexture'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalTexturing.html#GeneratedCubeMapTexture'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeneratedCubeMapTexture'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureNode'),
        ('size', 128, FieldType.SFInt32, AccessType.initializeOnly, 'GeneratedCubeMapTexture'),
        ('update', 'NONE', FieldType.SFString, AccessType.inputOutput, 'GeneratedCubeMapTexture'),
        ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly, 'GeneratedCubeMapTexture'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        description='',
        size=128,
        update='NONE',
        textureProperties=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode GeneratedCubeMapTexture __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.size = size
        self.update = update
        self.textureProperties = textureProperties
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def size(self):
        """(0,+infinity) size indicates the resolution of the generated images in number of pixels per side."""
        return self.__size
    @size.setter
    def size(self, size):
        if  size is None:
            size = 128  # default
        assertValidSFInt32(size)
        assertPositive('size', size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def update(self):
        """update controls regeneration of the texture."""
        return self.__update
    @update.setter
    def update(self, update):
        if  update is None:
            update = 'NONE'  # default
        assertValidSFString(update)
        assertValidGeneratedCubeMapTextureUpdate('update', update)
        self.__update = update
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        """[TextureProperties] Single contained TextureProperties node that can specify additional visual attributes applied to corresponding texture images."""
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties):
        if  textureProperties is None:
            textureProperties = None  # default
        assertValidSFNode(textureProperties)
        if not textureProperties is None and not isinstance(textureProperties,(TextureProperties,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(textureProperties) + ' does not match required node type (TextureProperties,ProtoInstance) and is invalid')
        self.__textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.textureProperties
    # output function - - - - - - - - - -

class GeoCoordinate(_X3DCoordinateNode):
    """
    GeoCoordinate builds geometry as a set of geographic 3D coordinates.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'GeoCoordinate'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoCoordinate'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoCoordinate'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'GeoCoordinate'),
        ('point', [], FieldType.MFVec3d, AccessType.inputOutput, 'GeoCoordinate'),
        ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly, 'GeoCoordinate'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        geoSystem=None,
        point=None,
        geoOrigin=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode GeoCoordinate __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.geoSystem = geoSystem
        self.point = point
        self.geoOrigin = geoOrigin
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"]  # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def point(self):
        """point contains a set of actual 3D geographic coordinates, provided in geoSystem format can split strings if desired: "x1 y1 z1 x2 y2 z2" or "x1 y1 z1", "x2 y2 z2"."""
        return self.__point
    @point.setter
    def point(self, point):
        if  point is None:
            point = MFVec3d.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec3d.DEFAULT_VALUE()))
        assertValidMFVec3d(point)
        self.__point = point
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        """[GeoOrigin] Single contained GeoOrigin node that can specify a local coordinate frame for extended precision."""
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin):
        if  geoOrigin is None:
            geoOrigin = None  # default
        assertValidSFNode(geoOrigin)
        if not geoOrigin is None and not isinstance(geoOrigin,(GeoOrigin,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(geoOrigin) + ' does not match required node type (GeoOrigin,ProtoInstance) and is invalid')
        self.__geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.geoOrigin or self.IS or self.metadata
    # output function - - - - - - - - - -

class GeoElevationGrid(_X3DGeometryNode):
    """
    GeoElevationGrid is a geometry node defining a rectangular height field, with default values for a 1m by 1m square at height 0.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'GeoElevationGrid'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoElevationGrid'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoElevationGrid'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'GeoElevationGrid'),
        ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'GeoElevationGrid'),
        ('creaseAngle', 0, FieldType.SFDouble, AccessType.initializeOnly, 'GeoElevationGrid'),
        ('geoGridOrigin', (0, 0, 0), FieldType.SFVec3d, AccessType.initializeOnly, 'GeoElevationGrid'),
        ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'GeoElevationGrid'),
        ('height', [0, 0], FieldType.MFDouble, AccessType.initializeOnly, 'GeoElevationGrid'),
        ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'GeoElevationGrid'),
        ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'GeoElevationGrid'),
        ('xDimension', 0, FieldType.SFInt32, AccessType.initializeOnly, 'GeoElevationGrid'),
        ('xSpacing', 1.0, FieldType.SFDouble, AccessType.initializeOnly, 'GeoElevationGrid'),
        ('yScale', 1, FieldType.SFFloat, AccessType.inputOutput, 'GeoElevationGrid'),
        ('zDimension', 0, FieldType.SFInt32, AccessType.initializeOnly, 'GeoElevationGrid'),
        ('zSpacing', 1.0, FieldType.SFDouble, AccessType.initializeOnly, 'GeoElevationGrid'),
        ('color', None, FieldType.SFNode, AccessType.inputOutput, 'GeoElevationGrid'),
        ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly, 'GeoElevationGrid'),
        ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'GeoElevationGrid'),
        ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'GeoElevationGrid'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        ccw=True,
        colorPerVertex=True,
        creaseAngle=0,
        geoGridOrigin=(0, 0, 0),
        geoSystem=None,
        height=None,
        normalPerVertex=True,
        solid=True,
        xDimension=0,
        xSpacing=1.0,
        yScale=1,
        zDimension=0,
        zSpacing=1.0,
        color=None,
        geoOrigin=None,
        normal=None,
        texCoord=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode GeoElevationGrid __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.creaseAngle = creaseAngle
        self.geoGridOrigin = geoGridOrigin
        self.geoSystem = geoSystem
        self.height = height
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.xDimension = xDimension
        self.xSpacing = xSpacing
        self.yScale = yScale
        self.zDimension = zDimension
        self.zSpacing = zSpacing
        self.color = color
        self.geoOrigin = geoOrigin
        self.normal = normal
        self.texCoord = texCoord
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True  # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color node color values are applied to each point vertex (true) or per quadrilateral (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True  # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def creaseAngle(self):
        """(0,+infinity) creaseAngle defines angle (in radians) for determining whether adjacent polygons are drawn with sharp edges or smooth shading."""
        return self.__creaseAngle
    @creaseAngle.setter
    def creaseAngle(self, creaseAngle):
        if  creaseAngle is None:
            creaseAngle = 0  # default
        assertValidSFDouble(creaseAngle)
        assertNonNegative('creaseAngle', creaseAngle)
        self.__creaseAngle = creaseAngle
    @property # getter - - - - - - - - - -
    def geoGridOrigin(self):
        """Geographic coordinate for southwest (lower-left) corner of height dataset."""
        return self.__geoGridOrigin
    @geoGridOrigin.setter
    def geoGridOrigin(self, geoGridOrigin):
        if  geoGridOrigin is None:
            geoGridOrigin = (0, 0, 0)  # default
        assertValidSFVec3d(geoGridOrigin)
        self.__geoGridOrigin = geoGridOrigin
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"]  # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def height(self):
        """Contains xDimension rows * zDimension columns floating-point values for elevation above ellipsoid."""
        return self.__height
    @height.setter
    def height(self, height):
        if  height is None:
            height = [0, 0]  # default
        assertValidMFDouble(height)
        self.__height = height
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or per quadrilateral (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True  # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def xDimension(self):
        """(0,+infinity) Number of elements in the height array along east-west X direction."""
        return self.__xDimension
    @xDimension.setter
    def xDimension(self, xDimension):
        if  xDimension is None:
            xDimension = 0  # default
        assertValidSFInt32(xDimension)
        assertNonNegative('xDimension', xDimension)
        self.__xDimension = xDimension
    @property # getter - - - - - - - - - -
    def xSpacing(self):
        """(0,+infinity) Distance between grid-array vertices along east-west X direction."""
        return self.__xSpacing
    @xSpacing.setter
    def xSpacing(self, xSpacing):
        if  xSpacing is None:
            xSpacing = 1.0  # default
        assertValidSFDouble(xSpacing)
        assertPositive('xSpacing', xSpacing)
        self.__xSpacing = xSpacing
    @property # getter - - - - - - - - - -
    def yScale(self):
        """[0,+infinity) Vertical exaggeration of displayed data produced from the height array."""
        return self.__yScale
    @yScale.setter
    def yScale(self, yScale):
        if  yScale is None:
            yScale = 1  # default
        assertValidSFFloat(yScale)
        assertNonNegative('yScale', yScale)
        self.__yScale = yScale
    @property # getter - - - - - - - - - -
    def zDimension(self):
        """(0,+infinity) Number of elements in the height array along north-south Z direction."""
        return self.__zDimension
    @zDimension.setter
    def zDimension(self, zDimension):
        if  zDimension is None:
            zDimension = 0  # default
        assertValidSFInt32(zDimension)
        assertNonNegative('zDimension', zDimension)
        self.__zDimension = zDimension
    @property # getter - - - - - - - - - -
    def zSpacing(self):
        """(0,+infinity) Distance between grid-array vertices along north-south Z direction."""
        return self.__zSpacing
    @zSpacing.setter
    def zSpacing(self, zSpacing):
        if  zSpacing is None:
            zSpacing = 1.0  # default
        assertValidSFDouble(zSpacing)
        assertPositive('zSpacing', zSpacing)
        self.__zSpacing = zSpacing
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that can specify color values applied to corresponding vertices according to colorPerVertex field."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None  # default
        assertValidSFNode(color)
        if not color is None and not isinstance(color,(_X3DColorNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not match required node type (_X3DColorNode,ProtoInstance) and is invalid')
        self.__color = color
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        """[GeoOrigin] Single contained GeoOrigin node that can specify a local coordinate frame for extended precision."""
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin):
        if  geoOrigin is None:
            geoOrigin = None  # default
        assertValidSFNode(geoOrigin)
        if not geoOrigin is None and not isinstance(geoOrigin,(GeoOrigin,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(geoOrigin) + ' does not match required node type (GeoOrigin,ProtoInstance) and is invalid')
        self.__geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that can specify perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None  # default
        assertValidSFNode(normal)
        if not normal is None and not isinstance(normal,(_X3DNormalNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not match required node type (_X3DNormalNode,ProtoInstance) and is invalid')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that can specify coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None  # default
        assertValidSFNode(texCoord)
        if not texCoord is None and not isinstance(texCoord,(_X3DSingleTextureCoordinateNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not match required node type (_X3DSingleTextureCoordinateNode,ProtoInstance) and is invalid')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.color or self.geoOrigin or self.IS or self.metadata or self.normal or self.texCoord
    # output function - - - - - - - - - -

class GeoLocation(_X3DGroupingNode):
    """
    GeoLocation positions a regular X3D model onto earth's surface.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'GeoLocation'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoLocation'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoLocation'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('geoCoords', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput, 'GeoLocation'),
        ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'GeoLocation'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly, 'GeoLocation'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        geoCoords=(0, 0, 0),
        geoSystem=None,
        visible=True,
        geoOrigin=None,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode GeoLocation __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.geoCoords = geoCoords
        self.geoSystem = geoSystem
        self.visible = visible
        self.geoOrigin = geoOrigin
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def geoCoords(self):
        """Geographic location (specified in current geoSystem coordinates) for children geometry (specified in relative coordinate system, in meters)."""
        return self.__geoCoords
    @geoCoords.setter
    def geoCoords(self, geoCoords):
        if  geoCoords is None:
            geoCoords = (0, 0, 0)  # default
        assertValidSFVec3d(geoCoords)
        self.__geoCoords = geoCoords
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"]  # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        """[GeoOrigin] Single contained GeoOrigin node that can specify a local coordinate frame for extended precision."""
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin):
        if  geoOrigin is None:
            geoOrigin = None  # default
        assertValidSFNode(geoOrigin)
        if not geoOrigin is None and not isinstance(geoOrigin,(GeoOrigin,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(geoOrigin) + ' does not match required node type (GeoOrigin,ProtoInstance) and is invalid')
        self.__geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.geoOrigin or self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class GeoLOD(_X3DChildNode, _X3DBoundedObject):
    """
    Note that MFNode rootNode field can contain multiple nodes and has accessType inputOutput. Meanwhile MFNode children field is outputOnly, unlike other X3DGroupingNode exemplars.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'GeoLOD'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoLOD'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoLOD'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('center', (0, 0, 0), FieldType.SFVec3d, AccessType.initializeOnly, 'GeoLOD'),
        ('child1Url', [], FieldType.MFString, AccessType.initializeOnly, 'GeoLOD'),
        ('child2Url', [], FieldType.MFString, AccessType.initializeOnly, 'GeoLOD'),
        ('child3Url', [], FieldType.MFString, AccessType.initializeOnly, 'GeoLOD'),
        ('child4Url', [], FieldType.MFString, AccessType.initializeOnly, 'GeoLOD'),
        ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'GeoLOD'),
        ('range', 10, FieldType.SFFloat, AccessType.initializeOnly, 'GeoLOD'),
        ('rootUrl', [], FieldType.MFString, AccessType.initializeOnly, 'GeoLOD'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly, 'GeoLOD'),
        ('rootNode', [], FieldType.MFNode, AccessType.initializeOnly, 'GeoLOD'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        center=(0, 0, 0),
        child1Url=None,
        child2Url=None,
        child3Url=None,
        child4Url=None,
        geoSystem=None,
        range=10,
        rootUrl=None,
        visible=True,
        geoOrigin=None,
        rootNode=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode GeoLOD __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.center = center
        self.child1Url = child1Url
        self.child2Url = child2Url
        self.child3Url = child3Url
        self.child4Url = child4Url
        self.geoSystem = geoSystem
        self.range = range
        self.rootUrl = rootUrl
        self.visible = visible
        self.geoOrigin = geoOrigin
        self.rootNode = rootNode
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        """Viewer range from geographic-coordinates center triggers quadtree loading/unloading."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0)  # default
        assertValidSFVec3d(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def child1Url(self):
        """quadtree geometry loaded when viewer is within range."""
        return self.__child1Url
    @child1Url.setter
    def child1Url(self, child1Url):
        if  child1Url is None:
            child1Url = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(child1Url)
        self.__child1Url = child1Url
    @property # getter - - - - - - - - - -
    def child2Url(self):
        """quadtree geometry loaded when viewer is within range."""
        return self.__child2Url
    @child2Url.setter
    def child2Url(self, child2Url):
        if  child2Url is None:
            child2Url = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(child2Url)
        self.__child2Url = child2Url
    @property # getter - - - - - - - - - -
    def child3Url(self):
        """quadtree geometry loaded when viewer is within range."""
        return self.__child3Url
    @child3Url.setter
    def child3Url(self, child3Url):
        if  child3Url is None:
            child3Url = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(child3Url)
        self.__child3Url = child3Url
    @property # getter - - - - - - - - - -
    def child4Url(self):
        """quadtree geometry loaded when viewer is within range."""
        return self.__child4Url
    @child4Url.setter
    def child4Url(self, child4Url):
        if  child4Url is None:
            child4Url = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(child4Url)
        self.__child4Url = child4Url
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"]  # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def range(self):
        """(0,+infinity) Viewer range from geographic-coordinates center triggers quadtree loading/unloading."""
        return self.__range
    @range.setter
    def range(self, range):
        if  range is None:
            range = 10  # default
        assertValidSFFloat(range)
        assertNonNegative('range', range)
        self.__range = range
    @property # getter - - - - - - - - - -
    def rootUrl(self):
        """url for scene providing geometry for the root tile."""
        return self.__rootUrl
    @rootUrl.setter
    def rootUrl(self, rootUrl):
        if  rootUrl is None:
            rootUrl = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(rootUrl)
        self.__rootUrl = rootUrl
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        """[GeoOrigin] Single contained GeoOrigin node that can specify a local coordinate frame for extended precision."""
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin):
        if  geoOrigin is None:
            geoOrigin = None  # default
        assertValidSFNode(geoOrigin)
        if not geoOrigin is None and not isinstance(geoOrigin,(GeoOrigin,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(geoOrigin) + ' does not match required node type (GeoOrigin,ProtoInstance) and is invalid')
        self.__geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def rootNode(self):
        """Geometry for the root tile."""
        return self.__rootNode
    @rootNode.setter
    def rootNode(self, rootNode):
        if  rootNode is None:
            rootNode = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(rootNode)
        self.__rootNode = rootNode
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.geoOrigin or self.IS or self.metadata or (len(self.rootNode) > 0)
    # output function - - - - - - - - - -

class GeoMetadata(_X3DInfoNode, _X3DUrlObject):
    """
    GeoMetadata includes a generic subset of metadata about the geographic data.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'GeoMetadata'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoMetadata'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoMetadata'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('autoRefresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('autoRefreshTimeLimit', 3600, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DUrlObject'),
        ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
        ('summary', [], FieldType.MFString, AccessType.inputOutput, 'GeoMetadata'),
        ('url', [], FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
        ('data', [], FieldType.MFNode, AccessType.inputOutput, 'GeoMetadata'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        autoRefresh=0,
        autoRefreshTimeLimit=3600,
        description='',
        load=True,
        summary=None,
        url=None,
        data=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode GeoMetadata __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.autoRefresh = autoRefresh
        self.autoRefreshTimeLimit = autoRefreshTimeLimit
        self.description = description
        self.load = load
        self.summary = summary
        self.url = url
        self.data = data
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def autoRefresh(self):
        """autoRefresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__autoRefresh
    @autoRefresh.setter
    def autoRefresh(self, autoRefresh):
        if  autoRefresh is None:
            autoRefresh = 0  # default
        assertValidSFTime(autoRefresh)
        assertNonNegative('autoRefresh', autoRefresh)
        self.__autoRefresh = autoRefresh
    @property # getter - - - - - - - - - -
    def autoRefreshTimeLimit(self):
        """autoRefreshTimeLimit defines maximum duration that automatic refresh activity can occur."""
        return self.__autoRefreshTimeLimit
    @autoRefreshTimeLimit.setter
    def autoRefreshTimeLimit(self, autoRefreshTimeLimit):
        if  autoRefreshTimeLimit is None:
            autoRefreshTimeLimit = 3600  # default
        assertValidSFTime(autoRefreshTimeLimit)
        assertNonNegative('autoRefreshTimeLimit', autoRefreshTimeLimit)
        self.__autoRefreshTimeLimit = autoRefreshTimeLimit
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True  # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def summary(self):
        """The summary string array contains a set of keyword/value pairs, with each keyword and its subsequent value contained in separate strings."""
        return self.__summary
    @summary.setter
    def summary(self, summary):
        if  summary is None:
            summary = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(summary)
        self.__summary = summary
    @property # getter - - - - - - - - - -
    def url(self):
        """Hypertext link to an external, complete metadata description."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def data(self):
        """DEF list of all nodes that implement this data."""
        return self.__data
    @data.setter
    def data(self, data):
        if  data is None:
            data = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(data)
        self.__data = data
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.data) > 0)
    # output function - - - - - - - - - -

class GeoOrigin(_X3DNode):
    """
    GeoOrigin is deprecated and discouraged (but nevertheless allowed) in X3D version 3.3. GeoOrigin is restored in X3D version 4.0 for special use on devices with limited floating-point resolution.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'GeoOrigin'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoOrigin'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoOrigin'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('geoCoords', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput, 'GeoOrigin'),
        ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'GeoOrigin'),
        ('rotateYUp', False, FieldType.SFBool, AccessType.initializeOnly, 'GeoOrigin'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        geoCoords=(0, 0, 0),
        geoSystem=None,
        rotateYUp=False,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode GeoOrigin __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.geoCoords = geoCoords
        self.geoSystem = geoSystem
        self.rotateYUp = rotateYUp
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def geoCoords(self):
        """Defines absolute geographic location (and implicit local coordinate frame)."""
        return self.__geoCoords
    @geoCoords.setter
    def geoCoords(self, geoCoords):
        if  geoCoords is None:
            geoCoords = (0, 0, 0)  # default
        assertValidSFVec3d(geoCoords)
        self.__geoCoords = geoCoords
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"]  # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def rotateYUp(self):
        """Whether to rotate coordinates of nodes using this GeoOrigin so that local-up direction aligns with VRML Y axis rotateYUp false means local up-direction is relative to planet surface rotateYUp true allows proper operation of NavigationInfo modes FLY, WALK."""
        return self.__rotateYUp
    @rotateYUp.setter
    def rotateYUp(self, rotateYUp):
        if  rotateYUp is None:
            rotateYUp = False  # default
        assertValidSFBool(rotateYUp)
        self.__rotateYUp = rotateYUp
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class GeoPositionInterpolator(_X3DInterpolatorNode):
    """
    GeoPositionInterpolator animates objects within a geographic coordinate system.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'GeoPositionInterpolator'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoPositionInterpolator'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoPositionInterpolator'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'GeoPositionInterpolator'),
        ('key', [], FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
        ('keyValue', [], FieldType.MFVec3d, AccessType.inputOutput, 'GeoPositionInterpolator'),
        ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly, 'GeoPositionInterpolator'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        geoSystem=None,
        key=None,
        keyValue=None,
        geoOrigin=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode GeoPositionInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.geoSystem = geoSystem
        self.key = key
        self.keyValue = keyValue
        self.geoOrigin = geoOrigin
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"]  # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFVec3d.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec3d.DEFAULT_VALUE()))
        assertValidMFVec3d(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        """[GeoOrigin] Single contained GeoOrigin node that can specify a local coordinate frame for extended precision."""
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin):
        if  geoOrigin is None:
            geoOrigin = None  # default
        assertValidSFNode(geoOrigin)
        if not geoOrigin is None and not isinstance(geoOrigin,(GeoOrigin,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(geoOrigin) + ' does not match required node type (GeoOrigin,ProtoInstance) and is invalid')
        self.__geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.geoOrigin or self.IS or self.metadata
    # output function - - - - - - - - - -

class GeoProximitySensor(_X3DEnvironmentalSensorNode):
    """
    GeoProximitySensor generates events when the viewer enters, exits and moves within a region of space (defined by a box).
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'GeoProximitySensor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoProximitySensor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoProximitySensor'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('center', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput, 'GeoProximitySensor'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSensorNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('geoCenter', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput, 'GeoProximitySensor'),
        ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'GeoProximitySensor'),
        ('size', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'X3DEnvironmentalSensorNode'),
        ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly, 'GeoProximitySensor'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        center=(0, 0, 0),
        description='',
        enabled=True,
        geoCenter=(0, 0, 0),
        geoSystem=None,
        size=(0, 0, 0),
        geoOrigin=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode GeoProximitySensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.center = center
        self.description = description
        self.enabled = enabled
        self.geoCenter = geoCenter
        self.geoSystem = geoSystem
        self.size = size
        self.geoOrigin = geoOrigin
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def center(self):
        """(starting with v3."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0)  # default
        assertValidSFVec3d(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def geoCenter(self):
        """(deprecated as of v3."""
        return self.__geoCenter
    @geoCenter.setter
    def geoCenter(self, geoCenter):
        if  geoCenter is None:
            geoCenter = (0, 0, 0)  # default
        assertValidSFVec3d(geoCenter)
        self.__geoCenter = geoCenter
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"]  # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def size(self):
        """[0,+infinity) size of Proximity box around center location, oriented within local transformation frame."""
        return self.__size
    @size.setter
    def size(self, size):
        if  size is None:
            size = (0, 0, 0)  # default
        assertValidSFVec3f(size)
        assertNonNegative('size', size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        """[GeoOrigin] Single contained GeoOrigin node that can specify a local coordinate frame for extended precision."""
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin):
        if  geoOrigin is None:
            geoOrigin = None  # default
        assertValidSFNode(geoOrigin)
        if not geoOrigin is None and not isinstance(geoOrigin,(GeoOrigin,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(geoOrigin) + ' does not match required node type (GeoOrigin,ProtoInstance) and is invalid')
        self.__geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.geoOrigin or self.IS or self.metadata
    # output function - - - - - - - - - -

class GeoTouchSensor(_X3DTouchSensorNode):
    """
    GeoTouchSensor returns geographic coordinates for the object being selected.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'GeoTouchSensor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoTouchSensor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoTouchSensor'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSensorNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'GeoTouchSensor'),
        ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly, 'GeoTouchSensor'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        description='',
        enabled=True,
        geoSystem=None,
        geoOrigin=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode GeoTouchSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.enabled = enabled
        self.geoSystem = geoSystem
        self.geoOrigin = geoOrigin
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (G D), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"]  # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        """[GeoOrigin] Single contained GeoOrigin node that can specify a local coordinate frame for extended precision."""
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin):
        if  geoOrigin is None:
            geoOrigin = None  # default
        assertValidSFNode(geoOrigin)
        if not geoOrigin is None and not isinstance(geoOrigin,(GeoOrigin,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(geoOrigin) + ' does not match required node type (GeoOrigin,ProtoInstance) and is invalid')
        self.__geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.geoOrigin or self.IS or self.metadata
    # output function - - - - - - - - - -

class GeoTransform(_X3DGroupingNode):
    """
    GeoTransform is a Grouping node that can contain most nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'GeoTransform'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoTransform'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoTransform'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('geoCenter', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput, 'GeoTransform'),
        ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'GeoTransform'),
        ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'GeoTransform'),
        ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'GeoTransform'),
        ('scaleOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'GeoTransform'),
        ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'GeoTransform'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly, 'GeoTransform'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        geoCenter=(0, 0, 0),
        geoSystem=None,
        rotation=(0, 0, 1, 0),
        scale=(1, 1, 1),
        scaleOrientation=(0, 0, 1, 0),
        translation=(0, 0, 0),
        visible=True,
        geoOrigin=None,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode GeoTransform __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.geoCenter = geoCenter
        self.geoSystem = geoSystem
        self.rotation = rotation
        self.scale = scale
        self.scaleOrientation = scaleOrientation
        self.translation = translation
        self.visible = visible
        self.geoOrigin = geoOrigin
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def geoCenter(self):
        """Translation offset from origin of local coordinate system, applied prior to rotation or scaling."""
        return self.__geoCenter
    @geoCenter.setter
    def geoCenter(self, geoCenter):
        if  geoCenter is None:
            geoCenter = (0, 0, 0)  # default
        assertValidSFVec3d(geoCenter)
        self.__geoCenter = geoCenter
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"]  # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def rotation(self):
        """Orientation (axis, angle in radians) of children relative to local coordinate system."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = (0, 0, 1, 0)  # default
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        """Non-uniform x-y-z scale of child coordinate system, adjusted by center and scaleOrientation."""
        return self.__scale
    @scale.setter
    def scale(self, scale):
        if  scale is None:
            scale = (1, 1, 1)  # default
        assertValidSFVec3f(scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def scaleOrientation(self):
        """Preliminary rotation of coordinate sys tem before scaling (to allow scaling around arbitrary orientations)."""
        return self.__scaleOrientation
    @scaleOrientation.setter
    def scaleOrientation(self, scaleOrientation):
        if  scaleOrientation is None:
            scaleOrientation = (0, 0, 1, 0)  # default
        assertValidSFRotation(scaleOrientation)
        self.__scaleOrientation = scaleOrientation
    @property # getter - - - - - - - - - -
    def translation(self):
        """Position (x, y, z in meters) of children relative to local coordinate system."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0, 0)  # default
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        """[GeoOrigin] Single contained GeoOrigin node that can specify a local coordinate frame for extended precision."""
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin):
        if  geoOrigin is None:
            geoOrigin = None  # default
        assertValidSFNode(geoOrigin)
        if not geoOrigin is None and not isinstance(geoOrigin,(GeoOrigin,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(geoOrigin) + ' does not match required node type (GeoOrigin,ProtoInstance) and is invalid')
        self.__geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.geoOrigin or self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class GeoViewpoint(_X3DViewpointNode):
    """
    GeoViewpoint specifies viewpoints using geographic coordinates.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'GeoViewpoint'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoViewpoint'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoViewpoint'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('centerOfRotation', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput, 'GeoViewpoint'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DViewpointNode'),
        ('farDistance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DViewpointNode'),
        ('fieldOfView', 0.7854, FieldType.SFFloat, AccessType.inputOutput, 'GeoViewpoint'),
        ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'GeoViewpoint'),
        ('jump', True, FieldType.SFBool, AccessType.inputOutput, 'X3DViewpointNode'),
        ('nearDistance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DViewpointNode'),
        ('orientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'X3DViewpointNode'),
        ('position', (0, 0, 100000), FieldType.SFVec3d, AccessType.inputOutput, 'GeoViewpoint'),
        ('retainUserOffsets', False, FieldType.SFBool, AccessType.inputOutput, 'X3DViewpointNode'),
        ('speedFactor', 1.0, FieldType.SFFloat, AccessType.initializeOnly, 'GeoViewpoint'),
        ('viewAll', False, FieldType.SFBool, AccessType.inputOutput, 'X3DViewpointNode'),
        ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly, 'GeoViewpoint'),
        ('navigationInfo', None, FieldType.SFNode, AccessType.inputOutput, 'X3DViewpointNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        centerOfRotation=(0, 0, 0),
        description='',
        farDistance=-1,
        fieldOfView=0.7854,
        geoSystem=None,
        jump=True,
        nearDistance=-1,
        orientation=(0, 0, 1, 0),
        position=(0, 0, 100000),
        retainUserOffsets=False,
        speedFactor=1.0,
        viewAll=False,
        geoOrigin=None,
        navigationInfo=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode GeoViewpoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.centerOfRotation = centerOfRotation
        self.description = description
        self.farDistance = farDistance
        self.fieldOfView = fieldOfView
        self.geoSystem = geoSystem
        self.jump = jump
        self.nearDistance = nearDistance
        self.orientation = orientation
        self.position = position
        self.retainUserOffsets = retainUserOffsets
        self.speedFactor = speedFactor
        self.viewAll = viewAll
        self.geoOrigin = geoOrigin
        self.navigationInfo = navigationInfo
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def centerOfRotation(self):
        """centerOfRotation specifies center point about which to rotate user's eyepoint when in EXAMINE or LOOKAT mode."""
        return self.__centerOfRotation
    @centerOfRotation.setter
    def centerOfRotation(self, centerOfRotation):
        if  centerOfRotation is None:
            centerOfRotation = (0, 0, 0)  # default
        assertValidSFVec3d(centerOfRotation)
        self.__centerOfRotation = centerOfRotation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def farDistance(self):
        """or (0,+infinity) farDistance defines maximum clipping plane distance allowed for object display."""
        return self.__farDistance
    @farDistance.setter
    def farDistance(self, farDistance):
        if  farDistance is None:
            farDistance = -1  # default
        assertValidSFFloat(farDistance)
        self.__farDistance = farDistance
    @property # getter - - - - - - - - - -
    def fieldOfView(self):
        """Preferred minimum viewing angle from this viewpoint in radians, providing minimum height or minimum width (whichever is smaller)."""
        return self.__fieldOfView
    @fieldOfView.setter
    def fieldOfView(self, fieldOfView):
        if  fieldOfView is None:
            fieldOfView = 0.7854  # default
        assertValidSFFloat(fieldOfView)
        assertGreaterThan('fieldOfView', fieldOfView, 0)
        assertLessThan('fieldOfView', fieldOfView, 3.1416)
        self.__fieldOfView = fieldOfView
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"]  # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def jump(self):
        """Whether to transition instantly by jumping, or else smoothly animate to this Viewpoint."""
        return self.__jump
    @jump.setter
    def jump(self, jump):
        if  jump is None:
            jump = True  # default
        assertValidSFBool(jump)
        self.__jump = jump
    @property # getter - - - - - - - - - -
    def nearDistance(self):
        """or (0,+infinity) nearDistance defines minimum clipping plane distance necessary for object display."""
        return self.__nearDistance
    @nearDistance.setter
    def nearDistance(self, nearDistance):
        if  nearDistance is None:
            nearDistance = -1  # default
        assertValidSFFloat(nearDistance)
        self.__nearDistance = nearDistance
    @property # getter - - - - - - - - - -
    def orientation(self):
        """Rotation of Viewpoint, relative to default -Z axis direction in local coordinate system."""
        return self.__orientation
    @orientation.setter
    def orientation(self, orientation):
        if  orientation is None:
            orientation = (0, 0, 1, 0)  # default
        assertValidSFRotation(orientation)
        self.__orientation = orientation
    @property # getter - - - - - - - - - -
    def position(self):
        """position relative to local georeferenced coordinate system, in proper format."""
        return self.__position
    @position.setter
    def position(self, position):
        if  position is None:
            position = (0, 0, 100000)  # default
        assertValidSFVec3d(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def retainUserOffsets(self):
        """Retain (true) or reset to zero (false) any prior user navigation offsets from defined viewpoint position, orientation."""
        return self.__retainUserOffsets
    @retainUserOffsets.setter
    def retainUserOffsets(self, retainUserOffsets):
        if  retainUserOffsets is None:
            retainUserOffsets = False  # default
        assertValidSFBool(retainUserOffsets)
        self.__retainUserOffsets = retainUserOffsets
    @property # getter - - - - - - - - - -
    def speedFactor(self):
        """[0,+infinity) speedFactor is a multiplier to modify the original elevation-based speed that is set automatically by the browser."""
        return self.__speedFactor
    @speedFactor.setter
    def speedFactor(self, speedFactor):
        if  speedFactor is None:
            speedFactor = 1.0  # default
        assertValidSFFloat(speedFactor)
        assertNonNegative('speedFactor', speedFactor)
        self.__speedFactor = speedFactor
    @property # getter - - - - - - - - - -
    def viewAll(self):
        """Viewpoint is automatically adjusted to view all visible geometry."""
        return self.__viewAll
    @viewAll.setter
    def viewAll(self, viewAll):
        if  viewAll is None:
            viewAll = False  # default
        assertValidSFBool(viewAll)
        self.__viewAll = viewAll
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        """[GeoOrigin] Single contained GeoOrigin node that can specify a local coordinate frame for extended precision."""
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin):
        if  geoOrigin is None:
            geoOrigin = None  # default
        assertValidSFNode(geoOrigin)
        if not geoOrigin is None and not isinstance(geoOrigin,(GeoOrigin,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(geoOrigin) + ' does not match required node type (GeoOrigin,ProtoInstance) and is invalid')
        self.__geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def navigationInfo(self):
        """[NavigationInfo] The navigationInfo field defines a dedicated NavigationInfo node for this X3DViewpointNode."""
        return self.__navigationInfo
    @navigationInfo.setter
    def navigationInfo(self, navigationInfo):
        if  navigationInfo is None:
            navigationInfo = None  # default
        assertValidSFNode(navigationInfo)
        if not navigationInfo is None and not isinstance(navigationInfo,(NavigationInfo,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(navigationInfo) + ' does not match required node type (NavigationInfo,ProtoInstance) and is invalid')
        self.__navigationInfo = navigationInfo
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.geoOrigin or self.IS or self.metadata or self.navigationInfo
    # output function - - - - - - - - - -

class Group(_X3DGroupingNode):
    """
    Group is a Grouping node that can contain most nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Group'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/grouping.html#Group'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Group'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        visible=True,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Group __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.visible = visible
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class HAnimDisplacer(_X3DGeometricPropertyNode):
    """
    HAnimDisplacer nodes alter the shape of coordinate-based geometry within parent HAnimJoint or HAnimSegment nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'HAnimDisplacer'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/hanim.html#HAnimDisplacer'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#HAnimDisplacer'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('coordIndex', [], FieldType.MFInt32, AccessType.inputOutput, 'HAnimDisplacer'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'HAnimDisplacer'),
        ('displacements', [], FieldType.MFVec3f, AccessType.inputOutput, 'HAnimDisplacer'),
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'HAnimDisplacer'),
        ('weight', 0.0, FieldType.SFFloat, AccessType.inputOutput, 'HAnimDisplacer'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        coordIndex=None,
        description='',
        displacements=None,
        name='',
        weight=0.0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode HAnimDisplacer __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.coordIndex = coordIndex
        self.description = description
        self.displacements = displacements
        self.name = name
        self.weight = weight
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def coordIndex(self):
        """[0,+infinity) Defines index values into the parent HAnimSegment or HAnimBody/HAnimHumanoid coordinate array for the mesh of vertices affected by this HAnimDisplacer."""
        return self.__coordIndex
    @coordIndex.setter
    def coordIndex(self, coordIndex):
        if  coordIndex is None:
            coordIndex = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(coordIndex)
        self.__coordIndex = coordIndex
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def displacements(self):
        """displacements are a set of SFVec3f values added to neutral/resting position of each of the corresponding HAnimSegment vertices (or HAnimJoint/HAnimHumanoid vertices) referenced by coordIndex field."""
        return self.__displacements
    @displacements.setter
    def displacements(self, displacements):
        if  displacements is None:
            displacements = MFVec3f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec3f.DEFAULT_VALUE()))
        assertValidMFVec3f(displacements)
        self.__displacements = displacements
    @property # getter - - - - - - - - - -
    def name(self):
        """Unique name attribute must be defined so that HAnimDisplacer node can be identified at run time for animation purposes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def weight(self):
        """The weigh factor has typical range [0,1] and defines the scale factor applied to displacement values before adding them to neutral vertex positions."""
        return self.__weight
    @weight.setter
    def weight(self, weight):
        if  weight is None:
            weight = 0.0  # default
        assertValidSFFloat(weight)
        self.__weight = weight
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class HAnimHumanoid(_X3DChildNode, _X3DBoundedObject):
    """
    The HAnimHumanoid node is used to: (a) store references to the joints, segments, sites, skeleton, optional skin, and fixed viewpoints, (b) serve as a container for the entire humanoid, (c) provide a convenient way of moving the humanoid through its environment, and (d) store human-readable metadata such as name, version, author, copyright, age, gender and other information.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'HAnimHumanoid'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/hanim.html#HAnimHumanoid'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#HAnimHumanoid'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimHumanoid'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'HAnimHumanoid'),
        ('info', [], FieldType.MFString, AccessType.inputOutput, 'HAnimHumanoid'),
        ('jointBindingPositions', [], FieldType.MFVec3f, AccessType.inputOutput, 'HAnimHumanoid'),
        ('jointBindingRotations', [], FieldType.MFRotation, AccessType.inputOutput, 'HAnimHumanoid'),
        ('jointBindingScales', [], FieldType.MFVec3f, AccessType.inputOutput, 'HAnimHumanoid'),
        ('loa', -1, FieldType.SFInt32, AccessType.inputOutput, 'HAnimHumanoid'),
        ('motionsEnabled', [], FieldType.MFBool, AccessType.inputOutput, 'HAnimHumanoid'),
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'HAnimHumanoid'),
        ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'HAnimHumanoid'),
        ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimHumanoid'),
        ('scaleOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'HAnimHumanoid'),
        ('skeletalConfiguration', 'BASIC', FieldType.SFString, AccessType.inputOutput, 'HAnimHumanoid'),
        ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimHumanoid'),
        ('version', '2.0', FieldType.SFString, AccessType.inputOutput, 'HAnimHumanoid'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('skinBindingCoords', None, FieldType.SFNode, AccessType.inputOutput, 'HAnimHumanoid'),
        ('skinBindingNormals', None, FieldType.SFNode, AccessType.inputOutput, 'HAnimHumanoid'),
        ('skinCoord', None, FieldType.SFNode, AccessType.inputOutput, 'HAnimHumanoid'),
        ('skinNormal', None, FieldType.SFNode, AccessType.inputOutput, 'HAnimHumanoid'),
        ('skeleton', [], FieldType.MFNode, AccessType.inputOutput, 'HAnimHumanoid'),
        ('joints', [], FieldType.MFNode, AccessType.inputOutput, 'HAnimHumanoid'),
        ('motions', [], FieldType.MFNode, AccessType.inputOutput, 'HAnimHumanoid'),
        ('segments', [], FieldType.MFNode, AccessType.inputOutput, 'HAnimHumanoid'),
        ('sites', [], FieldType.MFNode, AccessType.inputOutput, 'HAnimHumanoid'),
        ('skin', [], FieldType.MFNode, AccessType.inputOutput, 'HAnimHumanoid'),
        ('viewpoints', [], FieldType.MFNode, AccessType.inputOutput, 'HAnimHumanoid'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        center=(0, 0, 0),
        description='',
        info=None,
        jointBindingPositions=None,
        jointBindingRotations=None,
        jointBindingScales=None,
        loa=-1,
        motionsEnabled=None,
        name='',
        rotation=(0, 0, 1, 0),
        scale=(1, 1, 1),
        scaleOrientation=(0, 0, 1, 0),
        skeletalConfiguration='BASIC',
        translation=(0, 0, 0),
        version='2.0',
        visible=True,
        skinBindingCoords=None,
        skinBindingNormals=None,
        skinCoord=None,
        skinNormal=None,
        skeleton=None,
        joints=None,
        motions=None,
        segments=None,
        sites=None,
        skin=None,
        viewpoints=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode HAnimHumanoid __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.center = center
        self.description = description
        self.info = info
        self.jointBindingPositions = jointBindingPositions
        self.jointBindingRotations = jointBindingRotations
        self.jointBindingScales = jointBindingScales
        self.loa = loa
        self.motionsEnabled = motionsEnabled
        self.name = name
        self.rotation = rotation
        self.scale = scale
        self.scaleOrientation = scaleOrientation
        self.skeletalConfiguration = skeletalConfiguration
        self.translation = translation
        self.version = version
        self.visible = visible
        self.skinBindingCoords = skinBindingCoords
        self.skinBindingNormals = skinBindingNormals
        self.skinCoord = skinCoord
        self.skinNormal = skinNormal
        self.skeleton = skeleton
        self.joints = joints
        self.motions = motions
        self.segments = segments
        self.sites = sites
        self.skin = skin
        self.viewpoints = viewpoints
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        """Translation offset from origin of local coordinate system."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0)  # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def info(self):
        """Contains metadata keyword=value pairs, where approved keyword terms are humanoidVersion authorName authorEmail copyright creationDate usageRestrictions age gender height and weight."""
        return self.__info
    @info.setter
    def info(self, info):
        if  info is None:
            info = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(info)
        self.__info = info
    @property # getter - - - - - - - - - -
    def jointBindingPositions(self):
        """Specifies an array of position values for each HAnimJoint node in the joints field, in order, corresponding to each binding pose."""
        return self.__jointBindingPositions
    @jointBindingPositions.setter
    def jointBindingPositions(self, jointBindingPositions):
        if  jointBindingPositions is None:
            jointBindingPositions = MFVec3f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec3f.DEFAULT_VALUE()))
        assertValidMFVec3f(jointBindingPositions)
        self.__jointBindingPositions = jointBindingPositions
    @property # getter - - - - - - - - - -
    def jointBindingRotations(self):
        """Specifies an array of rotation values for each HAnimJoint node in the joints field, in order, corresponding to each binding pose."""
        return self.__jointBindingRotations
    @jointBindingRotations.setter
    def jointBindingRotations(self, jointBindingRotations):
        if  jointBindingRotations is None:
            jointBindingRotations = MFRotation.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFRotation.DEFAULT_VALUE()))
        assertValidMFRotation(jointBindingRotations)
        self.__jointBindingRotations = jointBindingRotations
    @property # getter - - - - - - - - - -
    def jointBindingScales(self):
        """Specifies an array of scale values for each HAnimJoint node in the joints field, in order, corresponding to each binding pose."""
        return self.__jointBindingScales
    @jointBindingScales.setter
    def jointBindingScales(self, jointBindingScales):
        if  jointBindingScales is None:
            jointBindingScales = MFVec3f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec3f.DEFAULT_VALUE()))
        assertValidMFVec3f(jointBindingScales)
        self.__jointBindingScales = jointBindingScales
    @property # getter - - - - - - - - - -
    def loa(self):
        """[-1,4] Level Of Articulation 0."""
        return self.__loa
    @loa.setter
    def loa(self, loa):
        if  loa is None:
            loa = -1  # default
        assertValidSFInt32(loa)
        assertGreaterThanEquals('loa', loa, -1)
        assertLessThanEquals('loa', loa, 4)
        self.__loa = loa
    @property # getter - - - - - - - - - -
    def motionsEnabled(self):
        """Array of boolean values corresponding to HAnimMotion nodes indicating which can animate the HAnimHumanoid."""
        return self.__motionsEnabled
    @motionsEnabled.setter
    def motionsEnabled(self, motionsEnabled):
        if  motionsEnabled is None:
            motionsEnabled = MFBool.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFBool.DEFAULT_VALUE()))
        assertValidMFBool(motionsEnabled)
        self.__motionsEnabled = motionsEnabled
    @property # getter - - - - - - - - - -
    def name(self):
        """Unique name attribute must be defined so that each HAnimHumanoid node in a scene can be identified at run time for animation purposes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def rotation(self):
        """Orientation of children relative to local coordinate system."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = (0, 0, 1, 0)  # default
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        """Non-uniform x-y-z scale of child coordinate system, adjusted by center and scaleOrientation."""
        return self.__scale
    @scale.setter
    def scale(self, scale):
        if  scale is None:
            scale = (1, 1, 1)  # default
        assertValidSFVec3f(scale)
        assertPositive('scale', scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def scaleOrientation(self):
        """Preliminary rotation of coordinate system before scaling (to allow scaling around arbitrary orientations)."""
        return self.__scaleOrientation
    @scaleOrientation.setter
    def scaleOrientation(self, scaleOrientation):
        if  scaleOrientation is None:
            scaleOrientation = (0, 0, 1, 0)  # default
        assertValidSFRotation(scaleOrientation)
        self.__scaleOrientation = scaleOrientation
    @property # getter - - - - - - - - - -
    def skeletalConfiguration(self):
        """Models sharing a common skeletal configuration can share animations and binding poses."""
        return self.__skeletalConfiguration
    @skeletalConfiguration.setter
    def skeletalConfiguration(self, skeletalConfiguration):
        if  skeletalConfiguration is None:
            skeletalConfiguration = 'BASIC'  # default
        assertValidSFString(skeletalConfiguration)
        self.__skeletalConfiguration = skeletalConfiguration
    @property # getter - - - - - - - - - -
    def translation(self):
        """Position of children relative to local coordinate system."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0, 0)  # default
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def version(self):
        """HAnimHumanoid version, where allowed value is 2."""
        return self.__version
    @version.setter
    def version(self, version):
        if  version is None:
            version = '2.0'  # default
        assertValidSFString(version)
        assertValidHanimVersion('version', version)
        self.__version = version
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def skinBindingCoords(self):
        """[Coordinate|CoordinateDouble] Array of Coordinate nodes to handle non-default source pose so that both skin and skeleton can be in same binding pose."""
        return self.__skinBindingCoords
    @skinBindingCoords.setter
    def skinBindingCoords(self, skinBindingCoords):
        if  skinBindingCoords is None:
            skinBindingCoords = None  # default
        assertValidSFNode(skinBindingCoords)
        if not skinBindingCoords is None and not isinstance(skinBindingCoords,(Coordinate,CoordinateDouble,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(skinBindingCoords) + ' does not match required node type (Coordinate,CoordinateDouble,ProtoInstance) and is invalid')
        self.__skinBindingCoords = skinBindingCoords
    @property # getter - - - - - - - - - -
    def skinBindingNormals(self):
        """[X3DNormalNode] Array of Normal nodes to handle non-default source pose so that both skin and skeleton can be in same binding pose."""
        return self.__skinBindingNormals
    @skinBindingNormals.setter
    def skinBindingNormals(self, skinBindingNormals):
        if  skinBindingNormals is None:
            skinBindingNormals = None  # default
        assertValidSFNode(skinBindingNormals)
        if not skinBindingNormals is None and not isinstance(skinBindingNormals,(_X3DNormalNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(skinBindingNormals) + ' does not match required node type (_X3DNormalNode,ProtoInstance) and is invalid')
        self.__skinBindingNormals = skinBindingNormals
    @property # getter - - - - - - - - - -
    def skinCoord(self):
        """[Coordinate|CoordinateDouble] Coordinate node utilized by indexed mesh definitions for skin."""
        return self.__skinCoord
    @skinCoord.setter
    def skinCoord(self, skinCoord):
        if  skinCoord is None:
            skinCoord = None  # default
        assertValidSFNode(skinCoord)
        if not skinCoord is None and not isinstance(skinCoord,(Coordinate,CoordinateDouble,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(skinCoord) + ' does not match required node type (Coordinate,CoordinateDouble,ProtoInstance) and is invalid')
        self.__skinCoord = skinCoord
    @property # getter - - - - - - - - - -
    def skinNormal(self):
        """[X3DNormalNode] Single Normal node utilized by indexed mesh definitions for skin."""
        return self.__skinNormal
    @skinNormal.setter
    def skinNormal(self, skinNormal):
        if  skinNormal is None:
            skinNormal = None  # default
        assertValidSFNode(skinNormal)
        if not skinNormal is None and not isinstance(skinNormal,(_X3DNormalNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(skinNormal) + ' does not match required node type (_X3DNormalNode,ProtoInstance) and is invalid')
        self.__skinNormal = skinNormal
    @property # getter - - - - - - - - - -
    def skeleton(self):
        """[HAnimJoint|HAnimSite] List of top-level HAnimJoint and HAnimSite nodes that create the skeleton model."""
        return self.__skeleton
    @skeleton.setter
    def skeleton(self, skeleton):
        if  skeleton is None:
            skeleton = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(skeleton)
        self.__skeleton = skeleton
    @property # getter - - - - - - - - - -
    def joints(self):
        """[HAnimJoint] The joints field contains a list of USE references for all HAnimJoint node instances found within the preceding skeleton hierarchy."""
        return self.__joints
    @joints.setter
    def joints(self, joints):
        if  joints is None:
            joints = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(joints)
        self.__joints = joints
    @property # getter - - - - - - - - - -
    def motions(self):
        """[HAnimMotion] Contains any HAnimMotion nodes that can animate the HAnimHumanoid."""
        return self.__motions
    @motions.setter
    def motions(self, motions):
        if  motions is None:
            motions = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(motions)
        self.__motions = motions
    @property # getter - - - - - - - - - -
    def segments(self):
        """[HAnimSegment] The segments field contains a list of USE references for all HAnimSegment node instances found within the preceding skeleton hierarchy."""
        return self.__segments
    @segments.setter
    def segments(self, segments):
        if  segments is None:
            segments = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(segments)
        self.__segments = segments
    @property # getter - - - - - - - - - -
    def sites(self):
        """[HAnimSite] sites field contains a list of USE references for all HAnimSite node instances found within the preceding skeleton hierarchy."""
        return self.__sites
    @sites.setter
    def sites(self, sites):
        if  sites is None:
            sites = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(sites)
        self.__sites = sites
    @property # getter - - - - - - - - - -
    def skin(self):
        """[Group|LOD|Shape|Switch|Transform|IndexedFaceSet|IndexedTriangleFanSet|IndexedLineSet|IndexedQuadSet|IndexedTriangleSet|IndexedTriangleStripSet] List of one or more indexed mesh definitions (such as IndexedFaceSet) that utilize skinCoord point and skinNormal normal data."""
        return self.__skin
    @skin.setter
    def skin(self, skin):
        if  skin is None:
            skin = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(skin)
        self.__skin = skin
    @property # getter - - - - - - - - - -
    def viewpoints(self):
        """[HAnimSite] List of HAnimSite nodes containing Viewpoint nodes that appear in the skeleton model, usually as USE node references."""
        return self.__viewpoints
    @viewpoints.setter
    def viewpoints(self, viewpoints):
        if  viewpoints is None:
            viewpoints = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(viewpoints)
        self.__viewpoints = viewpoints
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.skinBindingCoords or self.skinBindingNormals or self.skinCoord or self.skinNormal or (len(self.joints) > 0) or (len(self.motions) > 0) or (len(self.segments) > 0) or (len(self.sites) > 0) or (len(self.skeleton) > 0) or (len(self.skin) > 0) or (len(self.viewpoints) > 0)
    # output function - - - - - - - - - -

class HAnimJoint(_X3DChildNode, _X3DBoundedObject):
    """
    HAnimJoint node can represent each joint in a body.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'HAnimJoint'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/hanim.html#HAnimJoint'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#HAnimJoint'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimJoint'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'HAnimJoint'),
        ('limitOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'HAnimJoint'),
        ('llimit', [0, 0, 0], FieldType.MFFloat, AccessType.inputOutput, 'HAnimJoint'),
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'HAnimJoint'),
        ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'HAnimJoint'),
        ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimJoint'),
        ('scaleOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'HAnimJoint'),
        ('skinCoordIndex', [], FieldType.MFInt32, AccessType.inputOutput, 'HAnimJoint'),
        ('skinCoordWeight', [], FieldType.MFFloat, AccessType.inputOutput, 'HAnimJoint'),
        ('stiffness', [0, 0, 0], FieldType.MFFloat, AccessType.inputOutput, 'HAnimJoint'),
        ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimJoint'),
        ('ulimit', [0, 0, 0], FieldType.MFFloat, AccessType.inputOutput, 'HAnimJoint'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'HAnimJoint'),
        ('displacers', [], FieldType.MFNode, AccessType.inputOutput, 'HAnimJoint'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        center=(0, 0, 0),
        description='',
        limitOrientation=(0, 0, 1, 0),
        llimit=None,
        name='',
        rotation=(0, 0, 1, 0),
        scale=(1, 1, 1),
        scaleOrientation=(0, 0, 1, 0),
        skinCoordIndex=None,
        skinCoordWeight=None,
        stiffness=None,
        translation=(0, 0, 0),
        ulimit=None,
        visible=True,
        children=None,
        displacers=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode HAnimJoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.center = center
        self.description = description
        self.limitOrientation = limitOrientation
        self.llimit = llimit
        self.name = name
        self.rotation = rotation
        self.scale = scale
        self.scaleOrientation = scaleOrientation
        self.skinCoordIndex = skinCoordIndex
        self.skinCoordWeight = skinCoordWeight
        self.stiffness = stiffness
        self.translation = translation
        self.ulimit = ulimit
        self.visible = visible
        self.children = children
        self.displacers = displacers
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        """Translation offset from origin of local coordinate system."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0)  # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def limitOrientation(self):
        """Orientation of upper/lower rotation limits, relative to HAnimJoint center."""
        return self.__limitOrientation
    @limitOrientation.setter
    def limitOrientation(self, limitOrientation):
        if  limitOrientation is None:
            limitOrientation = (0, 0, 1, 0)  # default
        assertValidSFRotation(limitOrientation)
        self.__limitOrientation = limitOrientation
    @property # getter - - - - - - - - - -
    def llimit(self):
        """Lower limit for minimum joint rotation in radians."""
        return self.__llimit
    @llimit.setter
    def llimit(self, llimit):
        if  llimit is None:
            llimit = [0, 0, 0]  # default
        assertValidMFFloat(llimit)
        self.__llimit = llimit
    @property # getter - - - - - - - - - -
    def name(self):
        """Unique name attribute must be defined so that HAnimJoint node can be identified at run time for animation purposes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def rotation(self):
        """Orientation of children relative to local coordinate system."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = (0, 0, 1, 0)  # default
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        """Non-uniform x-y-z scale of child coordinate system, adjusted by center and scaleOrientation."""
        return self.__scale
    @scale.setter
    def scale(self, scale):
        if  scale is None:
            scale = (1, 1, 1)  # default
        assertValidSFVec3f(scale)
        assertPositive('scale', scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def scaleOrientation(self):
        """Preliminary rotation of coordinate system before scaling (to allow scaling around arbitrary orientations)."""
        return self.__scaleOrientation
    @scaleOrientation.setter
    def scaleOrientation(self, scaleOrientation):
        if  scaleOrientation is None:
            scaleOrientation = (0, 0, 1, 0)  # default
        assertValidSFRotation(scaleOrientation)
        self.__scaleOrientation = scaleOrientation
    @property # getter - - - - - - - - - -
    def skinCoordIndex(self):
        """[0,+infinity) Coordinate index values referencing which vertices are influenced by the HAnimJoint."""
        return self.__skinCoordIndex
    @skinCoordIndex.setter
    def skinCoordIndex(self, skinCoordIndex):
        if  skinCoordIndex is None:
            skinCoordIndex = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(skinCoordIndex)
        assertNonNegative('skinCoordIndex', skinCoordIndex)
        self.__skinCoordIndex = skinCoordIndex
    @property # getter - - - - - - - - - -
    def skinCoordWeight(self):
        """Weight deformation values for the corresponding values in the skinCoordIndex field."""
        return self.__skinCoordWeight
    @skinCoordWeight.setter
    def skinCoordWeight(self, skinCoordWeight):
        if  skinCoordWeight is None:
            skinCoordWeight = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(skinCoordWeight)
        self.__skinCoordWeight = skinCoordWeight
    @property # getter - - - - - - - - - -
    def stiffness(self):
        """[0,1] A scale factor of (1 - stiffness) is applied around the corresponding axis (X, Y, or Z for entries 0, 1 and 2 of the stiffness field)."""
        return self.__stiffness
    @stiffness.setter
    def stiffness(self, stiffness):
        if  stiffness is None:
            stiffness = [0, 0, 0]  # default
        assertValidMFFloat(stiffness)
        assertZeroToOne('stiffness', stiffness)
        self.__stiffness = stiffness
    @property # getter - - - - - - - - - -
    def translation(self):
        """Position of children relative to local coordinate system."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0, 0)  # default
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def ulimit(self):
        """Upper limit for maximum joint rotation in radians."""
        return self.__ulimit
    @ulimit.setter
    def ulimit(self, ulimit):
        if  ulimit is None:
            ulimit = [0, 0, 0]  # default
        assertValidMFFloat(ulimit)
        self.__ulimit = ulimit
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[HAnimJoint|HAnimSegment] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def displacers(self):
        """[HAnimDisplacer] the displacers field stores HAnimDisplacer objects for a particular HAnimJoint object."""
        return self.__displacers
    @displacers.setter
    def displacers(self, displacers):
        if  displacers is None:
            displacers = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(displacers)
        self.__displacers = displacers
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0) or (len(self.displacers) > 0)
    # output function - - - - - - - - - -

class HAnimMotion(_X3DChildNode):
    """
    An HAnimMotion node supports discrete frame-by-frame playback for HAnim motion data animation.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'HAnimMotion'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/hanim.html#HAnimMotion'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#HAnimMotion'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('channels', '', FieldType.SFString, AccessType.inputOutput, 'HAnimMotion'),
        ('channelsEnabled', [], FieldType.MFBool, AccessType.inputOutput, 'HAnimMotion'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'HAnimMotion'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'HAnimMotion'),
        ('endFrame', 0, FieldType.SFInt32, AccessType.inputOutput, 'HAnimMotion'),
        ('frameDuration', 0.1, FieldType.SFTime, AccessType.inputOutput, 'HAnimMotion'),
        ('frameIncrement', 1, FieldType.SFInt32, AccessType.inputOutput, 'HAnimMotion'),
        ('frameIndex', 0, FieldType.SFInt32, AccessType.inputOutput, 'HAnimMotion'),
        ('joints', '', FieldType.SFString, AccessType.inputOutput, 'HAnimMotion'),
        ('loa', -1, FieldType.SFInt32, AccessType.inputOutput, 'HAnimMotion'),
        ('loop', False, FieldType.SFBool, AccessType.inputOutput, 'HAnimMotion'),
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'HAnimMotion'),
        ('startFrame', 0, FieldType.SFInt32, AccessType.inputOutput, 'HAnimMotion'),
        ('values', [], FieldType.MFFloat, AccessType.inputOutput, 'HAnimMotion'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        channels='',
        channelsEnabled=None,
        description='',
        enabled=True,
        endFrame=0,
        frameDuration=0.1,
        frameIncrement=1,
        frameIndex=0,
        joints='',
        loa=-1,
        loop=False,
        name='',
        startFrame=0,
        values=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode HAnimMotion __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.channels = channels
        self.channelsEnabled = channelsEnabled
        self.description = description
        self.enabled = enabled
        self.endFrame = endFrame
        self.frameDuration = frameDuration
        self.frameIncrement = frameIncrement
        self.frameIndex = frameIndex
        self.joints = joints
        self.loa = loa
        self.loop = loop
        self.name = name
        self.startFrame = startFrame
        self.values = values
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def channels(self):
        """list of number of channels for transformation, followed by transformation type of each channel of data."""
        return self.__channels
    @channels.setter
    def channels(self, channels):
        if  channels is None:
            channels = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(channels)
        self.__channels = channels
    @property # getter - - - - - - - - - -
    def channelsEnabled(self):
        """boolean values for each channel indicating whether enabled."""
        return self.__channelsEnabled
    @channelsEnabled.setter
    def channelsEnabled(self, channelsEnabled):
        if  channelsEnabled is None:
            channelsEnabled = MFBool.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFBool.DEFAULT_VALUE()))
        assertValidMFBool(channelsEnabled)
        self.__channelsEnabled = channelsEnabled
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def endFrame(self):
        """[0,+infinity) endFrame indicates final index of animated frame."""
        return self.__endFrame
    @endFrame.setter
    def endFrame(self, endFrame):
        if  endFrame is None:
            endFrame = 0  # default
        assertValidSFInt32(endFrame)
        assertNonNegative('endFrame', endFrame)
        self.__endFrame = endFrame
    @property # getter - - - - - - - - - -
    def frameDuration(self):
        """(0,+infinity) frameDuration specifies the duration of each frame in seconds."""
        return self.__frameDuration
    @frameDuration.setter
    def frameDuration(self, frameDuration):
        if  frameDuration is None:
            frameDuration = 0.1  # default
        assertValidSFTime(frameDuration)
        assertPositive('frameDuration', frameDuration)
        self.__frameDuration = frameDuration
    @property # getter - - - - - - - - - -
    def frameIncrement(self):
        """[-infinity,+infinity) frameIncrement field controls whether playback direction is forwards or backwards, and also whether frames are skipped (for example, subsampled replay)."""
        return self.__frameIncrement
    @frameIncrement.setter
    def frameIncrement(self, frameIncrement):
        if  frameIncrement is None:
            frameIncrement = 1  # default
        assertValidSFInt32(frameIncrement)
        self.__frameIncrement = frameIncrement
    @property # getter - - - - - - - - - -
    def frameIndex(self):
        """[0,+infinity) frameIndex indicates index of current frame."""
        return self.__frameIndex
    @frameIndex.setter
    def frameIndex(self, frameIndex):
        if  frameIndex is None:
            frameIndex = 0  # default
        assertValidSFInt32(frameIndex)
        assertNonNegative('frameIndex', frameIndex)
        self.__frameIndex = frameIndex
    @property # getter - - - - - - - - - -
    def joints(self):
        """joints field lists names of joints that raw motion data is to be applied to."""
        return self.__joints
    @joints.setter
    def joints(self, joints):
        if  joints is None:
            joints = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(joints)
        self.__joints = joints
    @property # getter - - - - - - - - - -
    def loa(self):
        """[-1,4] Level Of Articulation 0."""
        return self.__loa
    @loa.setter
    def loa(self, loa):
        if  loa is None:
            loa = -1  # default
        assertValidSFInt32(loa)
        assertGreaterThanEquals('loa', loa, -1)
        assertLessThanEquals('loa', loa, 4)
        self.__loa = loa
    @property # getter - - - - - - - - - -
    def loop(self):
        """Repeat indefinitely when loop=true, repeat only once when loop=false."""
        return self.__loop
    @loop.setter
    def loop(self, loop):
        if  loop is None:
            loop = False  # default
        assertValidSFBool(loop)
        self.__loop = loop
    @property # getter - - - - - - - - - -
    def name(self):
        """Unique name attribute must be defined so that HAnimMotion node can be identified at run time for animation purposes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def startFrame(self):
        """[0,+infinity) startFrame indicates initial index of animated frame."""
        return self.__startFrame
    @startFrame.setter
    def startFrame(self, startFrame):
        if  startFrame is None:
            startFrame = 0  # default
        assertValidSFInt32(startFrame)
        assertNonNegative('startFrame', startFrame)
        self.__startFrame = startFrame
    @property # getter - - - - - - - - - -
    def values(self):
        """values field contains all transformation values, ordered first by frame, then by joint, and then by transformation Sets of floats in the values array matching the order listed in joints and channels fields."""
        return self.__values
    @values.setter
    def values(self, values):
        if  values is None:
            values = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(values)
        self.__values = values
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class HAnimSegment(_X3DGroupingNode):
    """
    HAnimSegment node contains Shape geometry for each body segment, providing a visual representation of the skeleton segment.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'HAnimSegment'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/hanim.html#HAnimSegment'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#HAnimSegment'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('centerOfMass', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimSegment'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'HAnimSegment'),
        ('mass', 0, FieldType.SFFloat, AccessType.inputOutput, 'HAnimSegment'),
        ('momentsOfInertia', [0, 0, 0, 0, 0, 0, 0, 0, 0], FieldType.MFFloat, AccessType.inputOutput, 'HAnimSegment'),
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'HAnimSegment'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'HAnimSegment'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
        ('displacers', [], FieldType.MFNode, AccessType.inputOutput, 'HAnimSegment'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        centerOfMass=(0, 0, 0),
        description='',
        mass=0,
        momentsOfInertia=None,
        name='',
        visible=True,
        coord=None,
        children=None,
        displacers=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode HAnimSegment __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.centerOfMass = centerOfMass
        self.description = description
        self.mass = mass
        self.momentsOfInertia = momentsOfInertia
        self.name = name
        self.visible = visible
        self.coord = coord
        self.children = children
        self.displacers = displacers
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def centerOfMass(self):
        """Location within segment of center of mass."""
        return self.__centerOfMass
    @centerOfMass.setter
    def centerOfMass(self, centerOfMass):
        if  centerOfMass is None:
            centerOfMass = (0, 0, 0)  # default
        assertValidSFVec3f(centerOfMass)
        self.__centerOfMass = centerOfMass
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def mass(self):
        """Total mass of the segment, 0 if not available, defined in mass base units (default is kilograms)."""
        return self.__mass
    @mass.setter
    def mass(self, mass):
        if  mass is None:
            mass = 0  # default
        assertValidSFFloat(mass)
        assertNonNegative('mass', mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def momentsOfInertia(self):
        """3x3 moments of inertia matrix."""
        return self.__momentsOfInertia
    @momentsOfInertia.setter
    def momentsOfInertia(self, momentsOfInertia):
        if  momentsOfInertia is None:
            momentsOfInertia = [0, 0, 0, 0, 0, 0, 0, 0, 0]  # default
        assertValidMFFloat(momentsOfInertia)
        assertNonNegative('momentsOfInertia', momentsOfInertia)
        self.__momentsOfInertia = momentsOfInertia
    @property # getter - - - - - - - - - -
    def name(self):
        """Unique name attribute must be defined so that HAnimSegment node can be identified at run time for animation purposes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def coord(self):
        """[Coordinate|CoordinateDouble] the coord field is used for HAnimSegment objects that have deformable meshes and shall contain coordinates referenced from the IndexedFaceSet for the paarent HAnimSegment object."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None  # default
        assertValidSFNode(coord)
        if not coord is None and not isinstance(coord,(Coordinate,CoordinateDouble,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not match required node type (Coordinate,CoordinateDouble,ProtoInstance) and is invalid')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def displacers(self):
        """[HAnimDisplacer] the displacers field stores HAnimDisplacer objects for a particular HAnimSegment object."""
        return self.__displacers
    @displacers.setter
    def displacers(self, displacers):
        if  displacers is None:
            displacers = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(displacers)
        self.__displacers = displacers
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.coord or self.IS or self.metadata or (len(self.children) > 0) or (len(self.displacers) > 0)
    # output function - - - - - - - - - -

class HAnimSite(_X3DGroupingNode):
    """
    An HAnimSite node serves three purposes: (a) define an "end effector" location which can be used by an inverse kinematics system, (b) define an attachment point for accessories such as jewelry and clothing, and (c) define a location for a Viewpoint virtual camera in the reference frame of an HAnimSegment (such as a view "through the eyes" of the humanoid for use in multi-user worlds).
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'HAnimSite'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/hanim.html#HAnimSite'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#HAnimSite'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimSite'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'HAnimSite'),
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'HAnimSite'),
        ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'HAnimSite'),
        ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimSite'),
        ('scaleOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'HAnimSite'),
        ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimSite'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        center=(0, 0, 0),
        description='',
        name='',
        rotation=(0, 0, 1, 0),
        scale=(1, 1, 1),
        scaleOrientation=(0, 0, 1, 0),
        translation=(0, 0, 0),
        visible=True,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode HAnimSite __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.center = center
        self.description = description
        self.name = name
        self.rotation = rotation
        self.scale = scale
        self.scaleOrientation = scaleOrientation
        self.translation = translation
        self.visible = visible
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        """Default location of this HAnimSite, i."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0)  # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def name(self):
        """Unique name attribute must be defined so that HAnimSite node can be identified at run time for animation purposes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def rotation(self):
        """Orientation of children relative to local coordinate system."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = (0, 0, 1, 0)  # default
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        """Non-uniform x-y-z scale of child coordinate system, adjusted by center and scaleOrientation."""
        return self.__scale
    @scale.setter
    def scale(self, scale):
        if  scale is None:
            scale = (1, 1, 1)  # default
        assertValidSFVec3f(scale)
        assertPositive('scale', scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def scaleOrientation(self):
        """Preliminary rotation of coordinate system before scaling (to allow scaling around arbitrary orientations)."""
        return self.__scaleOrientation
    @scaleOrientation.setter
    def scaleOrientation(self, scaleOrientation):
        if  scaleOrientation is None:
            scaleOrientation = (0, 0, 1, 0)  # default
        assertValidSFRotation(scaleOrientation)
        self.__scaleOrientation = scaleOrientation
    @property # getter - - - - - - - - - -
    def translation(self):
        """Position of children relative to local coordinate system."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0, 0)  # default
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class ImageCubeMapTexture(_X3DEnvironmentTextureNode, _X3DUrlObject):
    """
    ImageCubeMapTexture is a texture node that defines a cubic environment map source as a single file format that contains multiple images, one for each side.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ImageCubeMapTexture'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalTexturing.html#ImageCubeMapTexture'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ImageCubeMapTexture'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('autoRefresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('autoRefreshTimeLimit', 3600, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureNode'),
        ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
        ('url', [], FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
        ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly, 'ImageCubeMapTexture'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        autoRefresh=0,
        autoRefreshTimeLimit=3600,
        description='',
        load=True,
        url=None,
        textureProperties=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ImageCubeMapTexture __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.autoRefresh = autoRefresh
        self.autoRefreshTimeLimit = autoRefreshTimeLimit
        self.description = description
        self.load = load
        self.url = url
        self.textureProperties = textureProperties
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def autoRefresh(self):
        """autoRefresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__autoRefresh
    @autoRefresh.setter
    def autoRefresh(self, autoRefresh):
        if  autoRefresh is None:
            autoRefresh = 0  # default
        assertValidSFTime(autoRefresh)
        assertNonNegative('autoRefresh', autoRefresh)
        self.__autoRefresh = autoRefresh
    @property # getter - - - - - - - - - -
    def autoRefreshTimeLimit(self):
        """autoRefreshTimeLimit defines maximum duration that automatic refresh activity can occur."""
        return self.__autoRefreshTimeLimit
    @autoRefreshTimeLimit.setter
    def autoRefreshTimeLimit(self, autoRefreshTimeLimit):
        if  autoRefreshTimeLimit is None:
            autoRefreshTimeLimit = 3600  # default
        assertValidSFTime(autoRefreshTimeLimit)
        assertNonNegative('autoRefreshTimeLimit', autoRefreshTimeLimit)
        self.__autoRefreshTimeLimit = autoRefreshTimeLimit
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True  # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def url(self):
        """Location and filename of image."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        """[TextureProperties] Single contained TextureProperties node that can specify additional visual attributes applied to corresponding texture images."""
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties):
        if  textureProperties is None:
            textureProperties = None  # default
        assertValidSFNode(textureProperties)
        if not textureProperties is None and not isinstance(textureProperties,(TextureProperties,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(textureProperties) + ' does not match required node type (TextureProperties,ProtoInstance) and is invalid')
        self.__textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.textureProperties
    # output function - - - - - - - - - -

class ImageTexture(_X3DTexture2DNode, _X3DUrlObject):
    """
    ImageTexture maps a 2D-image file onto a geometric shape.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ImageTexture'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#ImageTexture'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ImageTexture'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('autoRefresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('autoRefreshTimeLimit', 3600, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureNode'),
        ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
        ('repeatS', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture2DNode'),
        ('repeatT', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture2DNode'),
        ('url', [], FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
        ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly, 'X3DTexture2DNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        autoRefresh=0,
        autoRefreshTimeLimit=3600,
        description='',
        load=True,
        repeatS=True,
        repeatT=True,
        url=None,
        textureProperties=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ImageTexture __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.autoRefresh = autoRefresh
        self.autoRefreshTimeLimit = autoRefreshTimeLimit
        self.description = description
        self.load = load
        self.repeatS = repeatS
        self.repeatT = repeatT
        self.url = url
        self.textureProperties = textureProperties
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def autoRefresh(self):
        """autoRefresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__autoRefresh
    @autoRefresh.setter
    def autoRefresh(self, autoRefresh):
        if  autoRefresh is None:
            autoRefresh = 0  # default
        assertValidSFTime(autoRefresh)
        assertNonNegative('autoRefresh', autoRefresh)
        self.__autoRefresh = autoRefresh
    @property # getter - - - - - - - - - -
    def autoRefreshTimeLimit(self):
        """autoRefreshTimeLimit defines maximum duration that automatic refresh activity can occur."""
        return self.__autoRefreshTimeLimit
    @autoRefreshTimeLimit.setter
    def autoRefreshTimeLimit(self, autoRefreshTimeLimit):
        if  autoRefreshTimeLimit is None:
            autoRefreshTimeLimit = 3600  # default
        assertValidSFTime(autoRefreshTimeLimit)
        assertNonNegative('autoRefreshTimeLimit', autoRefreshTimeLimit)
        self.__autoRefreshTimeLimit = autoRefreshTimeLimit
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True  # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def repeatS(self):
        """Whether to repeat texture along S axis horizontally from left to right."""
        return self.__repeatS
    @repeatS.setter
    def repeatS(self, repeatS):
        if  repeatS is None:
            repeatS = True  # default
        assertValidSFBool(repeatS)
        self.__repeatS = repeatS
    @property # getter - - - - - - - - - -
    def repeatT(self):
        """Whether to repeat texture along T axis vertically from top to bottom."""
        return self.__repeatT
    @repeatT.setter
    def repeatT(self, repeatT):
        if  repeatT is None:
            repeatT = True  # default
        assertValidSFBool(repeatT)
        self.__repeatT = repeatT
    @property # getter - - - - - - - - - -
    def url(self):
        """Location and filename of image."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        """[TextureProperties] Single contained TextureProperties node that can specify additional visual attributes applied to corresponding texture images."""
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties):
        if  textureProperties is None:
            textureProperties = None  # default
        assertValidSFNode(textureProperties)
        if not textureProperties is None and not isinstance(textureProperties,(TextureProperties,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(textureProperties) + ' does not match required node type (TextureProperties,ProtoInstance) and is invalid')
        self.__textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.textureProperties
    # output function - - - - - - - - - -

class ImageTexture3D(_X3DTexture3DNode, _X3DUrlObject):
    """
    ImageTexture3D defines a 3D image-based texture map by specifying a single image file that contains complete 3D data.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ImageTexture3D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texture3D.html#ImageTexture3D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ImageTexture3D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('autoRefresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('autoRefreshTimeLimit', 3600, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureNode'),
        ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
        ('repeatR', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture3DNode'),
        ('repeatS', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture3DNode'),
        ('repeatT', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture3DNode'),
        ('url', [], FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
        ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly, 'X3DTexture3DNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        autoRefresh=0,
        autoRefreshTimeLimit=3600,
        description='',
        load=True,
        repeatR=False,
        repeatS=False,
        repeatT=False,
        url=None,
        textureProperties=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ImageTexture3D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.autoRefresh = autoRefresh
        self.autoRefreshTimeLimit = autoRefreshTimeLimit
        self.description = description
        self.load = load
        self.repeatR = repeatR
        self.repeatS = repeatS
        self.repeatT = repeatT
        self.url = url
        self.textureProperties = textureProperties
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def autoRefresh(self):
        """autoRefresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__autoRefresh
    @autoRefresh.setter
    def autoRefresh(self, autoRefresh):
        if  autoRefresh is None:
            autoRefresh = 0  # default
        assertValidSFTime(autoRefresh)
        assertNonNegative('autoRefresh', autoRefresh)
        self.__autoRefresh = autoRefresh
    @property # getter - - - - - - - - - -
    def autoRefreshTimeLimit(self):
        """autoRefreshTimeLimit defines maximum duration that automatic refresh activity can occur."""
        return self.__autoRefreshTimeLimit
    @autoRefreshTimeLimit.setter
    def autoRefreshTimeLimit(self, autoRefreshTimeLimit):
        if  autoRefreshTimeLimit is None:
            autoRefreshTimeLimit = 3600  # default
        assertValidSFTime(autoRefreshTimeLimit)
        assertNonNegative('autoRefreshTimeLimit', autoRefreshTimeLimit)
        self.__autoRefreshTimeLimit = autoRefreshTimeLimit
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True  # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def repeatR(self):
        """Whether to repeat texture along R axis from front to back."""
        return self.__repeatR
    @repeatR.setter
    def repeatR(self, repeatR):
        if  repeatR is None:
            repeatR = False  # default
        assertValidSFBool(repeatR)
        self.__repeatR = repeatR
    @property # getter - - - - - - - - - -
    def repeatS(self):
        """Whether to repeat texture along S axis horizontally from left to right."""
        return self.__repeatS
    @repeatS.setter
    def repeatS(self, repeatS):
        if  repeatS is None:
            repeatS = False  # default
        assertValidSFBool(repeatS)
        self.__repeatS = repeatS
    @property # getter - - - - - - - - - -
    def repeatT(self):
        """Whether to repeat texture along T axis vertically from top to bottom."""
        return self.__repeatT
    @repeatT.setter
    def repeatT(self, repeatT):
        if  repeatT is None:
            repeatT = False  # default
        assertValidSFBool(repeatT)
        self.__repeatT = repeatT
    @property # getter - - - - - - - - - -
    def url(self):
        """Location and filename of image."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        """[TextureProperties] Single contained TextureProperties node that can specify additional visual attributes applied to corresponding texture images."""
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties):
        if  textureProperties is None:
            textureProperties = None  # default
        assertValidSFNode(textureProperties)
        if not textureProperties is None and not isinstance(textureProperties,(TextureProperties,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(textureProperties) + ' does not match required node type (TextureProperties,ProtoInstance) and is invalid')
        self.__textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.textureProperties
    # output function - - - - - - - - - -

class IndexedFaceSet(_X3DComposedGeometryNode):
    """
    IndexedFaceSet defines polygons using index lists corresponding to vertex coordinates.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'IndexedFaceSet'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry3D.html#IndexedFaceSet'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IndexedFaceSet'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('colorIndex', [], FieldType.MFInt32, AccessType.initializeOnly, 'IndexedFaceSet'),
        ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('convex', True, FieldType.SFBool, AccessType.initializeOnly, 'IndexedFaceSet'),
        ('coordIndex', [], FieldType.MFInt32, AccessType.initializeOnly, 'IndexedFaceSet'),
        ('creaseAngle', 0, FieldType.SFFloat, AccessType.initializeOnly, 'IndexedFaceSet'),
        ('normalIndex', [], FieldType.MFInt32, AccessType.initializeOnly, 'IndexedFaceSet'),
        ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('texCoordIndex', [], FieldType.MFInt32, AccessType.initializeOnly, 'IndexedFaceSet'),
        ('color', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('attrib', [], FieldType.MFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        ccw=True,
        colorIndex=None,
        colorPerVertex=True,
        convex=True,
        coordIndex=None,
        creaseAngle=0,
        normalIndex=None,
        normalPerVertex=True,
        solid=True,
        texCoordIndex=None,
        color=None,
        coord=None,
        fogCoord=None,
        normal=None,
        texCoord=None,
        attrib=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode IndexedFaceSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorIndex = colorIndex
        self.colorPerVertex = colorPerVertex
        self.convex = convex
        self.coordIndex = coordIndex
        self.creaseAngle = creaseAngle
        self.normalIndex = normalIndex
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.texCoordIndex = texCoordIndex
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True  # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorIndex(self):
        """[-1,+infinity) colorIndex values define the order in which Color|ColorRGBA values are applied to polygons (or vertices), interspersed by -1 if colorlPerVertex=true."""
        return self.__colorIndex
    @colorIndex.setter
    def colorIndex(self, colorIndex):
        if  colorIndex is None:
            colorIndex = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(colorIndex)
        assertGreaterThanEquals('colorIndex', colorIndex, -1)
        self.__colorIndex = colorIndex
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color|ColorRGBA values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True  # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def convex(self):
        """The convex field is a hint to renderers whether all polygons in a shape are convex (true), or possibly concave (false)."""
        return self.__convex
    @convex.setter
    def convex(self, convex):
        if  convex is None:
            convex = True  # default
        assertValidSFBool(convex)
        self.__convex = convex
    @property # getter - - - - - - - - - -
    def coordIndex(self):
        """[-1,+infinity) coordIndex indices provide the order in which coordinates are applied to construct each polygon face."""
        return self.__coordIndex
    @coordIndex.setter
    def coordIndex(self, coordIndex):
        if  coordIndex is None:
            coordIndex = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(coordIndex)
        assertGreaterThanEquals('coordIndex', coordIndex, -1)
        self.__coordIndex = coordIndex
    @property # getter - - - - - - - - - -
    def creaseAngle(self):
        """[0,+infinity) creaseAngle defines angle (in radians) for determining whether adjacent polygons are drawn with sharp edges or smooth shading."""
        return self.__creaseAngle
    @creaseAngle.setter
    def creaseAngle(self, creaseAngle):
        if  creaseAngle is None:
            creaseAngle = 0  # default
        assertValidSFFloat(creaseAngle)
        assertNonNegative('creaseAngle', creaseAngle)
        self.__creaseAngle = creaseAngle
    @property # getter - - - - - - - - - -
    def normalIndex(self):
        """[-1,+infinity) normalIndex values define the order in which normal vectors are applied to polygons (or vertices), interspersed by -1 if normalPerVertex=true."""
        return self.__normalIndex
    @normalIndex.setter
    def normalIndex(self, normalIndex):
        if  normalIndex is None:
            normalIndex = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(normalIndex)
        assertGreaterThanEquals('normalIndex', normalIndex, -1)
        self.__normalIndex = normalIndex
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True  # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def texCoordIndex(self):
        """[-1,+infinity) List of texture-coordinate indices mapping attached texture to corresponding coordinates."""
        return self.__texCoordIndex
    @texCoordIndex.setter
    def texCoordIndex(self, texCoordIndex):
        if  texCoordIndex is None:
            texCoordIndex = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(texCoordIndex)
        assertGreaterThanEquals('texCoordIndex', texCoordIndex, -1)
        self.__texCoordIndex = texCoordIndex
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that can specify color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None  # default
        assertValidSFNode(color)
        if not color is None and not isinstance(color,(_X3DColorNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not match required node type (_X3DColorNode,ProtoInstance) and is invalid')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that can specify a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None  # default
        assertValidSFNode(coord)
        if not coord is None and not isinstance(coord,(_X3DCoordinateNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not match required node type (_X3DCoordinateNode,ProtoInstance) and is invalid')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that can specify depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None  # default
        assertValidSFNode(fogCoord)
        if not fogCoord is None and not isinstance(fogCoord,(FogCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not match required node type (FogCoordinate,ProtoInstance) and is invalid')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that can specify perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None  # default
        assertValidSFNode(normal)
        if not normal is None and not isinstance(normal,(_X3DNormalNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not match required node type (_X3DNormalNode,ProtoInstance) and is invalid')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that can specify coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None  # default
        assertValidSFNode(texCoord)
        if not texCoord is None and not isinstance(texCoord,(_X3DSingleTextureCoordinateNode,MultiTextureCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not match required node type (_X3DSingleTextureCoordinateNode,MultiTextureCoordinate,ProtoInstance) and is invalid')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that can specify list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(attrib)
        self.__attrib = attrib
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or self.texCoord or (len(self.attrib) > 0)
    # output function - - - - - - - - - -

class IndexedLineSet(_X3DGeometryNode):
    """
    IndexedLineSet defines polyline segments using index lists corresponding to vertex coordinates.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'IndexedLineSet'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#IndexedLineSet'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IndexedLineSet'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('colorIndex', [], FieldType.MFInt32, AccessType.initializeOnly, 'IndexedLineSet'),
        ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'IndexedLineSet'),
        ('coordIndex', [], FieldType.MFInt32, AccessType.initializeOnly, 'IndexedLineSet'),
        ('color', None, FieldType.SFNode, AccessType.inputOutput, 'IndexedLineSet'),
        ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'IndexedLineSet'),
        ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'IndexedLineSet'),
        ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'IndexedLineSet'),
        ('attrib', [], FieldType.MFNode, AccessType.inputOutput, 'IndexedLineSet'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        colorIndex=None,
        colorPerVertex=True,
        coordIndex=None,
        color=None,
        coord=None,
        fogCoord=None,
        normal=None,
        attrib=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode IndexedLineSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.colorIndex = colorIndex
        self.colorPerVertex = colorPerVertex
        self.coordIndex = coordIndex
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.attrib = attrib
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def colorIndex(self):
        """[-1,+infinity) colorIndex values define the order in which Color|ColorRGBA values are applied to polygons (or vertices), interspersed by -1 if colorlPerVertex=true."""
        return self.__colorIndex
    @colorIndex.setter
    def colorIndex(self, colorIndex):
        if  colorIndex is None:
            colorIndex = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(colorIndex)
        assertGreaterThanEquals('colorIndex', colorIndex, -1)
        self.__colorIndex = colorIndex
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color node color values are applied to each point vertex (true) or per polyline (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True  # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def coordIndex(self):
        """[-1,+infinity) coordIndex indices provide the order in which coordinates are applied to construct each polygon face."""
        return self.__coordIndex
    @coordIndex.setter
    def coordIndex(self, coordIndex):
        if  coordIndex is None:
            coordIndex = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(coordIndex)
        assertGreaterThanEquals('coordIndex', coordIndex, -1)
        self.__coordIndex = coordIndex
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that can specify color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None  # default
        assertValidSFNode(color)
        if not color is None and not isinstance(color,(_X3DColorNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not match required node type (_X3DColorNode,ProtoInstance) and is invalid')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that can specify a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None  # default
        assertValidSFNode(coord)
        if not coord is None and not isinstance(coord,(_X3DCoordinateNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not match required node type (_X3DCoordinateNode,ProtoInstance) and is invalid')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that can specify depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None  # default
        assertValidSFNode(fogCoord)
        if not fogCoord is None and not isinstance(fogCoord,(FogCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not match required node type (FogCoordinate,ProtoInstance) and is invalid')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that can specify perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None  # default
        assertValidSFNode(normal)
        if not normal is None and not isinstance(normal,(_X3DNormalNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not match required node type (_X3DNormalNode,ProtoInstance) and is invalid')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that can specify list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(attrib)
        self.__attrib = attrib
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or (len(self.attrib) > 0)
    # output function - - - - - - - - - -

class IndexedQuadSet(_X3DComposedGeometryNode):
    """
    IndexedQuadSet is a geometry node that defines quadrilaterals.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'IndexedQuadSet'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/CADGeometry.html#IndexedQuadSet'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IndexedQuadSet'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('index', [], FieldType.MFInt32, AccessType.initializeOnly, 'IndexedQuadSet'),
        ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('color', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('attrib', [], FieldType.MFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        ccw=True,
        colorPerVertex=True,
        index=None,
        normalPerVertex=True,
        solid=True,
        color=None,
        coord=None,
        fogCoord=None,
        normal=None,
        texCoord=None,
        attrib=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode IndexedQuadSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.index = index
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True  # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color|ColorRGBA values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True  # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def index(self):
        """[0,+infinity) index values provide order in which coordinates are applied."""
        return self.__index
    @index.setter
    def index(self, index):
        if  index is None:
            index = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(index)
        assertNonNegative('index', index)
        self.__index = index
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True  # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that can specify color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None  # default
        assertValidSFNode(color)
        if not color is None and not isinstance(color,(_X3DColorNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not match required node type (_X3DColorNode,ProtoInstance) and is invalid')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that can specify a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None  # default
        assertValidSFNode(coord)
        if not coord is None and not isinstance(coord,(_X3DCoordinateNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not match required node type (_X3DCoordinateNode,ProtoInstance) and is invalid')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that can specify depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None  # default
        assertValidSFNode(fogCoord)
        if not fogCoord is None and not isinstance(fogCoord,(FogCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not match required node type (FogCoordinate,ProtoInstance) and is invalid')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that can specify perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None  # default
        assertValidSFNode(normal)
        if not normal is None and not isinstance(normal,(_X3DNormalNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not match required node type (_X3DNormalNode,ProtoInstance) and is invalid')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that can specify coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None  # default
        assertValidSFNode(texCoord)
        if not texCoord is None and not isinstance(texCoord,(_X3DSingleTextureCoordinateNode,MultiTextureCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not match required node type (_X3DSingleTextureCoordinateNode,MultiTextureCoordinate,ProtoInstance) and is invalid')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that can specify list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(attrib)
        self.__attrib = attrib
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or self.texCoord or (len(self.attrib) > 0)
    # output function - - - - - - - - - -

class IndexedTriangleFanSet(_X3DComposedGeometryNode):
    """
    IndexedTriangleFanSet is a geometry node containing a Coordinate|CoordinateDouble node, and can also contain Color|ColorRGBA, Normal and TextureCoordinate nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'IndexedTriangleFanSet'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#IndexedTriangleFanSet'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IndexedTriangleFanSet'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('index', [], FieldType.MFInt32, AccessType.initializeOnly, 'IndexedTriangleFanSet'),
        ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('color', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('attrib', [], FieldType.MFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        ccw=True,
        colorPerVertex=True,
        index=None,
        normalPerVertex=True,
        solid=True,
        color=None,
        coord=None,
        fogCoord=None,
        normal=None,
        texCoord=None,
        attrib=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode IndexedTriangleFanSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.index = index
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True  # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color|ColorRGBA values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True  # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def index(self):
        """[-1,+infinity) index list specifies triangles by connecting Coordinate vertices, each individual fan separated by -1 sentinel value."""
        return self.__index
    @index.setter
    def index(self, index):
        if  index is None:
            index = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(index)
        assertGreaterThanEquals('index', index, -1)
        self.__index = index
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True  # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that can specify color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None  # default
        assertValidSFNode(color)
        if not color is None and not isinstance(color,(_X3DColorNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not match required node type (_X3DColorNode,ProtoInstance) and is invalid')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that can specify a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None  # default
        assertValidSFNode(coord)
        if not coord is None and not isinstance(coord,(_X3DCoordinateNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not match required node type (_X3DCoordinateNode,ProtoInstance) and is invalid')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that can specify depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None  # default
        assertValidSFNode(fogCoord)
        if not fogCoord is None and not isinstance(fogCoord,(FogCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not match required node type (FogCoordinate,ProtoInstance) and is invalid')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that can specify perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None  # default
        assertValidSFNode(normal)
        if not normal is None and not isinstance(normal,(_X3DNormalNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not match required node type (_X3DNormalNode,ProtoInstance) and is invalid')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that can specify coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None  # default
        assertValidSFNode(texCoord)
        if not texCoord is None and not isinstance(texCoord,(_X3DSingleTextureCoordinateNode,MultiTextureCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not match required node type (_X3DSingleTextureCoordinateNode,MultiTextureCoordinate,ProtoInstance) and is invalid')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that can specify list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(attrib)
        self.__attrib = attrib
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or self.texCoord or (len(self.attrib) > 0)
    # output function - - - - - - - - - -

class IndexedTriangleSet(_X3DComposedGeometryNode):
    """
    IndexedTriangleSet is a geometry node containing a Coordinate|CoordinateDouble node, and can also contain Color|ColorRGBA, Normal and TextureCoordinate nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'IndexedTriangleSet'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#IndexedTriangleSet'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IndexedTriangleSet'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('index', [], FieldType.MFInt32, AccessType.initializeOnly, 'IndexedTriangleSet'),
        ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('color', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('attrib', [], FieldType.MFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        ccw=True,
        colorPerVertex=True,
        index=None,
        normalPerVertex=True,
        solid=True,
        color=None,
        coord=None,
        fogCoord=None,
        normal=None,
        texCoord=None,
        attrib=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode IndexedTriangleSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.index = index
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True  # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color|ColorRGBA values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True  # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def index(self):
        """[0,+infinity) index list specifies triangles by connecting Coordinate vertices."""
        return self.__index
    @index.setter
    def index(self, index):
        if  index is None:
            index = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(index)
        assertNonNegative('index', index)
        self.__index = index
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True  # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that can specify color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None  # default
        assertValidSFNode(color)
        if not color is None and not isinstance(color,(_X3DColorNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not match required node type (_X3DColorNode,ProtoInstance) and is invalid')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that can specify a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None  # default
        assertValidSFNode(coord)
        if not coord is None and not isinstance(coord,(_X3DCoordinateNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not match required node type (_X3DCoordinateNode,ProtoInstance) and is invalid')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that can specify depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None  # default
        assertValidSFNode(fogCoord)
        if not fogCoord is None and not isinstance(fogCoord,(FogCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not match required node type (FogCoordinate,ProtoInstance) and is invalid')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that can specify perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None  # default
        assertValidSFNode(normal)
        if not normal is None and not isinstance(normal,(_X3DNormalNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not match required node type (_X3DNormalNode,ProtoInstance) and is invalid')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that can specify coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None  # default
        assertValidSFNode(texCoord)
        if not texCoord is None and not isinstance(texCoord,(_X3DSingleTextureCoordinateNode,MultiTextureCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not match required node type (_X3DSingleTextureCoordinateNode,MultiTextureCoordinate,ProtoInstance) and is invalid')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that can specify list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(attrib)
        self.__attrib = attrib
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or self.texCoord or (len(self.attrib) > 0)
    # output function - - - - - - - - - -

class IndexedTriangleStripSet(_X3DComposedGeometryNode):
    """
    IndexedTriangleStripSet is a geometry node containing a Coordinate|CoordinateDouble node, and can also contain Color|ColorRGBA, Normal and TextureCoordinate nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'IndexedTriangleStripSet'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#IndexedTriangleStripSet'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IndexedTriangleStripSet'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('index', [], FieldType.MFInt32, AccessType.initializeOnly, 'IndexedTriangleStripSet'),
        ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('color', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('attrib', [], FieldType.MFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        ccw=True,
        colorPerVertex=True,
        index=None,
        normalPerVertex=True,
        solid=True,
        color=None,
        coord=None,
        fogCoord=None,
        normal=None,
        texCoord=None,
        attrib=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode IndexedTriangleStripSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.index = index
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True  # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color|ColorRGBA values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True  # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def index(self):
        """[-1,+infinity) index list specifies triangles by connecting Coordinate vertices for each individual strip, separated by -1 sentinel values."""
        return self.__index
    @index.setter
    def index(self, index):
        if  index is None:
            index = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(index)
        assertGreaterThanEquals('index', index, -1)
        self.__index = index
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True  # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that can specify color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None  # default
        assertValidSFNode(color)
        if not color is None and not isinstance(color,(_X3DColorNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not match required node type (_X3DColorNode,ProtoInstance) and is invalid')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that can specify a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None  # default
        assertValidSFNode(coord)
        if not coord is None and not isinstance(coord,(_X3DCoordinateNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not match required node type (_X3DCoordinateNode,ProtoInstance) and is invalid')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that can specify depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None  # default
        assertValidSFNode(fogCoord)
        if not fogCoord is None and not isinstance(fogCoord,(FogCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not match required node type (FogCoordinate,ProtoInstance) and is invalid')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that can specify perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None  # default
        assertValidSFNode(normal)
        if not normal is None and not isinstance(normal,(_X3DNormalNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not match required node type (_X3DNormalNode,ProtoInstance) and is invalid')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that can specify coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None  # default
        assertValidSFNode(texCoord)
        if not texCoord is None and not isinstance(texCoord,(_X3DSingleTextureCoordinateNode,MultiTextureCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not match required node type (_X3DSingleTextureCoordinateNode,MultiTextureCoordinate,ProtoInstance) and is invalid')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that can specify list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(attrib)
        self.__attrib = attrib
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or self.texCoord or (len(self.attrib) > 0)
    # output function - - - - - - - - - -

class Inline(_X3DChildNode, _X3DBoundedObject, _X3DUrlObject):
    """
    Inline can load another X3D or VRML model into the current scene via url.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Inline'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/networking.html#Inline'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Inline'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('autoRefresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('autoRefreshTimeLimit', 3600, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DUrlObject'),
        ('global_', False, FieldType.SFBool, AccessType.inputOutput, 'Inline'),
        ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
        ('url', [], FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        autoRefresh=0,
        autoRefreshTimeLimit=3600,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        description='',
        global_=False,
        load=True,
        url=None,
        visible=True,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Inline __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.autoRefresh = autoRefresh
        self.autoRefreshTimeLimit = autoRefreshTimeLimit
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.description = description
        self.global_ = global_
        self.load = load
        self.url = url
        self.visible = visible
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def autoRefresh(self):
        """autoRefresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__autoRefresh
    @autoRefresh.setter
    def autoRefresh(self, autoRefresh):
        if  autoRefresh is None:
            autoRefresh = 0  # default
        assertValidSFTime(autoRefresh)
        assertNonNegative('autoRefresh', autoRefresh)
        self.__autoRefresh = autoRefresh
    @property # getter - - - - - - - - - -
    def autoRefreshTimeLimit(self):
        """autoRefreshTimeLimit defines maximum duration that automatic refresh activity can occur."""
        return self.__autoRefreshTimeLimit
    @autoRefreshTimeLimit.setter
    def autoRefreshTimeLimit(self, autoRefreshTimeLimit):
        if  autoRefreshTimeLimit is None:
            autoRefreshTimeLimit = 3600  # default
        assertValidSFTime(autoRefreshTimeLimit)
        assertNonNegative('autoRefreshTimeLimit', autoRefreshTimeLimit)
        self.__autoRefreshTimeLimit = autoRefreshTimeLimit
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def global_(self):
        """The global field controls potential external scoping effects of lights found within an Inline scene."""
        return self.__global_
    @global_.setter
    def global_(self, global_):
        if  global_ is None:
            global_ = False  # default
        assertValidSFBool(global_)
        self.__global_ = global_
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True  # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def url(self):
        """Address of X3D world to load Inline with current scene, retrieved either from local system or an online address."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class IntegerSequencer(_X3DSequencerNode):
    """
    IntegerSequencer generates periodic discrete integer values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'IntegerSequencer'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/eventUtilities.html#IntegerSequencer'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IntegerSequencer'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('key', [], FieldType.MFFloat, AccessType.inputOutput, 'X3DSequencerNode'),
        ('keyValue', [], FieldType.MFInt32, AccessType.inputOutput, 'IntegerSequencer'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        key=None,
        keyValue=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode IntegerSequencer __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear sequencing, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class IntegerTrigger(_X3DTriggerNode):
    """
    IntegerTrigger converts set_boolean true input events to an integer value (for example, useful when animating whichChoice in a Switch node).
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'IntegerTrigger'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/eventUtilities.html#IntegerTrigger'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IntegerTrigger'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('integerKey', -1, FieldType.SFInt32, AccessType.inputOutput, 'IntegerTrigger'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        integerKey=-1,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode IntegerTrigger __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.integerKey = integerKey
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def integerKey(self):
        """integerKey is value for output when triggered."""
        return self.__integerKey
    @integerKey.setter
    def integerKey(self, integerKey):
        if  integerKey is None:
            integerKey = -1  # default
        assertValidSFInt32(integerKey)
        self.__integerKey = integerKey
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class IsoSurfaceVolumeData(_X3DVolumeDataNode):
    """
    IsoSurfaceVolumeData displays one or more surfaces extracted from a voxel dataset.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'IsoSurfaceVolumeData'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#IsoSurfaceVolumeData'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IsoSurfaceVolumeData'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DVolumeDataNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeDataNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DVolumeDataNode'),
        ('contourStepSize', 0, FieldType.SFFloat, AccessType.inputOutput, 'IsoSurfaceVolumeData'),
        ('dimensions', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'X3DVolumeDataNode'),
        ('surfaceTolerance', 0, FieldType.SFFloat, AccessType.inputOutput, 'IsoSurfaceVolumeData'),
        ('surfaceValues', [], FieldType.MFFloat, AccessType.inputOutput, 'IsoSurfaceVolumeData'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeDataNode'),
        ('gradients', None, FieldType.SFNode, AccessType.inputOutput, 'IsoSurfaceVolumeData'),
        ('voxels', None, FieldType.SFNode, AccessType.inputOutput, 'IsoSurfaceVolumeData'),
        ('renderStyle', [], FieldType.MFNode, AccessType.inputOutput, 'IsoSurfaceVolumeData'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        contourStepSize=0,
        dimensions=(1, 1, 1),
        surfaceTolerance=0,
        surfaceValues=None,
        visible=True,
        gradients=None,
        voxels=None,
        renderStyle=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode IsoSurfaceVolumeData __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.contourStepSize = contourStepSize
        self.dimensions = dimensions
        self.surfaceTolerance = surfaceTolerance
        self.surfaceValues = surfaceValues
        self.visible = visible
        self.gradients = gradients
        self.voxels = voxels
        self.renderStyle = renderStyle
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def contourStepSize(self):
        """If contourStepSize is non-zero, also render all isosurfaces that are multiples of that step size from initial surface value."""
        return self.__contourStepSize
    @contourStepSize.setter
    def contourStepSize(self, contourStepSize):
        if  contourStepSize is None:
            contourStepSize = 0  # default
        assertValidSFFloat(contourStepSize)
        self.__contourStepSize = contourStepSize
    @property # getter - - - - - - - - - -
    def dimensions(self):
        """Actual-size X-Y-Z dimensions of volume data in local coordinate system."""
        return self.__dimensions
    @dimensions.setter
    def dimensions(self, dimensions):
        if  dimensions is None:
            dimensions = (1, 1, 1)  # default
        assertValidSFVec3f(dimensions)
        assertPositive('dimensions', dimensions)
        self.__dimensions = dimensions
    @property # getter - - - - - - - - - -
    def surfaceTolerance(self):
        """[0,+infinity) Threshold for gradient magnitude for voxel inolusion in isosurface."""
        return self.__surfaceTolerance
    @surfaceTolerance.setter
    def surfaceTolerance(self, surfaceTolerance):
        if  surfaceTolerance is None:
            surfaceTolerance = 0  # default
        assertValidSFFloat(surfaceTolerance)
        assertNonNegative('surfaceTolerance', surfaceTolerance)
        self.__surfaceTolerance = surfaceTolerance
    @property # getter - - - - - - - - - -
    def surfaceValues(self):
        """If surfaceValues has one value defined, render corresponding isosurface plus any isosurfaces based on contourStepSize."""
        return self.__surfaceValues
    @surfaceValues.setter
    def surfaceValues(self, surfaceValues):
        if  surfaceValues is None:
            surfaceValues = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(surfaceValues)
        self.__surfaceValues = surfaceValues
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def gradients(self):
        """[X3DTexture3DNode] Single contained X3DTexture3DNode (ComposedTexture3D, ImageTexture3D, PixelTexture3D) that provides explicit per-voxel gradient direction information for determining surface boundaries, rather than having it implicitly calculated by the implementation."""
        return self.__gradients
    @gradients.setter
    def gradients(self, gradients):
        if  gradients is None:
            gradients = None  # default
        assertValidSFNode(gradients)
        if not gradients is None and not isinstance(gradients,(_X3DTexture3DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(gradients) + ' does not match required node type (_X3DTexture3DNode,ProtoInstance) and is invalid')
        self.__gradients = gradients
    @property # getter - - - - - - - - - -
    def voxels(self):
        """[X3DTexture3DNode] Single contained X3DTexture3DNode (ComposedTexture3D, ImageTexture3D, PixelTexture3D) that provides raw voxel information utilized by corresponding rendering styles."""
        return self.__voxels
    @voxels.setter
    def voxels(self, voxels):
        if  voxels is None:
            voxels = None  # default
        assertValidSFNode(voxels)
        if not voxels is None and not isinstance(voxels,(_X3DTexture3DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(voxels) + ' does not match required node type (_X3DTexture3DNode,ProtoInstance) and is invalid')
        self.__voxels = voxels
    @property # getter - - - - - - - - - -
    def renderStyle(self):
        """[X3DVolumeRenderStyleNode] Multiple contained X3DVolumeRenderStyleNode nodes corresponding to each isosurface that define specific rendering technique for this volumetric object."""
        return self.__renderStyle
    @renderStyle.setter
    def renderStyle(self, renderStyle):
        if  renderStyle is None:
            renderStyle = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(renderStyle)
        self.__renderStyle = renderStyle
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.gradients or self.IS or self.metadata or self.voxels or (len(self.renderStyle) > 0)
    # output function - - - - - - - - - -

class KeySensor(_X3DKeyDeviceSensorNode):
    """
    KeySensor generates events as the user presses keys on the keyboard.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'KeySensor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/keyDeviceSensor.html#KeySensor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#KeySensor'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSensorNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        description='',
        enabled=True,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode KeySensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.enabled = enabled
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class Layer(_X3DLayerNode):
    """
    Layer contains a list of children nodes that define the contents of the layer.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Layer'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/layering.html#Layer'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Layer'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('objectType', ["ALL"], FieldType.MFString, AccessType.inputOutput, 'X3DLayerNode'),
        ('pickable', True, FieldType.SFBool, AccessType.inputOutput, 'X3DLayerNode'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DLayerNode'),
        ('viewport', None, FieldType.SFNode, AccessType.inputOutput, 'X3DLayerNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'Layer'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        objectType=None,
        pickable=True,
        visible=True,
        viewport=None,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Layer __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.objectType = objectType
        self.pickable = pickable
        self.visible = visible
        self.viewport = viewport
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def objectType(self):
        """The objectType field specifies a set of labels used in the picking process."""
        return self.__objectType
    @objectType.setter
    def objectType(self, objectType):
        if  objectType is None:
            objectType = ["ALL"]  # default
        assertValidMFString(objectType)
        self.__objectType = objectType
    @property # getter - - - - - - - - - -
    def pickable(self):
        """pickable determines whether pick traversal is performed for this layer."""
        return self.__pickable
    @pickable.setter
    def pickable(self, pickable):
        if  pickable is None:
            pickable = True  # default
        assertValidSFBool(pickable)
        self.__pickable = pickable
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def viewport(self):
        """[X3DViewportNode] The viewport field is a single Viewport node that constrains layer output to a sub-region of the render surface."""
        return self.__viewport
    @viewport.setter
    def viewport(self, viewport):
        if  viewport is None:
            viewport = None  # default
        assertValidSFNode(viewport)
        if not viewport is None and not isinstance(viewport,(_X3DViewportNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(viewport) + ' does not match required node type (_X3DViewportNode,ProtoInstance) and is invalid')
        self.__viewport = viewport
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Nodes making up this layer."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.viewport or (len(self.children) > 0)
    # output function - - - - - - - - - -

class LayerSet(_X3DNode):
    """
    LayerSet defines a list of layers and a rendering order.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'LayerSet'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/layering.html#LayerSet'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LayerSet'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('activeLayer', 0, FieldType.SFInt32, AccessType.inputOutput, 'LayerSet'),
        ('order', [0], FieldType.MFInt32, AccessType.inputOutput, 'LayerSet'),
        ('layers', [], FieldType.MFNode, AccessType.inputOutput, 'LayerSet'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        activeLayer=0,
        order=None,
        layers=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode LayerSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.activeLayer = activeLayer
        self.order = order
        self.layers = layers
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def activeLayer(self):
        """[0,+infinity) activeLayer field specifies the layer in which navigation takes place."""
        return self.__activeLayer
    @activeLayer.setter
    def activeLayer(self, activeLayer):
        if  activeLayer is None:
            activeLayer = 0  # default
        assertValidSFInt32(activeLayer)
        assertNonNegative('activeLayer', activeLayer)
        self.__activeLayer = activeLayer
    @property # getter - - - - - - - - - -
    def order(self):
        """[0,+infinity) The order list defines the order in which layers are rendered."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = [0]  # default
        assertValidMFInt32(order)
        assertNonNegative('order', order)
        self.__order = order
    @property # getter - - - - - - - - - -
    def layers(self):
        """[X3DLayerNode] The layers list defines a list of Layer nodes that contain the constituent parts of the scene."""
        return self.__layers
    @layers.setter
    def layers(self, layers):
        if  layers is None:
            layers = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(layers)
        self.__layers = layers
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.layers) > 0)
    # output function - - - - - - - - - -

class Layout(_X3DLayoutNode):  #   # TODO fix additional inheritance method resolution order (MRO)
    """
    Layout node is used as layout field of LayoutLayer and LayoutGroup nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Layout'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/layout.html#Layout'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Layout'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('align', ["CENTER", "CENTER"], FieldType.MFString, AccessType.inputOutput, 'Layout'),
        ('offset', [0, 0], FieldType.MFFloat, AccessType.inputOutput, 'Layout'),
        ('offsetUnits', ["WORLD", "WORLD"], FieldType.MFString, AccessType.inputOutput, 'Layout'),
        ('scaleMode', ["NONE", "NONE"], FieldType.MFString, AccessType.inputOutput, 'Layout'),
        ('size', [1, 1], FieldType.MFFloat, AccessType.inputOutput, 'Layout'),
        ('sizeUnits', ["WORLD", "WORLD"], FieldType.MFString, AccessType.inputOutput, 'Layout'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        align=None,
        offset=None,
        offsetUnits=None,
        scaleMode=None,
        size=None,
        sizeUnits=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Layout __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.align = align
        self.offset = offset
        self.offsetUnits = offsetUnits
        self.scaleMode = scaleMode
        self.size = size
        self.sizeUnits = sizeUnits
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def align(self):
        """The align field values align the sized rectangle to an edge or center of the parent rectangle."""
        return self.__align
    @align.setter
    def align(self, align):
        if  align is None:
            align = ["CENTER", "CENTER"]  # default
        assertValidMFString(align)
        assertValidLayoutAlign('align', align)
        self.__align = align
    @property # getter - - - - - - - - - -
    def offset(self):
        """(-infinity,+infinity) The values of the offset field are used to translate the location of this rectangle after the initial alignment."""
        return self.__offset
    @offset.setter
    def offset(self, offset):
        if  offset is None:
            offset = [0, 0]  # default
        assertValidMFFloat(offset)
        self.__offset = offset
    @property # getter - - - - - - - - - -
    def offsetUnits(self):
        """The offsetUnits field values are used to interprete the offset values."""
        return self.__offsetUnits
    @offsetUnits.setter
    def offsetUnits(self, offsetUnits):
        if  offsetUnits is None:
            offsetUnits = ["WORLD", "WORLD"]  # default
        assertValidMFString(offsetUnits)
        assertValidLayoutUnits('offsetUnits', offsetUnits)
        self.__offsetUnits = offsetUnits
    @property # getter - - - - - - - - - -
    def scaleMode(self):
        """The scaleMode field specifies how the scale of the parent is modified."""
        return self.__scaleMode
    @scaleMode.setter
    def scaleMode(self, scaleMode):
        if  scaleMode is None:
            scaleMode = ["NONE", "NONE"]  # default
        assertValidMFString(scaleMode)
        assertValidLayoutScaleMode('scaleMode', scaleMode)
        self.__scaleMode = scaleMode
    @property # getter - - - - - - - - - -
    def size(self):
        """(0,+infinity) The two values in the size field define the width and height of the layout rectangle."""
        return self.__size
    @size.setter
    def size(self, size):
        if  size is None:
            size = [1, 1]  # default
        assertValidMFFloat(size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def sizeUnits(self):
        """The sizeUnits field values are used to interprete the offset values."""
        return self.__sizeUnits
    @sizeUnits.setter
    def sizeUnits(self, sizeUnits):
        if  sizeUnits is None:
            sizeUnits = ["WORLD", "WORLD"]  # default
        assertValidMFString(sizeUnits)
        assertValidLayoutUnits('sizeUnits', sizeUnits)
        self.__sizeUnits = sizeUnits
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class LayoutGroup(_X3DNode):  # , _X3DGroupingNode  # TODO fix additional inheritance method resolution order (MRO)
    """
    LayoutGroup is a Grouping node that can contain most nodes, whose children are related by a common layout within a parent layout.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'LayoutGroup'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/layout.html#LayoutGroup'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LayoutGroup'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('layout', None, FieldType.SFNode, AccessType.inputOutput, 'LayoutGroup'),
        ('viewport', None, FieldType.SFNode, AccessType.inputOutput, 'LayoutGroup'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'LayoutGroup'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        visible=True,
        layout=None,
        viewport=None,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode LayoutGroup __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.visible = visible
        self.layout = layout
        self.viewport = viewport
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def layout(self):
        """[X3DLayoutNode] The layout field contains an X3DLayoutNode node that provides the information required to locate and size the layout region of the LayoutGroup node relative to its parent's layout region, and also to scale the contents of the LayoutGroup."""
        return self.__layout
    @layout.setter
    def layout(self, layout):
        if  layout is None:
            layout = None  # default
        assertValidSFNode(layout)
        if not layout is None and not isinstance(layout,(_X3DLayoutNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(layout) + ' does not match required node type (_X3DLayoutNode,ProtoInstance) and is invalid')
        self.__layout = layout
    @property # getter - - - - - - - - - -
    def viewport(self):
        """[X3DViewportNode] The content of the LayoutGroup is clipped by the specified viewport."""
        return self.__viewport
    @viewport.setter
    def viewport(self, viewport):
        if  viewport is None:
            viewport = None  # default
        assertValidSFNode(viewport)
        if not viewport is None and not isinstance(viewport,(_X3DViewportNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(viewport) + ' does not match required node type (_X3DViewportNode,ProtoInstance) and is invalid')
        self.__viewport = viewport
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.layout or self.metadata or self.viewport or (len(self.children) > 0)
    # output function - - - - - - - - - -

class LayoutLayer(_X3DLayerNode):  #   # TODO fix additional inheritance method resolution order (MRO)
    """
    LayoutLayer is a Grouping node that can contain most nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'LayoutLayer'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/layout.html#LayoutLayer'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LayoutLayer'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('objectType', ["ALL"], FieldType.MFString, AccessType.inputOutput, 'X3DLayerNode'),
        ('pickable', True, FieldType.SFBool, AccessType.inputOutput, 'X3DLayerNode'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DLayerNode'),
        ('layout', None, FieldType.SFNode, AccessType.inputOutput, 'LayoutLayer'),
        ('viewport', None, FieldType.SFNode, AccessType.inputOutput, 'X3DLayerNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'LayoutLayer'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        objectType=None,
        pickable=True,
        visible=True,
        layout=None,
        viewport=None,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode LayoutLayer __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.objectType = objectType
        self.pickable = pickable
        self.visible = visible
        self.layout = layout
        self.viewport = viewport
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def objectType(self):
        """The objectType field specifies a set of labels used in the picking process."""
        return self.__objectType
    @objectType.setter
    def objectType(self, objectType):
        if  objectType is None:
            objectType = ["ALL"]  # default
        assertValidMFString(objectType)
        self.__objectType = objectType
    @property # getter - - - - - - - - - -
    def pickable(self):
        """pickable determines whether pick traversal is performed for this layer."""
        return self.__pickable
    @pickable.setter
    def pickable(self, pickable):
        if  pickable is None:
            pickable = True  # default
        assertValidSFBool(pickable)
        self.__pickable = pickable
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def layout(self):
        """[X3DLayoutNode] The layout field contains an X3DLayoutNode node that provides the information required to locate and size the layout region of the LayoutGroup node relative to its parent's layout region, and also to scale the contents of the LayoutGroup."""
        return self.__layout
    @layout.setter
    def layout(self, layout):
        if  layout is None:
            layout = None  # default
        assertValidSFNode(layout)
        if not layout is None and not isinstance(layout,(_X3DLayoutNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(layout) + ' does not match required node type (_X3DLayoutNode,ProtoInstance) and is invalid')
        self.__layout = layout
    @property # getter - - - - - - - - - -
    def viewport(self):
        """[X3DViewportNode] The content of the LayoutGroup is clipped by the specified viewport."""
        return self.__viewport
    @viewport.setter
    def viewport(self, viewport):
        if  viewport is None:
            viewport = None  # default
        assertValidSFNode(viewport)
        if not viewport is None and not isinstance(viewport,(_X3DViewportNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(viewport) + ' does not match required node type (_X3DViewportNode,ProtoInstance) and is invalid')
        self.__viewport = viewport
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.layout or self.metadata or self.viewport or (len(self.children) > 0)
    # output function - - - - - - - - - -

class LinePickSensor(_X3DPickSensorNode):
    """
    LinePickSensor uses one or more pickingGeometry line segments to compute intersections with pickTarget shapes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'LinePickSensor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/picking.html#LinePickSensor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LinePickSensor'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSensorNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('intersectionType', 'BOUNDS', FieldType.SFString, AccessType.initializeOnly, 'X3DPickSensorNode'),
        ('matchCriterion', 'MATCH_ANY', FieldType.SFString, AccessType.inputOutput, 'X3DPickSensorNode'),
        ('objectType', ["ALL"], FieldType.MFString, AccessType.inputOutput, 'X3DPickSensorNode'),
        ('sortOrder', 'CLOSEST', FieldType.SFString, AccessType.initializeOnly, 'X3DPickSensorNode'),
        ('pickingGeometry', None, FieldType.SFNode, AccessType.inputOutput, 'X3DPickSensorNode'),
        ('pickTarget', [], FieldType.MFNode, AccessType.inputOutput, 'X3DPickSensorNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        description='',
        enabled=True,
        intersectionType='BOUNDS',
        matchCriterion='MATCH_ANY',
        objectType=None,
        sortOrder='CLOSEST',
        pickingGeometry=None,
        pickTarget=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode LinePickSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.enabled = enabled
        self.intersectionType = intersectionType
        self.matchCriterion = matchCriterion
        self.objectType = objectType
        self.sortOrder = sortOrder
        self.pickingGeometry = pickingGeometry
        self.pickTarget = pickTarget
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def intersectionType(self):
        """intersectionType specifies precision of the collision computation."""
        return self.__intersectionType
    @intersectionType.setter
    def intersectionType(self, intersectionType):
        if  intersectionType is None:
            intersectionType = 'BOUNDS'  # default
        assertValidSFString(intersectionType)
        self.__intersectionType = intersectionType
    @property # getter - - - - - - - - - -
    def matchCriterion(self):
        """defines whether the intersection test (i."""
        return self.__matchCriterion
    @matchCriterion.setter
    def matchCriterion(self, matchCriterion):
        if  matchCriterion is None:
            matchCriterion = 'MATCH_ANY'  # default
        assertValidSFString(matchCriterion)
        assertValidPickSensorMatchCriterion('matchCriterion', matchCriterion)
        self.__matchCriterion = matchCriterion
    @property # getter - - - - - - - - - -
    def objectType(self):
        """The objectType field specifies a set of labels used in the picking process."""
        return self.__objectType
    @objectType.setter
    def objectType(self, objectType):
        if  objectType is None:
            objectType = ["ALL"]  # default
        assertValidMFString(objectType)
        self.__objectType = objectType
    @property # getter - - - - - - - - - -
    def sortOrder(self):
        """The sortOrder field determines the order provided for picked output events."""
        return self.__sortOrder
    @sortOrder.setter
    def sortOrder(self, sortOrder):
        if  sortOrder is None:
            sortOrder = 'CLOSEST'  # default
        assertValidSFString(sortOrder)
        self.__sortOrder = sortOrder
    @property # getter - - - - - - - - - -
    def pickingGeometry(self):
        """[IndexedLineSet|LineSet] pickingGeometry specifies the exact geometry coordinates that are used to perform the intersection testing of the picking operation."""
        return self.__pickingGeometry
    @pickingGeometry.setter
    def pickingGeometry(self, pickingGeometry):
        if  pickingGeometry is None:
            pickingGeometry = None  # default
        assertValidSFNode(pickingGeometry)
        if not pickingGeometry is None and not isinstance(pickingGeometry,(_X3DGeometryNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(pickingGeometry) + ' does not match required node type (_X3DGeometryNode,ProtoInstance) and is invalid')
        self.__pickingGeometry = pickingGeometry
    @property # getter - - - - - - - - - -
    def pickTarget(self):
        """[X3DGroupingNode|X3DShapeNode|Inline] pickTarget specifies the list of nodes against which picking operations are performed."""
        return self.__pickTarget
    @pickTarget.setter
    def pickTarget(self, pickTarget):
        if  pickTarget is None:
            pickTarget = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(pickTarget)
        self.__pickTarget = pickTarget
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.pickingGeometry or (len(self.pickTarget) > 0)
    # output function - - - - - - - - - -

class LineProperties(_X3DAppearanceChildNode):
    """
    LineProperties allows precise fine-grained control over the rendering style of lines and edges for associated geometry nodes inside the same Shape.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'LineProperties'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#LineProperties'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LineProperties'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('applied', True, FieldType.SFBool, AccessType.inputOutput, 'LineProperties'),
        ('linetype', 1, FieldType.SFInt32, AccessType.inputOutput, 'LineProperties'),
        ('linewidthScaleFactor', 0, FieldType.SFFloat, AccessType.inputOutput, 'LineProperties'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        applied=True,
        linetype=1,
        linewidthScaleFactor=0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode LineProperties __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.applied = applied
        self.linetype = linetype
        self.linewidthScaleFactor = linewidthScaleFactor
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def applied(self):
        """Whether or not LineProperties are applied to associated geometry."""
        return self.__applied
    @applied.setter
    def applied(self, applied):
        if  applied is None:
            applied = True  # default
        assertValidSFBool(applied)
        self.__applied = applied
    @property # getter - - - - - - - - - -
    def linetype(self):
        """linetype selects a line pattern, with solid default if defined value isn't supported."""
        return self.__linetype
    @linetype.setter
    def linetype(self, linetype):
        if  linetype is None:
            linetype = 1  # default
        assertValidSFInt32(linetype)
        assertNonNegative('linetype', linetype)
        self.__linetype = linetype
    @property # getter - - - - - - - - - -
    def linewidthScaleFactor(self):
        """linewidthScaleFactor is a scale factor multiplied by browser-dependent nominal linewidth, mapped to nearest available line width."""
        return self.__linewidthScaleFactor
    @linewidthScaleFactor.setter
    def linewidthScaleFactor(self, linewidthScaleFactor):
        if  linewidthScaleFactor is None:
            linewidthScaleFactor = 0  # default
        assertValidSFFloat(linewidthScaleFactor)
        self.__linewidthScaleFactor = linewidthScaleFactor
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class LineSet(_X3DGeometryNode):
    """
    LineSet is a geometry node that can contain a Coordinate|CoordinateDouble node and optionally a Color|ColorRGBA node.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'LineSet'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#LineSet'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LineSet'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('vertexCount', [], FieldType.MFInt32, AccessType.inputOutput, 'LineSet'),
        ('color', None, FieldType.SFNode, AccessType.inputOutput, 'LineSet'),
        ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'LineSet'),
        ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'LineSet'),
        ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'LineSet'),
        ('attrib', [], FieldType.MFNode, AccessType.inputOutput, 'LineSet'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        vertexCount=None,
        color=None,
        coord=None,
        fogCoord=None,
        normal=None,
        attrib=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode LineSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.vertexCount = vertexCount
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.attrib = attrib
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def vertexCount(self):
        """[2,+infinity) vertexCount describes how many vertices are used in each individual polyline segment from the Coordinate point values."""
        return self.__vertexCount
    @vertexCount.setter
    def vertexCount(self, vertexCount):
        if  vertexCount is None:
            vertexCount = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(vertexCount)
        assertGreaterThanEquals('vertexCount', vertexCount, 2)
        self.__vertexCount = vertexCount
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that can specify color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None  # default
        assertValidSFNode(color)
        if not color is None and not isinstance(color,(_X3DColorNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not match required node type (_X3DColorNode,ProtoInstance) and is invalid')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that can specify a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None  # default
        assertValidSFNode(coord)
        if not coord is None and not isinstance(coord,(_X3DCoordinateNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not match required node type (_X3DCoordinateNode,ProtoInstance) and is invalid')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that can specify depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None  # default
        assertValidSFNode(fogCoord)
        if not fogCoord is None and not isinstance(fogCoord,(FogCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not match required node type (FogCoordinate,ProtoInstance) and is invalid')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that can specify perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None  # default
        assertValidSFNode(normal)
        if not normal is None and not isinstance(normal,(_X3DNormalNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not match required node type (_X3DNormalNode,ProtoInstance) and is invalid')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that can specify list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(attrib)
        self.__attrib = attrib
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or (len(self.attrib) > 0)
    # output function - - - - - - - - - -

class ListenerPointSource(_X3DSoundSourceNode):
    """
    ListenerPointSource node represents position and orientation of a person listening to virtual sound in the audio scene, and provides single or multiple sound channels as output.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ListenerPointSource'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#ListenerPointSource'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ListenerPointSource'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('dopplerEnabled', False, FieldType.SFBool, AccessType.inputOutput, 'ListenerPointSource'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundSourceNode'),
        ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundSourceNode'),
        ('interauralDistance', 0, FieldType.SFFloat, AccessType.inputOutput, 'ListenerPointSource'),
        ('orientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'ListenerPointSource'),
        ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('position', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'ListenerPointSource'),
        ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('trackCurrentView', False, FieldType.SFBool, AccessType.inputOutput, 'ListenerPointSource'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        description='',
        dopplerEnabled=False,
        enabled=True,
        gain=1,
        interauralDistance=0,
        orientation=(0, 0, 1, 0),
        pauseTime=0,
        position=(0, 0, 0),
        resumeTime=0,
        startTime=0,
        stopTime=0,
        trackCurrentView=False,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ListenerPointSource __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.dopplerEnabled = dopplerEnabled
        self.enabled = enabled
        self.gain = gain
        self.interauralDistance = interauralDistance
        self.orientation = orientation
        self.pauseTime = pauseTime
        self.position = position
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
        self.trackCurrentView = trackCurrentView
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def dopplerEnabled(self):
        """dopplerEnabled enables/disables whether real-time Doppler effects (due to relation motion between sources and listeners) are computed by browser between virtual sound sources and active listening locations, then applied to received frequency at active listening locations."""
        return self.__dopplerEnabled
    @dopplerEnabled.setter
    def dopplerEnabled(self, dopplerEnabled):
        if  dopplerEnabled is None:
            dopplerEnabled = False  # default
        assertValidSFBool(dopplerEnabled)
        self.__dopplerEnabled = dopplerEnabled
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1  # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def interauralDistance(self):
        """[0,+infinity) The interauralDistance field is."""
        return self.__interauralDistance
    @interauralDistance.setter
    def interauralDistance(self, interauralDistance):
        if  interauralDistance is None:
            interauralDistance = 0  # default
        assertValidSFFloat(interauralDistance)
        assertNonNegative('interauralDistance', interauralDistance)
        self.__interauralDistance = interauralDistance
    @property # getter - - - - - - - - - -
    def orientation(self):
        """Rotation (axis, angle in radians) of listening point direction relative to default -Z axis direction in local coordinate system."""
        return self.__orientation
    @orientation.setter
    def orientation(self, orientation):
        if  orientation is None:
            orientation = (0, 0, 1, 0)  # default
        assertValidSFRotation(orientation)
        self.__orientation = orientation
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0  # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def position(self):
        """position (x, y, z in meters) relative to local coordinate system."""
        return self.__position
    @position.setter
    def position(self, position):
        if  position is None:
            position = (0, 0, 0)  # default
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0  # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0  # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0  # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def trackCurrentView(self):
        """If trackCurrentView field is true then position and orientation match avatar's (user's) current view."""
        return self.__trackCurrentView
    @trackCurrentView.setter
    def trackCurrentView(self, trackCurrentView):
        if  trackCurrentView is None:
            trackCurrentView = False  # default
        assertValidSFBool(trackCurrentView)
        self.__trackCurrentView = trackCurrentView
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class LoadSensor(_X3DNetworkSensorNode):
    """
    LoadSensor generates events as watchList child nodes are either loaded or fail to load.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'LoadSensor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/networking.html#LoadSensor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LoadSensor'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSensorNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('timeOut', 0, FieldType.SFTime, AccessType.inputOutput, 'LoadSensor'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'LoadSensor'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        description='',
        enabled=True,
        timeOut=0,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode LoadSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.enabled = enabled
        self.timeOut = timeOut
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def timeOut(self):
        """Time in seconds of maximum load duration prior to declaring failure."""
        return self.__timeOut
    @timeOut.setter
    def timeOut(self, timeOut):
        if  timeOut is None:
            timeOut = 0  # default
        assertValidSFTime(timeOut)
        assertNonNegative('timeOut', timeOut)
        self.__timeOut = timeOut
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DUrlObject] The children field monitors one or more USE nodes that contain a valid url field."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class LocalFog(_X3DChildNode, _X3DFogObject):
    """
    LocalFog simulates atmospheric effects by blending distant objects with fog color.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'LocalFog'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalEffects.html#LocalFog'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LocalFog'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'X3DFogObject'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'LocalFog'),
        ('fogType', 'LINEAR', FieldType.SFString, AccessType.inputOutput, 'X3DFogObject'),
        ('visibilityRange', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DFogObject'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        color=(1, 1, 1),
        enabled=True,
        fogType='LINEAR',
        visibilityRange=0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode LocalFog __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.color = color
        self.enabled = enabled
        self.fogType = fogType
        self.visibilityRange = visibilityRange
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def color(self):
        """[0,1] Fog color."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = (1, 1, 1)  # default
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def fogType(self):
        """Specifies algorithm for rate of increasing Fog, either LINEAR or EXPONENTIAL."""
        return self.__fogType
    @fogType.setter
    def fogType(self, fogType):
        if  fogType is None:
            fogType = 'LINEAR'  # default
        assertValidSFString(fogType)
        assertValidFogType('fogType', fogType)
        self.__fogType = fogType
    @property # getter - - - - - - - - - -
    def visibilityRange(self):
        """Distance in meters where objects are totally obscured by the fog, using local coordinate system."""
        return self.__visibilityRange
    @visibilityRange.setter
    def visibilityRange(self, visibilityRange):
        if  visibilityRange is None:
            visibilityRange = 0  # default
        assertValidSFFloat(visibilityRange)
        assertNonNegative('visibilityRange', visibilityRange)
        self.__visibilityRange = visibilityRange
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class LOD(_X3DGroupingNode):
    """
    LOD (Level Of Detail) uses camera-to-object distance to switch among contained child levels.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'LOD'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/navigation.html#LOD'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LOD'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'LOD'),
        ('forceTransitions', False, FieldType.SFBool, AccessType.initializeOnly, 'LOD'),
        ('range', [], FieldType.MFFloat, AccessType.initializeOnly, 'LOD'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        center=(0, 0, 0),
        forceTransitions=False,
        range=None,
        visible=True,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode LOD __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.center = center
        self.forceTransitions = forceTransitions
        self.range = range
        self.visible = visible
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        """Viewpoint distance-measurement offset from origin of local coordinate system, used for LOD node distance calculations."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0)  # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def forceTransitions(self):
        """Whether to perform every range-based transition, regardless of browser optimizations that might otherwise occur."""
        return self.__forceTransitions
    @forceTransitions.setter
    def forceTransitions(self, forceTransitions):
        if  forceTransitions is None:
            forceTransitions = False  # default
        assertValidSFBool(forceTransitions)
        self.__forceTransitions = forceTransitions
    @property # getter - - - - - - - - - -
    def range(self):
        """(0,+infinity) Specifies ideal distances at which to switch between levels."""
        return self.__range
    @range.setter
    def range(self, range):
        if  range is None:
            range = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(range)
        self.__range = range
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class Material(_X3DOneSidedMaterialNode):
    """
    Material specifies surface rendering properties for associated geometry nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Material'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#Material'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Material'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('ambientIntensity', 0.2, FieldType.SFFloat, AccessType.inputOutput, 'Material'),
        ('ambientTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'Material'),
        ('diffuseColor', (0.8, 0.8, 0.8), FieldType.SFColor, AccessType.inputOutput, 'Material'),
        ('diffuseTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'Material'),
        ('emissiveColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput, 'Material'),
        ('emissiveTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
        ('normalScale', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
        ('normalTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
        ('occlusionStrength', 1, FieldType.SFFloat, AccessType.inputOutput, 'Material'),
        ('occlusionTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'Material'),
        ('shininess', 0.2, FieldType.SFFloat, AccessType.inputOutput, 'Material'),
        ('shininessTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'Material'),
        ('specularColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput, 'Material'),
        ('specularTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'Material'),
        ('transparency', 0, FieldType.SFFloat, AccessType.inputOutput, 'Material'),
        ('ambientTexture', None, FieldType.SFNode, AccessType.inputOutput, 'Material'),
        ('diffuseTexture', None, FieldType.SFNode, AccessType.inputOutput, 'Material'),
        ('emissiveTexture', None, FieldType.SFNode, AccessType.inputOutput, 'Material'),
        ('normalTexture', None, FieldType.SFNode, AccessType.inputOutput, 'Material'),
        ('occlusionTexture', None, FieldType.SFNode, AccessType.inputOutput, 'Material'),
        ('shininessTexture', None, FieldType.SFNode, AccessType.inputOutput, 'Material'),
        ('specularTexture', None, FieldType.SFNode, AccessType.inputOutput, 'Material'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        ambientIntensity=0.2,
        ambientTextureMapping='',
        diffuseColor=(0.8, 0.8, 0.8),
        diffuseTextureMapping='',
        emissiveColor=(0, 0, 0),
        emissiveTextureMapping='',
        normalScale=1,
        normalTextureMapping='',
        occlusionStrength=1,
        occlusionTextureMapping='',
        shininess=0.2,
        shininessTextureMapping='',
        specularColor=(0, 0, 0),
        specularTextureMapping='',
        transparency=0,
        ambientTexture=None,
        diffuseTexture=None,
        emissiveTexture=None,
        normalTexture=None,
        occlusionTexture=None,
        shininessTexture=None,
        specularTexture=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Material __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ambientIntensity = ambientIntensity
        self.ambientTextureMapping = ambientTextureMapping
        self.diffuseColor = diffuseColor
        self.diffuseTextureMapping = diffuseTextureMapping
        self.emissiveColor = emissiveColor
        self.emissiveTextureMapping = emissiveTextureMapping
        self.normalScale = normalScale
        self.normalTextureMapping = normalTextureMapping
        self.occlusionStrength = occlusionStrength
        self.occlusionTextureMapping = occlusionTextureMapping
        self.shininess = shininess
        self.shininessTextureMapping = shininessTextureMapping
        self.specularColor = specularColor
        self.specularTextureMapping = specularTextureMapping
        self.transparency = transparency
        self.ambientTexture = ambientTexture
        self.diffuseTexture = diffuseTexture
        self.emissiveTexture = emissiveTexture
        self.normalTexture = normalTexture
        self.occlusionTexture = occlusionTexture
        self.shininessTexture = shininessTexture
        self.specularTexture = specularTexture
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def ambientIntensity(self):
        """[0,1] how much ambient omnidirectional light is reflected from all light sources."""
        return self.__ambientIntensity
    @ambientIntensity.setter
    def ambientIntensity(self, ambientIntensity):
        if  ambientIntensity is None:
            ambientIntensity = 0.2  # default
        assertValidSFFloat(ambientIntensity)
        assertZeroToOne('ambientIntensity', ambientIntensity)
        self.__ambientIntensity = ambientIntensity
    @property # getter - - - - - - - - - -
    def ambientTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__ambientTextureMapping
    @ambientTextureMapping.setter
    def ambientTextureMapping(self, ambientTextureMapping):
        if  ambientTextureMapping is None:
            ambientTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(ambientTextureMapping)
        self.__ambientTextureMapping = ambientTextureMapping
    @property # getter - - - - - - - - - -
    def diffuseColor(self):
        """[0,1] how much direct, angle-dependent light is reflected from all light sources."""
        return self.__diffuseColor
    @diffuseColor.setter
    def diffuseColor(self, diffuseColor):
        if  diffuseColor is None:
            diffuseColor = (0.8, 0.8, 0.8)  # default
        assertValidSFColor(diffuseColor)
        assertZeroToOne('diffuseColor', diffuseColor)
        self.__diffuseColor = diffuseColor
    @property # getter - - - - - - - - - -
    def diffuseTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__diffuseTextureMapping
    @diffuseTextureMapping.setter
    def diffuseTextureMapping(self, diffuseTextureMapping):
        if  diffuseTextureMapping is None:
            diffuseTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(diffuseTextureMapping)
        self.__diffuseTextureMapping = diffuseTextureMapping
    @property # getter - - - - - - - - - -
    def emissiveColor(self):
        """[0,1] how much glowing light is emitted from this object."""
        return self.__emissiveColor
    @emissiveColor.setter
    def emissiveColor(self, emissiveColor):
        if  emissiveColor is None:
            emissiveColor = (0, 0, 0)  # default
        assertValidSFColor(emissiveColor)
        assertZeroToOne('emissiveColor', emissiveColor)
        self.__emissiveColor = emissiveColor
    @property # getter - - - - - - - - - -
    def emissiveTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__emissiveTextureMapping
    @emissiveTextureMapping.setter
    def emissiveTextureMapping(self, emissiveTextureMapping):
        if  emissiveTextureMapping is None:
            emissiveTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(emissiveTextureMapping)
        self.__emissiveTextureMapping = emissiveTextureMapping
    @property # getter - - - - - - - - - -
    def normalScale(self):
        """[0,infinity] normalScale controls the degree to which normalTexture RGB values apply XYZ-normal bump mapping to pixels in the parent material."""
        return self.__normalScale
    @normalScale.setter
    def normalScale(self, normalScale):
        if  normalScale is None:
            normalScale = 1  # default
        assertValidSFFloat(normalScale)
        assertNonNegative('normalScale', normalScale)
        self.__normalScale = normalScale
    @property # getter - - - - - - - - - -
    def normalTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__normalTextureMapping
    @normalTextureMapping.setter
    def normalTextureMapping(self, normalTextureMapping):
        if  normalTextureMapping is None:
            normalTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(normalTextureMapping)
        self.__normalTextureMapping = normalTextureMapping
    @property # getter - - - - - - - - - -
    def occlusionStrength(self):
        """[0,1] occlusionStrength indicates areas of indirect lighting, typically called ambient occlusion."""
        return self.__occlusionStrength
    @occlusionStrength.setter
    def occlusionStrength(self, occlusionStrength):
        if  occlusionStrength is None:
            occlusionStrength = 1  # default
        assertValidSFFloat(occlusionStrength)
        assertZeroToOne('occlusionStrength', occlusionStrength)
        self.__occlusionStrength = occlusionStrength
    @property # getter - - - - - - - - - -
    def occlusionTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__occlusionTextureMapping
    @occlusionTextureMapping.setter
    def occlusionTextureMapping(self, occlusionTextureMapping):
        if  occlusionTextureMapping is None:
            occlusionTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(occlusionTextureMapping)
        self.__occlusionTextureMapping = occlusionTextureMapping
    @property # getter - - - - - - - - - -
    def shininess(self):
        """[0,1] Lower shininess values provide soft specular glows, while higher values result in sharper, smaller highlights."""
        return self.__shininess
    @shininess.setter
    def shininess(self, shininess):
        if  shininess is None:
            shininess = 0.2  # default
        assertValidSFFloat(shininess)
        assertZeroToOne('shininess', shininess)
        self.__shininess = shininess
    @property # getter - - - - - - - - - -
    def shininessTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__shininessTextureMapping
    @shininessTextureMapping.setter
    def shininessTextureMapping(self, shininessTextureMapping):
        if  shininessTextureMapping is None:
            shininessTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(shininessTextureMapping)
        self.__shininessTextureMapping = shininessTextureMapping
    @property # getter - - - - - - - - - -
    def specularColor(self):
        """[0,1] specular highlights are brightness reflections (example: shiny spots on an apple)."""
        return self.__specularColor
    @specularColor.setter
    def specularColor(self, specularColor):
        if  specularColor is None:
            specularColor = (0, 0, 0)  # default
        assertValidSFColor(specularColor)
        assertZeroToOne('specularColor', specularColor)
        self.__specularColor = specularColor
    @property # getter - - - - - - - - - -
    def specularTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__specularTextureMapping
    @specularTextureMapping.setter
    def specularTextureMapping(self, specularTextureMapping):
        if  specularTextureMapping is None:
            specularTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(specularTextureMapping)
        self.__specularTextureMapping = specularTextureMapping
    @property # getter - - - - - - - - - -
    def transparency(self):
        """[0,1] how "clear" an object is: 1."""
        return self.__transparency
    @transparency.setter
    def transparency(self, transparency):
        if  transparency is None:
            transparency = 0  # default
        assertValidSFFloat(transparency)
        assertZeroToOne('transparency', transparency)
        self.__transparency = transparency
    @property # getter - - - - - - - - - -
    def ambientTexture(self):
        """[X3DSingleTextureNode] When applying ambientIntensity for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__ambientTexture
    @ambientTexture.setter
    def ambientTexture(self, ambientTexture):
        if  ambientTexture is None:
            ambientTexture = None  # default
        assertValidSFNode(ambientTexture)
        if not ambientTexture is None and not isinstance(ambientTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(ambientTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__ambientTexture = ambientTexture
    @property # getter - - - - - - - - - -
    def diffuseTexture(self):
        """[X3DSingleTextureNode] When applying diffuseColor for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__diffuseTexture
    @diffuseTexture.setter
    def diffuseTexture(self, diffuseTexture):
        if  diffuseTexture is None:
            diffuseTexture = None  # default
        assertValidSFNode(diffuseTexture)
        if not diffuseTexture is None and not isinstance(diffuseTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(diffuseTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__diffuseTexture = diffuseTexture
    @property # getter - - - - - - - - - -
    def emissiveTexture(self):
        """[X3DSingleTextureNode] When applying emissiveColor for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__emissiveTexture
    @emissiveTexture.setter
    def emissiveTexture(self, emissiveTexture):
        if  emissiveTexture is None:
            emissiveTexture = None  # default
        assertValidSFNode(emissiveTexture)
        if not emissiveTexture is None and not isinstance(emissiveTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(emissiveTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__emissiveTexture = emissiveTexture
    @property # getter - - - - - - - - - -
    def normalTexture(self):
        """[X3DSingleTextureNode] When applying normalScale for this material node, the contained texture modulates the texture across the surface."""
        return self.__normalTexture
    @normalTexture.setter
    def normalTexture(self, normalTexture):
        if  normalTexture is None:
            normalTexture = None  # default
        assertValidSFNode(normalTexture)
        if not normalTexture is None and not isinstance(normalTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(normalTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__normalTexture = normalTexture
    @property # getter - - - - - - - - - -
    def occlusionTexture(self):
        """[X3DSingleTextureNode] When applying occlusionStrength for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__occlusionTexture
    @occlusionTexture.setter
    def occlusionTexture(self, occlusionTexture):
        if  occlusionTexture is None:
            occlusionTexture = None  # default
        assertValidSFNode(occlusionTexture)
        if not occlusionTexture is None and not isinstance(occlusionTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(occlusionTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__occlusionTexture = occlusionTexture
    @property # getter - - - - - - - - - -
    def shininessTexture(self):
        """[X3DSingleTextureNode] When applying shininess for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__shininessTexture
    @shininessTexture.setter
    def shininessTexture(self, shininessTexture):
        if  shininessTexture is None:
            shininessTexture = None  # default
        assertValidSFNode(shininessTexture)
        if not shininessTexture is None and not isinstance(shininessTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(shininessTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__shininessTexture = shininessTexture
    @property # getter - - - - - - - - - -
    def specularTexture(self):
        """[X3DSingleTextureNode] When applying specularColor for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__specularTexture
    @specularTexture.setter
    def specularTexture(self, specularTexture):
        if  specularTexture is None:
            specularTexture = None  # default
        assertValidSFNode(specularTexture)
        if not specularTexture is None and not isinstance(specularTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(specularTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__specularTexture = specularTexture
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.ambientTexture or self.diffuseTexture or self.emissiveTexture or self.IS or self.metadata or self.normalTexture or self.occlusionTexture or self.shininessTexture or self.specularTexture
    # output function - - - - - - - - - -

class Matrix3VertexAttribute(_X3DVertexAttributeNode):
    """
    Matrix3VertexAttribute defines a set of per-vertex 3x3 matrix attributes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Matrix3VertexAttribute'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shaders.html#Matrix3VertexAttribute'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Matrix3VertexAttribute'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('name', '', FieldType.SFString, AccessType.initializeOnly, 'X3DVertexAttributeNode'),
        ('value', [], FieldType.MFMatrix3f, AccessType.inputOutput, 'Matrix3VertexAttribute'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        name='',
        value=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Matrix3VertexAttribute __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.value = value
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def name(self):
        """Required name for this particular VertexAttribute instance."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def value(self):
        """value specifies an arbitrary collection of matrix values that will be passed to the shader as per-vertex information."""
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = MFMatrix3f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFMatrix3f.DEFAULT_VALUE()))
        assertValidMFMatrix3f(value)
        self.__value = value
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class Matrix4VertexAttribute(_X3DVertexAttributeNode):
    """
    Matrix4VertexAttribute defines a set of per-vertex 4x4 matrix attributes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Matrix4VertexAttribute'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shaders.html#Matrix4VertexAttribute'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Matrix4VertexAttribute'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('name', '', FieldType.SFString, AccessType.initializeOnly, 'X3DVertexAttributeNode'),
        ('value', [], FieldType.MFMatrix4f, AccessType.inputOutput, 'Matrix4VertexAttribute'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        name='',
        value=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Matrix4VertexAttribute __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.value = value
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def name(self):
        """Required name for this particular VertexAttribute instance."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def value(self):
        """value specifies an arbitrary collection of matrix values that will be passed to the shader as per-vertex information."""
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = MFMatrix4f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFMatrix4f.DEFAULT_VALUE()))
        assertValidMFMatrix4f(value)
        self.__value = value
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class MetadataBoolean(_X3DNode):  # , _X3DMetadataObject  # TODO fix additional inheritance method resolution order (MRO)
    """
    The metadata provided by this node is contained in the Boolean values of the value field.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'MetadataBoolean'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#MetadataBoolean'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataBoolean'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
        ('reference', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
        ('value', [], FieldType.MFBool, AccessType.inputOutput, 'MetadataBoolean'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        name='',
        reference='',
        value=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode MetadataBoolean __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.reference = reference
        self.value = value
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def name(self):
        """Depending on the metadata vocabulary, the attribute name is usually required for metadata nodes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def reference(self):
        """Reference to the metadata standard or definition defining this particular metadata value."""
        return self.__reference
    @reference.setter
    def reference(self, reference):
        if  reference is None:
            reference = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(reference)
        self.__reference = reference
    @property # getter - - - - - - - - - -
    def value(self):
        """The value attribute is a strictly typed data array providing relevant metadata information."""
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = MFBool.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFBool.DEFAULT_VALUE()))
        assertValidMFBool(value)
        self.__value = value
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class MetadataDouble(_X3DNode):  # , _X3DMetadataObject  # TODO fix additional inheritance method resolution order (MRO)
    """
    The metadata provided by this node is contained in the double-precision floating point numbers of the value field.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'MetadataDouble'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#MetadataDouble'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataDouble'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
        ('reference', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
        ('value', [], FieldType.MFDouble, AccessType.inputOutput, 'MetadataDouble'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        name='',
        reference='',
        value=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode MetadataDouble __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.reference = reference
        self.value = value
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def name(self):
        """Depending on the metadata vocabulary, the attribute name is usually required for metadata nodes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def reference(self):
        """Reference to the metadata standard or definition defining this particular metadata value."""
        return self.__reference
    @reference.setter
    def reference(self, reference):
        if  reference is None:
            reference = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(reference)
        self.__reference = reference
    @property # getter - - - - - - - - - -
    def value(self):
        """The value attribute is a strictly typed data array providing relevant metadata information."""
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
        assertValidMFDouble(value)
        self.__value = value
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class MetadataFloat(_X3DNode):  # , _X3DMetadataObject  # TODO fix additional inheritance method resolution order (MRO)
    """
    The metadata provided by this node is contained in the single-precision floating point numbers of the value field.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'MetadataFloat'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#MetadataFloat'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataFloat'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
        ('reference', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
        ('value', [], FieldType.MFFloat, AccessType.inputOutput, 'MetadataFloat'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        name='',
        reference='',
        value=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode MetadataFloat __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.reference = reference
        self.value = value
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def name(self):
        """Depending on the metadata vocabulary, the attribute name is usually required for metadata nodes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def reference(self):
        """Reference to the metadata standard or definition defining this particular metadata value."""
        return self.__reference
    @reference.setter
    def reference(self, reference):
        if  reference is None:
            reference = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(reference)
        self.__reference = reference
    @property # getter - - - - - - - - - -
    def value(self):
        """The value attribute is a strictly typed data array providing relevant metadata information."""
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(value)
        self.__value = value
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class MetadataInteger(_X3DNode):  # , _X3DMetadataObject  # TODO fix additional inheritance method resolution order (MRO)
    """
    The metadata provided by this node is contained in the integer numbers of the value field.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'MetadataInteger'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#MetadataInteger'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataInteger'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
        ('reference', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
        ('value', [], FieldType.MFInt32, AccessType.inputOutput, 'MetadataInteger'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        name='',
        reference='',
        value=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode MetadataInteger __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.reference = reference
        self.value = value
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def name(self):
        """Depending on the metadata vocabulary, the attribute name is usually required for metadata nodes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def reference(self):
        """Reference to the metadata standard or definition defining this particular metadata value."""
        return self.__reference
    @reference.setter
    def reference(self, reference):
        if  reference is None:
            reference = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(reference)
        self.__reference = reference
    @property # getter - - - - - - - - - -
    def value(self):
        """The value attribute is a strictly typed data array providing relevant metadata information."""
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(value)
        self.__value = value
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class MetadataSet(_X3DNode):  # , _X3DMetadataObject  # TODO fix additional inheritance method resolution order (MRO)
    """
    The metadata provided by this node is contained in the metadata nodes of the value field.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'MetadataSet'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#MetadataSet'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataSet'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
        ('reference', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
        ('value', [], FieldType.MFNode, AccessType.inputOutput, 'MetadataSet'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'MetadataSet'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'MetadataSet'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        name='',
        reference='',
        value=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode MetadataSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.reference = reference
        self.value = value
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def name(self):
        """Depending on the metadata vocabulary, the attribute name is usually required for metadata nodes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def reference(self):
        """Reference to the metadata standard or definition defining this particular metadata value."""
        return self.__reference
    @reference.setter
    def reference(self, reference):
        if  reference is None:
            reference = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(reference)
        self.__reference = reference
    @property # getter - - - - - - - - - -
    def value(self):
        """[X3DNode] The value field provides a list of X3DMetadataObject nodes whose meaning is determined by the name field."""
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(value)
        self.__value = value
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):

        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.value) > 0)
    # output function - - - - - - - - - -

class MetadataString(_X3DNode):  # , _X3DMetadataObject  # TODO fix additional inheritance method resolution order (MRO)
    """
    The metadata provided by this node is contained in the strings of the value field.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'MetadataString'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#MetadataString'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataString'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
        ('reference', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
        ('value', [], FieldType.MFString, AccessType.inputOutput, 'MetadataString'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        name='',
        reference='',
        value=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode MetadataString __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.reference = reference
        self.value = value
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def name(self):
        """Depending on the metadata vocabulary, the attribute name is usually required for metadata nodes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def reference(self):
        """Reference to the metadata standard or definition defining this particular metadata value."""
        return self.__reference
    @reference.setter
    def reference(self, reference):
        if  reference is None:
            reference = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(reference)
        self.__reference = reference
    @property # getter - - - - - - - - - -
    def value(self):
        """The value attribute is a strictly typed data array providing relevant metadata information."""
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(value)
        self.__value = value
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class MicrophoneSource(_X3DSoundSourceNode):
    """
    MicrophoneSource captures input from a physical microphone in the real world.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'MicrophoneSource'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#MicrophoneSource'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MicrophoneSource'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundSourceNode'),
        ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundSourceNode'),
        ('mediaDeviceID', '', FieldType.SFString, AccessType.inputOutput, 'MicrophoneSource'),
        ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        description='',
        enabled=True,
        gain=1,
        mediaDeviceID='',
        pauseTime=0,
        resumeTime=0,
        startTime=0,
        stopTime=0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode MicrophoneSource __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.mediaDeviceID = mediaDeviceID
        self.pauseTime = pauseTime
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1  # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def mediaDeviceID(self):
        """mediaDeviceID field provides ID parameter functionality."""
        return self.__mediaDeviceID
    @mediaDeviceID.setter
    def mediaDeviceID(self, mediaDeviceID):
        if  mediaDeviceID is None:
            mediaDeviceID = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(mediaDeviceID)
        self.__mediaDeviceID = mediaDeviceID
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0  # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0  # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0  # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0  # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class MotorJoint(_X3DRigidJointNode):
    """
    MotorJoint drives relative angular velocities between body1 and body2 within a common reference frame.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'MotorJoint'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#MotorJoint'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MotorJoint'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('autoCalc', False, FieldType.SFBool, AccessType.initializeOnly, 'MotorJoint'),
        ('axis1Angle', 0, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
        ('axis1Torque', 0, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
        ('axis2Angle', 0, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
        ('axis2Torque', 0, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
        ('axis3Angle', 0, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
        ('axis3Torque', 0, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
        ('enabledAxes', 1, FieldType.SFInt32, AccessType.inputOutput, 'MotorJoint'),
        ('forceOutput', ["NONE"], FieldType.MFString, AccessType.inputOutput, 'X3DRigidJointNode'),
        ('motor1Axis', (1, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'MotorJoint'),
        ('motor2Axis', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'MotorJoint'),
        ('motor3Axis', (0, 0, 1), FieldType.SFVec3f, AccessType.inputOutput, 'MotorJoint'),
        ('stop1Bounce', 0, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
        ('stop1ErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
        ('stop2Bounce', 0, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
        ('stop2ErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
        ('stop3Bounce', 0, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
        ('stop3ErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
        ('body1', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
        ('body2', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        autoCalc=False,
        axis1Angle=0,
        axis1Torque=0,
        axis2Angle=0,
        axis2Torque=0,
        axis3Angle=0,
        axis3Torque=0,
        enabledAxes=1,
        forceOutput=None,
        motor1Axis=(1, 0, 0),
        motor2Axis=(0, 1, 0),
        motor3Axis=(0, 0, 1),
        stop1Bounce=0,
        stop1ErrorCorrection=0.8,
        stop2Bounce=0,
        stop2ErrorCorrection=0.8,
        stop3Bounce=0,
        stop3ErrorCorrection=0.8,
        body1=None,
        body2=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode MotorJoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.autoCalc = autoCalc
        self.axis1Angle = axis1Angle
        self.axis1Torque = axis1Torque
        self.axis2Angle = axis2Angle
        self.axis2Torque = axis2Torque
        self.axis3Angle = axis3Angle
        self.axis3Torque = axis3Torque
        self.enabledAxes = enabledAxes
        self.forceOutput = forceOutput
        self.motor1Axis = motor1Axis
        self.motor2Axis = motor2Axis
        self.motor3Axis = motor3Axis
        self.stop1Bounce = stop1Bounce
        self.stop1ErrorCorrection = stop1ErrorCorrection
        self.stop2Bounce = stop2Bounce
        self.stop2ErrorCorrection = stop2ErrorCorrection
        self.stop3Bounce = stop3Bounce
        self.stop3ErrorCorrection = stop3ErrorCorrection
        self.body1 = body1
        self.body2 = body2
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def autoCalc(self):
        """autoCalc controls whether user manually provides individual angle rotations each frame (false) or if angle values are automatically calculated by motor implementations (true)."""
        return self.__autoCalc
    @autoCalc.setter
    def autoCalc(self, autoCalc):
        if  autoCalc is None:
            autoCalc = False  # default
        assertValidSFBool(autoCalc)
        self.__autoCalc = autoCalc
    @property # getter - - - - - - - - - -
    def axis1Angle(self):
        """axis1Angle (radians) is rotation angle for corresponding motor axis when in user-calculated mode."""
        return self.__axis1Angle
    @axis1Angle.setter
    def axis1Angle(self, axis1Angle):
        if  axis1Angle is None:
            axis1Angle = 0  # default
        assertValidSFFloat(axis1Angle)
        self.__axis1Angle = axis1Angle
    @property # getter - - - - - - - - - -
    def axis1Torque(self):
        """axis1Torque is rotational torque applied by corresponding motor axis when in user-calculated mode."""
        return self.__axis1Torque
    @axis1Torque.setter
    def axis1Torque(self, axis1Torque):
        if  axis1Torque is None:
            axis1Torque = 0  # default
        assertValidSFFloat(axis1Torque)
        self.__axis1Torque = axis1Torque
    @property # getter - - - - - - - - - -
    def axis2Angle(self):
        """axis2Angle (radians) is rotation angle for corresponding motor axis when in user-calculated mode."""
        return self.__axis2Angle
    @axis2Angle.setter
    def axis2Angle(self, axis2Angle):
        if  axis2Angle is None:
            axis2Angle = 0  # default
        assertValidSFFloat(axis2Angle)
        self.__axis2Angle = axis2Angle
    @property # getter - - - - - - - - - -
    def axis2Torque(self):
        """axis2Torque is rotational torque applied by corresponding motor axis when in user-calculated mode."""
        return self.__axis2Torque
    @axis2Torque.setter
    def axis2Torque(self, axis2Torque):
        if  axis2Torque is None:
            axis2Torque = 0  # default
        assertValidSFFloat(axis2Torque)
        self.__axis2Torque = axis2Torque
    @property # getter - - - - - - - - - -
    def axis3Angle(self):
        """axis3Angle (radians) is rotation angle for corresponding motor axis when in user-calculated mode."""
        return self.__axis3Angle
    @axis3Angle.setter
    def axis3Angle(self, axis3Angle):
        if  axis3Angle is None:
            axis3Angle = 0  # default
        assertValidSFFloat(axis3Angle)
        self.__axis3Angle = axis3Angle
    @property # getter - - - - - - - - - -
    def axis3Torque(self):
        """axis3Torque is rotational torque applied by corresponding motor axis when in user-calculated mode."""
        return self.__axis3Torque
    @axis3Torque.setter
    def axis3Torque(self, axis3Torque):
        if  axis3Torque is None:
            axis3Torque = 0  # default
        assertValidSFFloat(axis3Torque)
        self.__axis3Torque = axis3Torque
    @property # getter - - - - - - - - - -
    def enabledAxes(self):
        """[0,3] enabledAxes indicates which motor axes are active."""
        return self.__enabledAxes
    @enabledAxes.setter
    def enabledAxes(self, enabledAxes):
        if  enabledAxes is None:
            enabledAxes = 1  # default
        assertValidSFInt32(enabledAxes)
        assertGreaterThanEquals('enabledAxes', enabledAxes, 0)
        assertLessThanEquals('enabledAxes', enabledAxes, 3)
        self.__enabledAxes = enabledAxes
    @property # getter - - - - - - - - - -
    def forceOutput(self):
        """forceOutput controls which output fields are generated for the next frame."""
        return self.__forceOutput
    @forceOutput.setter
    def forceOutput(self, forceOutput):
        if  forceOutput is None:
            forceOutput = ["NONE"]  # default
        assertValidMFString(forceOutput)
        self.__forceOutput = forceOutput
    @property # getter - - - - - - - - - -
    def motor1Axis(self):
        """motor1Axis defines axis vector of corresponding motor axis."""
        return self.__motor1Axis
    @motor1Axis.setter
    def motor1Axis(self, motor1Axis):
        if  motor1Axis is None:
            motor1Axis = (1, 0, 0)  # default
        assertValidSFVec3f(motor1Axis)
        self.__motor1Axis = motor1Axis
    @property # getter - - - - - - - - - -
    def motor2Axis(self):
        """motor2Axis defines axis vector of corresponding motor axis."""
        return self.__motor2Axis
    @motor2Axis.setter
    def motor2Axis(self, motor2Axis):
        if  motor2Axis is None:
            motor2Axis = (0, 1, 0)  # default
        assertValidSFVec3f(motor2Axis)
        self.__motor2Axis = motor2Axis
    @property # getter - - - - - - - - - -
    def motor3Axis(self):
        """motor3Axis defines axis vector of corresponding motor axis."""
        return self.__motor3Axis
    @motor3Axis.setter
    def motor3Axis(self, motor3Axis):
        if  motor3Axis is None:
            motor3Axis = (0, 0, 1)  # default
        assertValidSFVec3f(motor3Axis)
        self.__motor3Axis = motor3Axis
    @property # getter - - - - - - - - - -
    def stop1Bounce(self):
        """[0,1] stop1Bounce is velocity factor for bounce back once stop point is reached."""
        return self.__stop1Bounce
    @stop1Bounce.setter
    def stop1Bounce(self, stop1Bounce):
        if  stop1Bounce is None:
            stop1Bounce = 0  # default
        assertValidSFFloat(stop1Bounce)
        self.__stop1Bounce = stop1Bounce
    @property # getter - - - - - - - - - -
    def stop1ErrorCorrection(self):
        """[0,1] stop1ErrorCorrection is fraction of error correction performed during time step once stop point is reached."""
        return self.__stop1ErrorCorrection
    @stop1ErrorCorrection.setter
    def stop1ErrorCorrection(self, stop1ErrorCorrection):
        if  stop1ErrorCorrection is None:
            stop1ErrorCorrection = 0.8  # default
        assertValidSFFloat(stop1ErrorCorrection)
        self.__stop1ErrorCorrection = stop1ErrorCorrection
    @property # getter - - - - - - - - - -
    def stop2Bounce(self):
        """[0,1] stop2Bounce is velocity factor for bounce back once stop point is reached."""
        return self.__stop2Bounce
    @stop2Bounce.setter
    def stop2Bounce(self, stop2Bounce):
        if  stop2Bounce is None:
            stop2Bounce = 0  # default
        assertValidSFFloat(stop2Bounce)
        self.__stop2Bounce = stop2Bounce
    @property # getter - - - - - - - - - -
    def stop2ErrorCorrection(self):
        """[0,1] stop2ErrorCorrection is fraction of error correction performed during time step once stop point is reached."""
        return self.__stop2ErrorCorrection
    @stop2ErrorCorrection.setter
    def stop2ErrorCorrection(self, stop2ErrorCorrection):
        if  stop2ErrorCorrection is None:
            stop2ErrorCorrection = 0.8  # default
        assertValidSFFloat(stop2ErrorCorrection)
        self.__stop2ErrorCorrection = stop2ErrorCorrection
    @property # getter - - - - - - - - - -
    def stop3Bounce(self):
        """[0,1] stop3Bounce is velocity factor for bounce back once stop point is reached."""
        return self.__stop3Bounce
    @stop3Bounce.setter
    def stop3Bounce(self, stop3Bounce):
        if  stop3Bounce is None:
            stop3Bounce = 0  # default
        assertValidSFFloat(stop3Bounce)
        self.__stop3Bounce = stop3Bounce
    @property # getter - - - - - - - - - -
    def stop3ErrorCorrection(self):
        """[0,1] stop3ErrorCorrection is fraction of error correction performed during time step once stop point is reached."""
        return self.__stop3ErrorCorrection
    @stop3ErrorCorrection.setter
    def stop3ErrorCorrection(self, stop3ErrorCorrection):
        if  stop3ErrorCorrection is None:
            stop3ErrorCorrection = 0.8  # default
        assertValidSFFloat(stop3ErrorCorrection)
        self.__stop3ErrorCorrection = stop3ErrorCorrection
    @property # getter - - - - - - - - - -
    def body1(self):
        """[RigidBody] The body1 and body2 fields indicate the two RigidBody nodes connected by this joint."""
        return self.__body1
    @body1.setter
    def body1(self, body1):
        if  body1 is None:
            body1 = None  # default
        assertValidSFNode(body1)
        if not body1 is None and not isinstance(body1,(RigidBody,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(body1) + ' does not match required node type (RigidBody,ProtoInstance) and is invalid')
        self.__body1 = body1
    @property # getter - - - - - - - - - -
    def body2(self):
        """[RigidBody] The body1 and body2 fields indicate the two RigidBody nodes connected by this joint."""
        return self.__body2
    @body2.setter
    def body2(self, body2):
        if  body2 is None:
            body2 = None  # default
        assertValidSFNode(body2)
        if not body2 is None and not isinstance(body2,(RigidBody,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(body2) + ' does not match required node type (RigidBody,ProtoInstance) and is invalid')
        self.__body2 = body2
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.body1 or self.body2 or self.IS or self.metadata
    # output function - - - - - - - - - -

class MovieTexture(_X3DSoundSourceNode, _X3DTexture2DNode, _X3DUrlObject):
    """
    MovieTexture applies a 2D movie image to surface geometry, or provides audio for a Sound node.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'MovieTexture'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#MovieTexture'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MovieTexture'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('autoRefresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('autoRefreshTimeLimit', 3600, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundSourceNode'),
        ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundSourceNode'),
        ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
        ('loop', False, FieldType.SFBool, AccessType.inputOutput, 'MovieTexture'),
        ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('pitch', 1.0, FieldType.SFFloat, AccessType.inputOutput, 'MovieTexture'),
        ('repeatS', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture2DNode'),
        ('repeatT', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture2DNode'),
        ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('speed', 1.0, FieldType.SFFloat, AccessType.inputOutput, 'MovieTexture'),
        ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('url', [], FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
        ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly, 'MovieTexture'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        autoRefresh=0,
        autoRefreshTimeLimit=3600,
        description='',
        enabled=True,
        gain=1,
        load=True,
        loop=False,
        pauseTime=0,
        pitch=1.0,
        repeatS=True,
        repeatT=True,
        resumeTime=0,
        speed=1.0,
        startTime=0,
        stopTime=0,
        url=None,
        textureProperties=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode MovieTexture __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.autoRefresh = autoRefresh
        self.autoRefreshTimeLimit = autoRefreshTimeLimit
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.load = load
        self.loop = loop
        self.pauseTime = pauseTime
        self.pitch = pitch
        self.repeatS = repeatS
        self.repeatT = repeatT
        self.resumeTime = resumeTime
        self.speed = speed
        self.startTime = startTime
        self.stopTime = stopTime
        self.url = url
        self.textureProperties = textureProperties
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def autoRefresh(self):
        """autoRefresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__autoRefresh
    @autoRefresh.setter
    def autoRefresh(self, autoRefresh):
        if  autoRefresh is None:
            autoRefresh = 0  # default
        assertValidSFTime(autoRefresh)
        assertNonNegative('autoRefresh', autoRefresh)
        self.__autoRefresh = autoRefresh
    @property # getter - - - - - - - - - -
    def autoRefreshTimeLimit(self):
        """autoRefreshTimeLimit defines maximum duration that automatic refresh activity can occur."""
        return self.__autoRefreshTimeLimit
    @autoRefreshTimeLimit.setter
    def autoRefreshTimeLimit(self, autoRefreshTimeLimit):
        if  autoRefreshTimeLimit is None:
            autoRefreshTimeLimit = 3600  # default
        assertValidSFTime(autoRefreshTimeLimit)
        assertNonNegative('autoRefreshTimeLimit', autoRefreshTimeLimit)
        self.__autoRefreshTimeLimit = autoRefreshTimeLimit
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1  # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True  # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def loop(self):
        """Repeat indefinitely when loop=true, repeat only once when loop=false."""
        return self.__loop
    @loop.setter
    def loop(self, loop):
        if  loop is None:
            loop = False  # default
        assertValidSFBool(loop)
        self.__loop = loop
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and MovieTexture becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0  # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def pitch(self):
        """(0,+infinity) Multiplier for the rate at which sampled sound is played."""
        return self.__pitch
    @pitch.setter
    def pitch(self, pitch):
        if  pitch is None:
            pitch = 1.0  # default
        assertValidSFFloat(pitch)
        assertPositive('pitch', pitch)
        self.__pitch = pitch
    @property # getter - - - - - - - - - -
    def repeatS(self):
        """Whether to repeat texture along S axis horizontally from left to right."""
        return self.__repeatS
    @repeatS.setter
    def repeatS(self, repeatS):
        if  repeatS is None:
            repeatS = True  # default
        assertValidSFBool(repeatS)
        self.__repeatS = repeatS
    @property # getter - - - - - - - - - -
    def repeatT(self):
        """Whether to repeat texture along T axis vertically from top to bottom."""
        return self.__repeatT
    @repeatT.setter
    def repeatT(self, repeatT):
        if  repeatT is None:
            repeatT = True  # default
        assertValidSFBool(repeatT)
        self.__repeatT = repeatT
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and MovieTexture becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0  # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def speed(self):
        """Factor for how fast the movie (or soundtrack) is played."""
        return self.__speed
    @speed.setter
    def speed(self, speed):
        if  speed is None:
            speed = 1.0  # default
        assertValidSFFloat(speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0  # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0  # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def url(self):
        """Location and filename of movie file or stream."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        """[TextureProperties] Single contained TextureProperties node that can specify additional visual attributes applied to corresponding texture images."""
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties):
        if  textureProperties is None:
            textureProperties = None  # default
        assertValidSFNode(textureProperties)
        if not textureProperties is None and not isinstance(textureProperties,(TextureProperties,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(textureProperties) + ' does not match required node type (TextureProperties,ProtoInstance) and is invalid')
        self.__textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.textureProperties
    # output function - - - - - - - - - -

class MultiTexture(_X3DTextureNode):
    """
    MultiTexture applies several individual textures to a single geometry node, enabling a variety of visual effects that include light mapping and environment mapping.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'MultiTexture'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#MultiTexture'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MultiTexture'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('alpha', 1, FieldType.SFFloat, AccessType.inputOutput, 'MultiTexture'),
        ('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'MultiTexture'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureNode'),
        ('function', [], FieldType.MFString, AccessType.inputOutput, 'MultiTexture'),
        ('mode', [], FieldType.MFString, AccessType.inputOutput, 'MultiTexture'),
        ('source', [], FieldType.MFString, AccessType.inputOutput, 'MultiTexture'),
        ('texture', [], FieldType.MFNode, AccessType.inputOutput, 'MultiTexture'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        alpha=1,
        color=(1, 1, 1),
        description='',
        function=None,
        mode=None,
        source=None,
        texture=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode MultiTexture __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.alpha = alpha
        self.color = color
        self.description = description
        self.function = function
        self.mode = mode
        self.source = source
        self.texture = texture
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def alpha(self):
        """[0,1] The alpha field defines the alpha (1-transparency) base value for mode operations."""
        return self.__alpha
    @alpha.setter
    def alpha(self, alpha):
        if  alpha is None:
            alpha = 1  # default
        assertValidSFFloat(alpha)
        assertZeroToOne('alpha', alpha)
        self.__alpha = alpha
    @property # getter - - - - - - - - - -
    def color(self):
        """[0,1] The color field defines the RGB base values for mode operations."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = (1, 1, 1)  # default
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def function(self):
        """function operators COMPLEMENT or ALPHAREPLICATE can be applied after the mode blending operation."""
        return self.__function
    @function.setter
    def function(self, function):
        if  function is None:
            function = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(function)
        self.__function = function
    @property # getter - - - - - - - - - -
    def mode(self):
        """mode field indicates the type of blending operation, both for color and for alpha channel."""
        return self.__mode
    @mode.setter
    def mode(self, mode):
        if  mode is None:
            mode = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(mode)
        self.__mode = mode
    @property # getter - - - - - - - - - -
    def source(self):
        """source field determines whether each image source is treated as DIFFUSE, SPECULAR or a multiplicative FACTOR."""
        return self.__source
    @source.setter
    def source(self, source):
        if  source is None:
            source = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(source)
        self.__source = source
    @property # getter - - - - - - - - - -
    def texture(self):
        """[X3DSingleTextureNode] Contained texture nodes (ImageTexture, MovieTexture, PixelTexture) that map image(s) to surface geometry, defining each of the different texture channels."""
        return self.__texture
    @texture.setter
    def texture(self, texture):
        if  texture is None:
            texture = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(texture)
        self.__texture = texture
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.texture) > 0)
    # output function - - - - - - - - - -

class MultiTextureCoordinate(_X3DTextureCoordinateNode):
    """
    MultiTextureCoordinate contains multiple TextureCoordinate or TextureCoordinateGenerator nodes, for use by a parent polygonal geometry node such as IndexedFaceSet or a Triangle* node.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'MultiTextureCoordinate'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#MultiTextureCoordinate'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MultiTextureCoordinate'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('texCoord', [], FieldType.MFNode, AccessType.inputOutput, 'MultiTextureCoordinate'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        texCoord=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode MultiTextureCoordinate __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.texCoord = texCoord
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DSingleTextureCoordinateNode] Zero or more contained TextureCoordinate or TextureCoordinateGenerator nodes that specify texture coordinates for the different texture channels, used for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(texCoord)
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.texCoord) > 0)
    # output function - - - - - - - - - -

class MultiTextureTransform(_X3DTextureTransformNode):
    """
    MultiTextureTransform contains multiple TextureTransform nodes, each provided for use by corresponding ImageTexture MovieTexture or PixelTexture nodes within a sibling MultiTexture node.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'MultiTextureTransform'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#MultiTextureTransform'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MultiTextureTransform'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('textureTransform', [], FieldType.MFNode, AccessType.inputOutput, 'MultiTextureTransform'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        textureTransform=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode MultiTextureTransform __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.textureTransform = textureTransform
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def textureTransform(self):
        """[X3DSingleTextureTransformNode] Zero or more contained TextureTransform nodes, for each of the different texture channels, that define 2D transformation applied to texture coordinates."""
        return self.__textureTransform
    @textureTransform.setter
    def textureTransform(self, textureTransform):
        if  textureTransform is None:
            textureTransform = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(textureTransform)
        self.__textureTransform = textureTransform
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):

        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.textureTransform) > 0)
    # output function - - - - - - - - - -

class NavigationInfo(_X3DBindableNode):
    """
    NavigationInfo describes the user's viewing model, user navigation-interaction modalities, and also dimensional characteristics of the user's (typically invisible) avatar.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'NavigationInfo'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/navigation.html#NavigationInfo'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NavigationInfo'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('avatarSize', [0.25, 1.6, 0.75], FieldType.MFFloat, AccessType.inputOutput, 'NavigationInfo'),
        ('headlight', True, FieldType.SFBool, AccessType.inputOutput, 'NavigationInfo'),
        ('speed', 1, FieldType.SFFloat, AccessType.inputOutput, 'NavigationInfo'),
        ('transitionTime', 1.0, FieldType.SFTime, AccessType.inputOutput, 'NavigationInfo'),
        ('transitionType', ["LINEAR"], FieldType.MFString, AccessType.inputOutput, 'NavigationInfo'),
        ('type', ["EXAMINE", "ANY"], FieldType.MFString, AccessType.inputOutput, 'NavigationInfo'),
        ('visibilityLimit', 0, FieldType.SFFloat, AccessType.inputOutput, 'NavigationInfo'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        avatarSize=None,
        headlight=True,
        speed=1,
        transitionTime=1.0,
        transitionType=None,
        type=None,
        visibilityLimit=0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode NavigationInfo __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.avatarSize = avatarSize
        self.headlight = headlight
        self.speed = speed
        self.transitionTime = transitionTime
        self.transitionType = transitionType
        self.type = type
        self.visibilityLimit = visibilityLimit
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def avatarSize(self):
        """avatarSize triplet values define three separate parameters: (a) collisionDistance between user and geometry, i."""
        return self.__avatarSize
    @avatarSize.setter
    def avatarSize(self, avatarSize):
        if  avatarSize is None:
            avatarSize = [0.25, 1.6, 0.75]  # default
        assertValidMFFloat(avatarSize)
        assertNonNegative('avatarSize', avatarSize)
        self.__avatarSize = avatarSize
    @property # getter - - - - - - - - - -
    def headlight(self):
        """Enable/disable directional light that always points in the direction the user is looking."""
        return self.__headlight
    @headlight.setter
    def headlight(self, headlight):
        if  headlight is None:
            headlight = True  # default
        assertValidSFBool(headlight)
        self.__headlight = headlight
    @property # getter - - - - - - - - - -
    def speed(self):
        """[0,+infinity) Default rate at which viewer travels through scene, meters/second."""
        return self.__speed
    @speed.setter
    def speed(self, speed):
        if  speed is None:
            speed = 1  # default
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def transitionTime(self):
        """transitionTime defines the expected duration of viewpoint transition in seconds."""
        return self.__transitionTime
    @transitionTime.setter
    def transitionTime(self, transitionTime):
        if  transitionTime is None:
            transitionTime = 1.0  # default
        assertValidSFTime(transitionTime)
        assertNonNegative('transitionTime', transitionTime)
        self.__transitionTime = transitionTime
    @property # getter - - - - - - - - - -
    def transitionType(self):
        """Camera transition between viewpoints."""
        return self.__transitionType
    @transitionType.setter
    def transitionType(self, transitionType):
        if  transitionType is None:
            transitionType = ["LINEAR"]  # default
        assertValidMFString(transitionType)
        self.__transitionType = transitionType
    @property # getter - - - - - - - - - -
    def type(self):
        """Enter one or more quoted SFString values: "EXAMINE" "WALK" "FLY" "LOOKAT" "EXPLORE" "ANY" "NONE"."""
        return self.__type
    @type.setter
    def type(self, type):
        if  type is None:
            type = ["EXAMINE", "ANY"]  # default
        assertValidMFString(type)
        self.__type = type
    @property # getter - - - - - - - - - -
    def visibilityLimit(self):
        """Geometry beyond the visibilityLimit may not be rendered (far clipping plane of the view frustrum)."""
        return self.__visibilityLimit
    @visibilityLimit.setter
    def visibilityLimit(self, visibilityLimit):
        if  visibilityLimit is None:
            visibilityLimit = 0  # default
        assertValidSFFloat(visibilityLimit)
        assertNonNegative('visibilityLimit', visibilityLimit)
        self.__visibilityLimit = visibilityLimit
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))

        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class Normal(_X3DNormalNode):
    """
    Normal defines a set of 3D surface-normal vectors that apply either to a sibling Coordinate|CoordinateDouble node, or else to a parent ElevationGrid node.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Normal'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#Normal'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Normal'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('vector', [], FieldType.MFVec3f, AccessType.inputOutput, 'Normal'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        vector=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Normal __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.vector = vector
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def vector(self):
        """set of unit-length normal vectors, corresponding to indexed polygons or vertices."""
        return self.__vector
    @vector.setter
    def vector(self, vector):
        if  vector is None:
            vector = MFVec3f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec3f.DEFAULT_VALUE()))
        assertValidMFVec3f(vector)
        assertGreaterThanEquals('vector', vector, -1)
        assertLessThanEquals('vector', vector, 1)
        self.__vector = vector
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class NormalInterpolator(_X3DInterpolatorNode):
    """
    NormalInterpolator generates a series of normal (perpendicular) 3-tuple SFVec3f values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'NormalInterpolator'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#NormalInterpolator'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NormalInterpolator'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('key', [], FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
        ('keyValue', [], FieldType.MFVec3f, AccessType.inputOutput, 'NormalInterpolator'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        key=None,
        keyValue=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode NormalInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFVec3f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec3f.DEFAULT_VALUE()))
        assertValidMFVec3f(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class NurbsCurve(_X3DParametricGeometryNode):
    """
    NurbsCurve is a 3D curve analogous to NurbsPatchSurface.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'NurbsCurve'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsCurve'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsCurve'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('closed', False, FieldType.SFBool, AccessType.initializeOnly, 'NurbsCurve'),
        ('knot', [], FieldType.MFDouble, AccessType.initializeOnly, 'NurbsCurve'),
        ('order', 3, FieldType.SFInt32, AccessType.initializeOnly, 'NurbsCurve'),
        ('tessellation', 0, FieldType.SFInt32, AccessType.inputOutput, 'NurbsCurve'),
        ('weight', [], FieldType.MFDouble, AccessType.inputOutput, 'NurbsCurve'),
        ('controlPoint', None, FieldType.SFNode, AccessType.inputOutput, 'NurbsCurve'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        closed=False,
        knot=None,
        order=3,
        tessellation=0,
        weight=None,
        controlPoint=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode NurbsCurve __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.closed = closed
        self.knot = knot
        self.order = order
        self.tessellation = tessellation
        self.weight = weight
        self.controlPoint = controlPoint
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def closed(self):
        """Whether or not the curve is closed (i."""
        return self.__closed
    @closed.setter
    def closed(self, closed):
        if  closed is None:
            closed = False  # default
        assertValidSFBool(closed)
        self.__closed = closed
    @property # getter - - - - - - - - - -
    def knot(self):
        """knot vector, where size = number of control points + order of curve."""
        return self.__knot
    @knot.setter
    def knot(self, knot):
        if  knot is None:
            knot = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
        assertValidMFDouble(knot)
        self.__knot = knot
    @property # getter - - - - - - - - - -
    def order(self):
        """define order of surface by polynomials of degree = order-1."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3  # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 2)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tessellation(self):
        """hint for surface tessellation."""
        return self.__tessellation
    @tessellation.setter
    def tessellation(self, tessellation):
        if  tessellation is None:
            tessellation = 0  # default
        assertValidSFInt32(tessellation)
        self.__tessellation = tessellation
    @property # getter - - - - - - - - - -
    def weight(self):
        """Vector assigning relative weight value to each control point."""
        return self.__weight
    @weight.setter
    def weight(self, weight):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
        assertValidMFDouble(weight)
        assertPositive('weight', weight)
        self.__weight = weight
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        """[Coordinate|CoordinateDouble|GeoCoordinate] Single contained Coordinate or CoordinateDouble node that can specify control points for NURBS geometry definitions."""
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint):
        if  controlPoint is None:
            controlPoint = None  # default
        assertValidSFNode(controlPoint)
        if not controlPoint is None and not isinstance(controlPoint,(Coordinate,CoordinateDouble,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(controlPoint) + ' does not match required node type (Coordinate,CoordinateDouble,ProtoInstance) and is invalid')
        self.__controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.controlPoint or self.IS or self.metadata
    # output function - - - - - - - - - -

class NurbsCurve2D(_X3DNurbsControlCurveNode):
    """
    NurbsCurve2D defines a trimming segment that is part of a trimming contour in the u-v domain of a surface.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'NurbsCurve2D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsCurve2D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsCurve2D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('closed', False, FieldType.SFBool, AccessType.initializeOnly, 'NurbsCurve2D'),
        ('controlPoint', [], FieldType.MFVec2d, AccessType.inputOutput, 'X3DNurbsControlCurveNode'),
        ('knot', [], FieldType.MFDouble, AccessType.initializeOnly, 'NurbsCurve2D'),
        ('order', 3, FieldType.SFInt32, AccessType.initializeOnly, 'NurbsCurve2D'),
        ('tessellation', 0, FieldType.SFInt32, AccessType.inputOutput, 'NurbsCurve2D'),
        ('weight', [], FieldType.MFDouble, AccessType.inputOutput, 'NurbsCurve2D'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        closed=False,
        controlPoint=None,
        knot=None,
        order=3,
        tessellation=0,
        weight=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode NurbsCurve2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.closed = closed
        self.controlPoint = controlPoint
        self.knot = knot
        self.order = order
        self.tessellation = tessellation
        self.weight = weight
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def closed(self):
        """Whether or not the curve is closed (i."""
        return self.__closed
    @closed.setter
    def closed(self, closed):
        if  closed is None:
            closed = False  # default
        assertValidSFBool(closed)
        self.__closed = closed
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        """controlPoint defines a set of control points of dimension uDimension by vDimension, and defines a mesh where the points do not have uniform spacing."""
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint):
        if  controlPoint is None:
            controlPoint = MFVec2d.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec2d.DEFAULT_VALUE()))
        assertValidMFVec2d(controlPoint)
        self.__controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def knot(self):
        """knot vector, where size = number of control points + order of curve."""
        return self.__knot
    @knot.setter
    def knot(self, knot):
        if  knot is None:
            knot = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
        assertValidMFDouble(knot)
        self.__knot = knot
    @property # getter - - - - - - - - - -
    def order(self):
        """define order of surface by polynomials of degree = order-1."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3  # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 2)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tessellation(self):
        """hint for surface tessellation."""
        return self.__tessellation
    @tessellation.setter
    def tessellation(self, tessellation):
        if  tessellation is None:
            tessellation = 0  # default
        assertValidSFInt32(tessellation)
        self.__tessellation = tessellation
    @property # getter - - - - - - - - - -
    def weight(self):
        """Vector assigning relative weight value to each control point."""
        return self.__weight
    @weight.setter
    def weight(self, weight):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
        assertValidMFDouble(weight)
        assertPositive('weight', weight)
        self.__weight = weight
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class NurbsOrientationInterpolator(_X3DChildNode):
    """
    NurbsOrientationInterpolator describes a 3D NURBS curve and outputs interpolated orientation values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'NurbsOrientationInterpolator'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsOrientationInterpolator'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsOrientationInterpolator'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('knot', [], FieldType.MFDouble, AccessType.inputOutput, 'NurbsOrientationInterpolator'),
        ('order', 3, FieldType.SFInt32, AccessType.inputOutput, 'NurbsOrientationInterpolator'),
        ('weight', [], FieldType.MFDouble, AccessType.inputOutput, 'NurbsOrientationInterpolator'),
        ('controlPoint', None, FieldType.SFNode, AccessType.inputOutput, 'NurbsOrientationInterpolator'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        knot=None,
        order=3,
        weight=None,
        controlPoint=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode NurbsOrientationInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.knot = knot
        self.order = order
        self.weight = weight
        self.controlPoint = controlPoint
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def knot(self):
        """knot vector, where size = number of control points + order of curve."""
        return self.__knot
    @knot.setter
    def knot(self, knot):
        if  knot is None:
            knot = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
        assertValidMFDouble(knot)
        self.__knot = knot
    @property # getter - - - - - - - - - -
    def order(self):
        """define order of surface by polynomials of degree = order-1."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3  # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 2)
        self.__order = order
    @property # getter - - - - - - - - - -
    def weight(self):
        """Output values for computational interpolation, each corresponding to knots."""
        return self.__weight
    @weight.setter
    def weight(self, weight):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
        assertValidMFDouble(weight)
        self.__weight = weight
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        """[Coordinate|CoordinateDouble|GeoCoordinate] Single contained Coordinate or CoordinateDouble node that can specify control points for NURBS geometry definitions."""
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint):
        if  controlPoint is None:
            controlPoint = None  # default
        assertValidSFNode(controlPoint)
        if not controlPoint is None and not isinstance(controlPoint,(Coordinate,CoordinateDouble,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(controlPoint) + ' does not match required node type (Coordinate,CoordinateDouble,ProtoInstance) and is invalid')
        self.__controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.controlPoint or self.IS or self.metadata
    # output function - - - - - - - - - -

class NurbsPatchSurface(_X3DNurbsSurfaceGeometryNode):
    """
    NurbsPatchSurface defines a contiguous 3D Non-Uniform Rational B-Spline (NURBS) surface.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'NurbsPatchSurface'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsPatchSurface'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsPatchSurface'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
        ('uClosed', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
        ('uDimension', 0, FieldType.SFInt32, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
        ('uKnot', [], FieldType.MFDouble, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
        ('uOrder', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
        ('uTessellation', 0, FieldType.SFInt32, AccessType.inputOutput, 'X3DNurbsSurfaceGeometryNode'),
        ('vClosed', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
        ('vDimension', 0, FieldType.SFInt32, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
        ('vKnot', [], FieldType.MFDouble, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
        ('vOrder', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
        ('vTessellation', 0, FieldType.SFInt32, AccessType.inputOutput, 'X3DNurbsSurfaceGeometryNode'),
        ('weight', [], FieldType.MFDouble, AccessType.inputOutput, 'X3DNurbsSurfaceGeometryNode'),
        ('controlPoint', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNurbsSurfaceGeometryNode'),
        ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNurbsSurfaceGeometryNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        solid=True,
        uClosed=False,
        uDimension=0,
        uKnot=None,
        uOrder=3,
        uTessellation=0,
        vClosed=False,
        vDimension=0,
        vKnot=None,
        vOrder=3,
        vTessellation=0,
        weight=None,
        controlPoint=None,
        texCoord=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode NurbsPatchSurface __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.solid = solid
        self.uClosed = uClosed
        self.uDimension = uDimension
        self.uKnot = uKnot
        self.uOrder = uOrder
        self.uTessellation = uTessellation
        self.vClosed = vClosed
        self.vDimension = vDimension
        self.vKnot = vKnot
        self.vOrder = vOrder
        self.vTessellation = vTessellation
        self.weight = weight
        self.controlPoint = controlPoint
        self.texCoord = texCoord
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def uClosed(self):
        """Whether opposite surface sides are closed (seamless) across u dimension."""
        return self.__uClosed
    @uClosed.setter
    def uClosed(self, uClosed):
        if  uClosed is None:
            uClosed = False  # default
        assertValidSFBool(uClosed)
        self.__uClosed = uClosed
    @property # getter - - - - - - - - - -
    def uDimension(self):
        """Number of control points in u dimension."""
        return self.__uDimension
    @uDimension.setter
    def uDimension(self, uDimension):
        if  uDimension is None:
            uDimension = 0  # default
        assertValidSFInt32(uDimension)
        assertNonNegative('uDimension', uDimension)
        self.__uDimension = uDimension
    @property # getter - - - - - - - - - -
    def uKnot(self):
        """knot vector, where size = number of control points + order of curve."""
        return self.__uKnot
    @uKnot.setter
    def uKnot(self, uKnot):
        if  uKnot is None:
            uKnot = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
        assertValidMFDouble(uKnot)
        self.__uKnot = uKnot
    @property # getter - - - - - - - - - -
    def uOrder(self):
        """define order of surface by polynomials of degree = order-1."""
        return self.__uOrder
    @uOrder.setter
    def uOrder(self, uOrder):
        if  uOrder is None:
            uOrder = 3  # default
        assertValidSFInt32(uOrder)
        assertGreaterThanEquals('uOrder', uOrder, 2)
        self.__uOrder = uOrder
    @property # getter - - - - - - - - - -
    def uTessellation(self):
        """hint for surface tessellation."""
        return self.__uTessellation
    @uTessellation.setter
    def uTessellation(self, uTessellation):
        if  uTessellation is None:
            uTessellation = 0  # default
        assertValidSFInt32(uTessellation)
        self.__uTessellation = uTessellation
    @property # getter - - - - - - - - - -
    def vClosed(self):
        """Whether opposite surface sides are closed (seamless) across u dimension."""
        return self.__vClosed
    @vClosed.setter
    def vClosed(self, vClosed):
        if  vClosed is None:
            vClosed = False  # default
        assertValidSFBool(vClosed)
        self.__vClosed = vClosed
    @property # getter - - - - - - - - - -
    def vDimension(self):
        """Number of control points in v dimension."""
        return self.__vDimension
    @vDimension.setter
    def vDimension(self, vDimension):
        if  vDimension is None:
            vDimension = 0  # default
        assertValidSFInt32(vDimension)
        assertNonNegative('vDimension', vDimension)
        self.__vDimension = vDimension
    @property # getter - - - - - - - - - -
    def vKnot(self):
        """knot vector, where size = number of control points + order of curve."""
        return self.__vKnot
    @vKnot.setter
    def vKnot(self, vKnot):
        if  vKnot is None:
            vKnot = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
        assertValidMFDouble(vKnot)
        self.__vKnot = vKnot
    @property # getter - - - - - - - - - -
    def vOrder(self):
        """define order of surface by polynomials of degree = order-1."""
        return self.__vOrder
    @vOrder.setter
    def vOrder(self, vOrder):
        if  vOrder is None:
            vOrder = 3  # default
        assertValidSFInt32(vOrder)
        assertGreaterThanEquals('vOrder', vOrder, 2)
        self.__vOrder = vOrder
    @property # getter - - - - - - - - - -
    def vTessellation(self):
        """hint for surface tessellation."""
        return self.__vTessellation
    @vTessellation.setter
    def vTessellation(self, vTessellation):
        if  vTessellation is None:
            vTessellation = 0  # default
        assertValidSFInt32(vTessellation)
        self.__vTessellation = vTessellation
    @property # getter - - - - - - - - - -
    def weight(self):
        """Vector assigning relative weight value to each control point."""
        return self.__weight
    @weight.setter
    def weight(self, weight):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
        assertValidMFDouble(weight)
        assertPositive('weight', weight)
        self.__weight = weight
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        """[Coordinate|CoordinateDouble|GeoCoordinate] Single contained Coordinate or CoordinateDouble node that can specify control points for NURBS geometry definitions."""
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint):
        if  controlPoint is None:
            controlPoint = None  # default
        assertValidSFNode(controlPoint)
        if not controlPoint is None and not isinstance(controlPoint,(Coordinate,CoordinateDouble,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(controlPoint) + ' does not match required node type (Coordinate,CoordinateDouble,ProtoInstance) and is invalid')
        self.__controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode|NurbsTextureCoordinate] Single contained NurbsTextureCoordinate, TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that can specify coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None  # default
        assertValidSFNode(texCoord)
        if not texCoord is None and not isinstance(texCoord,(_X3DSingleTextureCoordinateNode,NurbsTextureCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not match required node type (_X3DSingleTextureCoordinateNode,NurbsTextureCoordinate,ProtoInstance) and is invalid')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.controlPoint or self.IS or self.metadata or self.texCoord
    # output function - - - - - - - - - -

class NurbsPositionInterpolator(_X3DChildNode):
    """
    NurbsPositionInterpolator describes a 3D NURBS curve and outputs interpolated position values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'NurbsPositionInterpolator'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsPositionInterpolator'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsPositionInterpolator'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('knot', [], FieldType.MFDouble, AccessType.inputOutput, 'NurbsPositionInterpolator'),
        ('order', 3, FieldType.SFInt32, AccessType.inputOutput, 'NurbsPositionInterpolator'),
        ('weight', [], FieldType.MFDouble, AccessType.inputOutput, 'NurbsPositionInterpolator'),
        ('controlPoint', None, FieldType.SFNode, AccessType.inputOutput, 'NurbsPositionInterpolator'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        knot=None,
        order=3,
        weight=None,
        controlPoint=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode NurbsPositionInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.knot = knot
        self.order = order
        self.weight = weight
        self.controlPoint = controlPoint
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def knot(self):
        """knot vector, where size = number of control points + order of curve."""
        return self.__knot
    @knot.setter
    def knot(self, knot):
        if  knot is None:
            knot = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
        assertValidMFDouble(knot)
        self.__knot = knot
    @property # getter - - - - - - - - - -
    def order(self):
        """define order of surface by polynomials of degree = order-1."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3  # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 2)
        self.__order = order
    @property # getter - - - - - - - - - -
    def weight(self):
        """Output values for linear interpolation, each corresponding to knots."""
        return self.__weight
    @weight.setter
    def weight(self, weight):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
        assertValidMFDouble(weight)
        self.__weight = weight
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        """[Coordinate|CoordinateDouble|GeoCoordinate] Single contained Coordinate or CoordinateDouble node that can specify control points for NURBS geometry definitions."""
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint):
        if  controlPoint is None:
            controlPoint = None  # default
        assertValidSFNode(controlPoint)
        if not controlPoint is None and not isinstance(controlPoint,(Coordinate,CoordinateDouble,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(controlPoint) + ' does not match required node type (Coordinate,CoordinateDouble,ProtoInstance) and is invalid')
        self.__controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.controlPoint or self.IS or self.metadata
    # output function - - - - - - - - - -

class NurbsSet(_X3DChildNode, _X3DBoundedObject):
    """
    NurbsSet collects a set of NurbsSurface nodes into a common group and treats NurbsSurface set as a unit during tessellation, thereby enforcing tessellation continuity along borders.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'NurbsSet'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsSet'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsSet'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('tessellationScale', 1.0, FieldType.SFFloat, AccessType.inputOutput, 'NurbsSet'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('geometry', [], FieldType.MFNode, AccessType.inputOutput, 'NurbsSet'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        tessellationScale=1.0,
        visible=True,
        geometry=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode NurbsSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.tessellationScale = tessellationScale
        self.visible = visible
        self.geometry = geometry
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def tessellationScale(self):
        """scale for surface tessellation in children NurbsSurface nodes."""
        return self.__tessellationScale
    @tessellationScale.setter
    def tessellationScale(self, tessellationScale):
        if  tessellationScale is None:
            tessellationScale = 1.0  # default
        assertValidSFFloat(tessellationScale)
        assertPositive('tessellationScale', tessellationScale)
        self.__tessellationScale = tessellationScale
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def geometry(self):
        """[NurbsPatchSurface|NurbsTrimmedSurface] The children form a closed loop with first point of first child repeated as last point of last child, and the last point of a segment repeated as first point of the consecutive one."""
        return self.__geometry
    @geometry.setter
    def geometry(self, geometry):
        if  geometry is None:
            geometry = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(geometry)
        self.__geometry = geometry
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.geometry) > 0)
    # output function - - - - - - - - - -

class NurbsSurfaceInterpolator(_X3DChildNode):
    """
    NurbsSurfaceInterpolator describes a 3D NURBS curve and outputs interpolated position and normal values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'NurbsSurfaceInterpolator'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsSurfaceInterpolator'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsSurfaceInterpolator'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('uDimension', 0, FieldType.SFInt32, AccessType.initializeOnly, 'NurbsSurfaceInterpolator'),
        ('uKnot', [], FieldType.MFDouble, AccessType.initializeOnly, 'NurbsSurfaceInterpolator'),
        ('uOrder', 3, FieldType.SFInt32, AccessType.initializeOnly, 'NurbsSurfaceInterpolator'),
        ('vDimension', 0, FieldType.SFInt32, AccessType.initializeOnly, 'NurbsSurfaceInterpolator'),
        ('vKnot', [], FieldType.MFDouble, AccessType.initializeOnly, 'NurbsSurfaceInterpolator'),
        ('vOrder', 3, FieldType.SFInt32, AccessType.initializeOnly, 'NurbsSurfaceInterpolator'),
        ('weight', [], FieldType.MFDouble, AccessType.inputOutput, 'NurbsSurfaceInterpolator'),
        ('controlPoint', None, FieldType.SFNode, AccessType.inputOutput, 'NurbsSurfaceInterpolator'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        uDimension=0,
        uKnot=None,
        uOrder=3,
        vDimension=0,
        vKnot=None,
        vOrder=3,
        weight=None,
        controlPoint=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode NurbsSurfaceInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.uDimension = uDimension
        self.uKnot = uKnot
        self.uOrder = uOrder
        self.vDimension = vDimension
        self.vKnot = vKnot
        self.vOrder = vOrder
        self.weight = weight
        self.controlPoint = controlPoint
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def uDimension(self):
        """Number of control points in u dimension."""
        return self.__uDimension
    @uDimension.setter
    def uDimension(self, uDimension):
        if  uDimension is None:
            uDimension = 0  # default
        assertValidSFInt32(uDimension)
        assertNonNegative('uDimension', uDimension)
        self.__uDimension = uDimension
    @property # getter - - - - - - - - - -
    def uKnot(self):
        """Knot vector, where size = number of control points + order of curve."""
        return self.__uKnot
    @uKnot.setter
    def uKnot(self, uKnot):
        if  uKnot is None:
            uKnot = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
        assertValidMFDouble(uKnot)
        self.__uKnot = uKnot
    @property # getter - - - - - - - - - -
    def uOrder(self):
        """Define order of surface by polynomials of degree = order-1."""
        return self.__uOrder
    @uOrder.setter
    def uOrder(self, uOrder):
        if  uOrder is None:
            uOrder = 3  # default
        assertValidSFInt32(uOrder)
        assertGreaterThanEquals('uOrder', uOrder, 2)
        self.__uOrder = uOrder
    @property # getter - - - - - - - - - -
    def vDimension(self):
        """Number of control points in v dimension."""
        return self.__vDimension
    @vDimension.setter
    def vDimension(self, vDimension):
        if  vDimension is None:
            vDimension = 0  # default
        assertValidSFInt32(vDimension)
        assertNonNegative('vDimension', vDimension)
        self.__vDimension = vDimension
    @property # getter - - - - - - - - - -
    def vKnot(self):
        """Knot vector, where size = number of control points + order of curve."""
        return self.__vKnot
    @vKnot.setter
    def vKnot(self, vKnot):
        if  vKnot is None:
            vKnot = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
        assertValidMFDouble(vKnot)
        self.__vKnot = vKnot
    @property # getter - - - - - - - - - -
    def vOrder(self):
        """Define order of surface by polynomials of degree = order-1."""
        return self.__vOrder
    @vOrder.setter
    def vOrder(self, vOrder):
        if  vOrder is None:
            vOrder = 3  # default
        assertValidSFInt32(vOrder)
        assertGreaterThanEquals('vOrder', vOrder, 2)
        self.__vOrder = vOrder
    @property # getter - - - - - - - - - -
    def weight(self):
        """Output values for linear interpolation, each corresponding to knots."""
        return self.__weight
    @weight.setter
    def weight(self, weight):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
        assertValidMFDouble(weight)
        self.__weight = weight
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        """[Coordinate|CoordinateDouble|GeoCoordinate] Single contained Coordinate or CoordinateDouble node that can specify control points for NURBS geometry definitions."""
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint):
        if  controlPoint is None:
            controlPoint = None  # default
        assertValidSFNode(controlPoint)
        if not controlPoint is None and not isinstance(controlPoint,(Coordinate,CoordinateDouble,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(controlPoint) + ' does not match required node type (Coordinate,CoordinateDouble,ProtoInstance) and is invalid')
        self.__controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.controlPoint or self.IS or self.metadata
    # output function - - - - - - - - - -

class NurbsSweptSurface(_X3DParametricGeometryNode):
    """
    NurbsSweptSurface uses a trajectoryCurve path to describe a generalized surface that is swept by a crossSectionCurve.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'NurbsSweptSurface'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsSweptSurface'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsSweptSurface'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'NurbsSweptSurface'),
        ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'NurbsSweptSurface'),
        ('crossSectionCurve', None, FieldType.SFNode, AccessType.inputOutput, 'NurbsSweptSurface'),
        ('trajectoryCurve', None, FieldType.SFNode, AccessType.inputOutput, 'NurbsSweptSurface'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        ccw=True,
        solid=True,
        crossSectionCurve=None,
        trajectoryCurve=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode NurbsSweptSurface __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.solid = solid
        self.crossSectionCurve = crossSectionCurve
        self.trajectoryCurve = trajectoryCurve
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True  # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def crossSectionCurve(self):
        """[X3DNurbsControlCurveNode] defines cross-section of the surface traced about the trajectoryCurve axis."""
        return self.__crossSectionCurve
    @crossSectionCurve.setter
    def crossSectionCurve(self, crossSectionCurve):
        if  crossSectionCurve is None:
            crossSectionCurve = None  # default
        assertValidSFNode(crossSectionCurve)
        if not crossSectionCurve is None and not isinstance(crossSectionCurve,(_X3DNurbsControlCurveNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(crossSectionCurve) + ' does not match required node type (_X3DNurbsControlCurveNode,ProtoInstance) and is invalid')
        self.__crossSectionCurve = crossSectionCurve
    @property # getter - - - - - - - - - -
    def trajectoryCurve(self):
        """[NurbsCurve] describes the center-line path using a NurbsCurve node, oriented so that it is defined counterclockwise when looking down the -Y axis, thus defining a concept of inside and outside."""
        return self.__trajectoryCurve
    @trajectoryCurve.setter
    def trajectoryCurve(self, trajectoryCurve):
        if  trajectoryCurve is None:
            trajectoryCurve = None  # default
        assertValidSFNode(trajectoryCurve)
        if not trajectoryCurve is None and not isinstance(trajectoryCurve,(NurbsCurve,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(trajectoryCurve) + ' does not match required node type (NurbsCurve,ProtoInstance) and is invalid')
        self.__trajectoryCurve = trajectoryCurve
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.crossSectionCurve or self.IS or self.metadata or self.trajectoryCurve
    # output function - - - - - - - - - -

class NurbsSwungSurface(_X3DParametricGeometryNode):
    """
    NurbsSwungSurface contains a profileCurve and a trajectoryCurve [X3DNurbsControlCurveNode].
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'NurbsSwungSurface'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsSwungSurface'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsSwungSurface'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'NurbsSwungSurface'),
        ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'NurbsSwungSurface'),
        ('profileCurve', None, FieldType.SFNode, AccessType.inputOutput, 'NurbsSwungSurface'),
        ('trajectoryCurve', None, FieldType.SFNode, AccessType.inputOutput, 'NurbsSwungSurface'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        ccw=True,
        solid=True,
        profileCurve=None,
        trajectoryCurve=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode NurbsSwungSurface __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.solid = solid
        self.profileCurve = profileCurve
        self.trajectoryCurve = trajectoryCurve
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True  # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def profileCurve(self):
        """[X3DNurbsControlCurveNode] 2D curve in the yz-plane that describes the cross-sectional shape of the object."""
        return self.__profileCurve
    @profileCurve.setter
    def profileCurve(self, profileCurve):
        if  profileCurve is None:
            profileCurve = None  # default
        assertValidSFNode(profileCurve)
        if not profileCurve is None and not isinstance(profileCurve,(_X3DNurbsControlCurveNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(profileCurve) + ' does not match required node type (_X3DNurbsControlCurveNode,ProtoInstance) and is invalid')
        self.__profileCurve = profileCurve
    @property # getter - - - - - - - - - -
    def trajectoryCurve(self):
        """[X3DNurbsControlCurveNode] 2D curve in the xz-plane that describes path over which to trace the cross-section."""
        return self.__trajectoryCurve
    @trajectoryCurve.setter
    def trajectoryCurve(self, trajectoryCurve):
        if  trajectoryCurve is None:
            trajectoryCurve = None  # default
        assertValidSFNode(trajectoryCurve)
        if not trajectoryCurve is None and not isinstance(trajectoryCurve,(_X3DNurbsControlCurveNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(trajectoryCurve) + ' does not match required node type (_X3DNurbsControlCurveNode,ProtoInstance) and is invalid')
        self.__trajectoryCurve = trajectoryCurve
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.profileCurve or self.trajectoryCurve
    # output function - - - - - - - - - -

class NurbsTextureCoordinate(_X3DNode):
    """
    NurbsTextureCoordinate describes a 3D NURBS surface in the parametric domain of its surface host, specifying mapping of texture onto the surface.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'NurbsTextureCoordinate'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsTextureCoordinate'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsTextureCoordinate'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('controlPoint', [], FieldType.MFVec2f, AccessType.inputOutput, 'NurbsTextureCoordinate'),
        ('uDimension', 0, FieldType.SFInt32, AccessType.initializeOnly, 'NurbsTextureCoordinate'),
        ('uKnot', [], FieldType.MFDouble, AccessType.initializeOnly, 'NurbsTextureCoordinate'),
        ('uOrder', 3, FieldType.SFInt32, AccessType.initializeOnly, 'NurbsTextureCoordinate'),
        ('vDimension', 0, FieldType.SFInt32, AccessType.initializeOnly, 'NurbsTextureCoordinate'),
        ('vKnot', [], FieldType.MFDouble, AccessType.initializeOnly, 'NurbsTextureCoordinate'),
        ('vOrder', 3, FieldType.SFInt32, AccessType.initializeOnly, 'NurbsTextureCoordinate'),
        ('weight', [], FieldType.MFDouble, AccessType.inputOutput, 'NurbsTextureCoordinate'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        controlPoint=None,
        uDimension=0,
        uKnot=None,
        uOrder=3,
        vDimension=0,
        vKnot=None,
        vOrder=3,
        weight=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode NurbsTextureCoordinate __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.controlPoint = controlPoint
        self.uDimension = uDimension
        self.uKnot = uKnot
        self.uOrder = uOrder
        self.vDimension = vDimension
        self.vKnot = vKnot
        self.vOrder = vOrder
        self.weight = weight
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        """controlPoint defines a set of control points of dimension uDimension by vDimension, and defines a mesh where the points do not have uniform spacing."""
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint):
        if  controlPoint is None:
            controlPoint = MFVec2f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec2f.DEFAULT_VALUE()))
        assertValidMFVec2f(controlPoint)
        self.__controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def uDimension(self):
        """Number of control points in u dimension."""
        return self.__uDimension
    @uDimension.setter
    def uDimension(self, uDimension):
        if  uDimension is None:
            uDimension = 0  # default
        assertValidSFInt32(uDimension)
        assertNonNegative('uDimension', uDimension)
        self.__uDimension = uDimension
    @property # getter - - - - - - - - - -
    def uKnot(self):
        """Knot vector, where size = number of control points + order of curve."""
        return self.__uKnot
    @uKnot.setter
    def uKnot(self, uKnot):
        if  uKnot is None:
            uKnot = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
        assertValidMFDouble(uKnot)
        self.__uKnot = uKnot
    @property # getter - - - - - - - - - -
    def uOrder(self):
        """Define order of surface by polynomials of degree = order-1."""
        return self.__uOrder
    @uOrder.setter
    def uOrder(self, uOrder):
        if  uOrder is None:
            uOrder = 3  # default
        assertValidSFInt32(uOrder)
        assertGreaterThanEquals('uOrder', uOrder, 2)
        self.__uOrder = uOrder
    @property # getter - - - - - - - - - -
    def vDimension(self):
        """Number of control points in v dimension."""
        return self.__vDimension
    @vDimension.setter
    def vDimension(self, vDimension):
        if  vDimension is None:
            vDimension = 0  # default
        assertValidSFInt32(vDimension)
        assertNonNegative('vDimension', vDimension)
        self.__vDimension = vDimension
    @property # getter - - - - - - - - - -
    def vKnot(self):
        """Knot vector, where size = number of control points + order of curve."""
        return self.__vKnot
    @vKnot.setter
    def vKnot(self, vKnot):
        if  vKnot is None:
            vKnot = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
        assertValidMFDouble(vKnot)
        self.__vKnot = vKnot
    @property # getter - - - - - - - - - -
    def vOrder(self):
        """Define order of surface by polynomials of degree = order-1."""
        return self.__vOrder
    @vOrder.setter
    def vOrder(self, vOrder):
        if  vOrder is None:
            vOrder = 3  # default
        assertValidSFInt32(vOrder)
        assertGreaterThanEquals('vOrder', vOrder, 2)
        self.__vOrder = vOrder
    @property # getter - - - - - - - - - -
    def weight(self):
        """Output values for linear interpolation, each corresponding to knots."""
        return self.__weight
    @weight.setter
    def weight(self, weight):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
        assertValidMFDouble(weight)
        assertPositive('weight', weight)
        self.__weight = weight
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class NurbsTrimmedSurface(_X3DNurbsSurfaceGeometryNode):
    """
    NurbsTrimmedSurface generates texture coordinates from a Non-Uniform Rational B-Spline (NURBS) surface.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'NurbsTrimmedSurface'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsTrimmedSurface'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsTrimmedSurface'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
        ('uClosed', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
        ('uDimension', 0, FieldType.SFInt32, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
        ('uKnot', [], FieldType.MFDouble, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
        ('uOrder', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
        ('uTessellation', 0, FieldType.SFInt32, AccessType.inputOutput, 'X3DNurbsSurfaceGeometryNode'),
        ('vClosed', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
        ('vDimension', 0, FieldType.SFInt32, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
        ('vKnot', [], FieldType.MFDouble, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
        ('vOrder', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
        ('vTessellation', 0, FieldType.SFInt32, AccessType.inputOutput, 'X3DNurbsSurfaceGeometryNode'),
        ('weight', [], FieldType.MFDouble, AccessType.inputOutput, 'X3DNurbsSurfaceGeometryNode'),
        ('controlPoint', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNurbsSurfaceGeometryNode'),
        ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNurbsSurfaceGeometryNode'),
        ('trimmingContour', [], FieldType.MFNode, AccessType.inputOutput, 'NurbsTrimmedSurface'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        solid=True,
        uClosed=False,
        uDimension=0,
        uKnot=None,
        uOrder=3,
        uTessellation=0,
        vClosed=False,
        vDimension=0,
        vKnot=None,
        vOrder=3,
        vTessellation=0,
        weight=None,
        controlPoint=None,
        texCoord=None,
        trimmingContour=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode NurbsTrimmedSurface __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.solid = solid
        self.uClosed = uClosed
        self.uDimension = uDimension
        self.uKnot = uKnot
        self.uOrder = uOrder
        self.uTessellation = uTessellation
        self.vClosed = vClosed
        self.vDimension = vDimension
        self.vKnot = vKnot
        self.vOrder = vOrder
        self.vTessellation = vTessellation
        self.weight = weight
        self.controlPoint = controlPoint
        self.texCoord = texCoord
        self.trimmingContour = trimmingContour
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def uClosed(self):
        """Whether opposite surface sides are closed (seamless) across u dimension."""
        return self.__uClosed
    @uClosed.setter
    def uClosed(self, uClosed):
        if  uClosed is None:
            uClosed = False  # default
        assertValidSFBool(uClosed)
        self.__uClosed = uClosed
    @property # getter - - - - - - - - - -
    def uDimension(self):
        """Number of control points in u dimension."""
        return self.__uDimension
    @uDimension.setter
    def uDimension(self, uDimension):
        if  uDimension is None:
            uDimension = 0  # default
        assertValidSFInt32(uDimension)
        assertNonNegative('uDimension', uDimension)
        self.__uDimension = uDimension
    @property # getter - - - - - - - - - -
    def uKnot(self):
        """Knot vector, where size = number of control points + order of curve."""
        return self.__uKnot
    @uKnot.setter
    def uKnot(self, uKnot):
        if  uKnot is None:
            uKnot = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
        assertValidMFDouble(uKnot)
        self.__uKnot = uKnot
    @property # getter - - - - - - - - - -
    def uOrder(self):
        """Define order of surface by polynomials of degree = order-1."""
        return self.__uOrder
    @uOrder.setter
    def uOrder(self, uOrder):
        if  uOrder is None:
            uOrder = 3  # default
        assertValidSFInt32(uOrder)
        assertGreaterThanEquals('uOrder', uOrder, 2)
        self.__uOrder = uOrder
    @property # getter - - - - - - - - - -
    def uTessellation(self):
        """hint for surface tessellation."""
        return self.__uTessellation
    @uTessellation.setter
    def uTessellation(self, uTessellation):
        if  uTessellation is None:
            uTessellation = 0  # default
        assertValidSFInt32(uTessellation)
        self.__uTessellation = uTessellation
    @property # getter - - - - - - - - - -
    def vClosed(self):
        """Whether opposite surface sides are closed (seamless) across u dimension."""
        return self.__vClosed
    @vClosed.setter
    def vClosed(self, vClosed):
        if  vClosed is None:
            vClosed = False  # default
        assertValidSFBool(vClosed)
        self.__vClosed = vClosed
    @property # getter - - - - - - - - - -
    def vDimension(self):
        """Number of control points in v dimension."""
        return self.__vDimension
    @vDimension.setter
    def vDimension(self, vDimension):
        if  vDimension is None:
            vDimension = 0  # default
        assertValidSFInt32(vDimension)
        assertNonNegative('vDimension', vDimension)
        self.__vDimension = vDimension
    @property # getter - - - - - - - - - -
    def vKnot(self):
        """Knot vector, where size = number of control points + order of curve."""
        return self.__vKnot
    @vKnot.setter
    def vKnot(self, vKnot):
        if  vKnot is None:
            vKnot = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
        assertValidMFDouble(vKnot)
        self.__vKnot = vKnot
    @property # getter - - - - - - - - - -
    def vOrder(self):
        """Define order of surface by polynomials of degree = order-1."""
        return self.__vOrder
    @vOrder.setter
    def vOrder(self, vOrder):
        if  vOrder is None:
            vOrder = 3  # default
        assertValidSFInt32(vOrder)
        assertGreaterThanEquals('vOrder', vOrder, 2)
        self.__vOrder = vOrder
    @property # getter - - - - - - - - - -
    def vTessellation(self):
        """hint for surface tessellation."""
        return self.__vTessellation
    @vTessellation.setter
    def vTessellation(self, vTessellation):
        if  vTessellation is None:
            vTessellation = 0  # default
        assertValidSFInt32(vTessellation)
        self.__vTessellation = vTessellation
    @property # getter - - - - - - - - - -
    def weight(self):
        """Vector assigning relative weight value to each control point."""
        return self.__weight
    @weight.setter
    def weight(self, weight):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFDouble.DEFAULT_VALUE()))
        assertValidMFDouble(weight)
        assertPositive('weight', weight)
        self.__weight = weight
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        """[Coordinate|CoordinateDouble|GeoCoordinate] Single contained Coordinate or CoordinateDouble node that can specify control points for NURBS geometry definitions."""
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint):
        if  controlPoint is None:
            controlPoint = None  # default
        assertValidSFNode(controlPoint)
        if not controlPoint is None and not isinstance(controlPoint,(Coordinate,CoordinateDouble,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(controlPoint) + ' does not match required node type (Coordinate,CoordinateDouble,ProtoInstance) and is invalid')
        self.__controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode|NurbsTextureCoordinate] Single contained NurbsTextureCoordinate, TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that can specify coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None  # default
        assertValidSFNode(texCoord)
        if not texCoord is None and not isinstance(texCoord,(_X3DSingleTextureCoordinateNode,NurbsTextureCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not match required node type (_X3DSingleTextureCoordinateNode,NurbsTextureCoordinate,ProtoInstance) and is invalid')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def trimmingContour(self):
        """[Contour2D] A set of Contour2D nodes are used as trimming loops."""
        return self.__trimmingContour
    @trimmingContour.setter
    def trimmingContour(self, trimmingContour):
        if  trimmingContour is None:
            trimmingContour = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(trimmingContour)
        self.__trimmingContour = trimmingContour
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.controlPoint or self.IS or self.metadata or self.texCoord or (len(self.trimmingContour) > 0)
    # output function - - - - - - - - - -

class OpacityMapVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    OpacityMapVolumeStyle specifies that volumetric data is rendered using opacity mapped to a transfer function texture.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'OpacityMapVolumeStyle'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#OpacityMapVolumeStyle'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#OpacityMapVolumeStyle'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeRenderStyleNode'),
        ('transferFunction', None, FieldType.SFNode, AccessType.inputOutput, 'OpacityMapVolumeStyle'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        enabled=True,
        transferFunction=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode OpacityMapVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.transferFunction = transferFunction
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def transferFunction(self):
        """[X3DTexture2DNode,X3DTexture3DNode] The transferFunction field holds a single texture representation in either two or three dimensions that maps the voxel data values to a specific colour output."""
        return self.__transferFunction
    @transferFunction.setter
    def transferFunction(self, transferFunction):
        if  transferFunction is None:
            transferFunction = None  # default
        assertValidSFNode(transferFunction)
        if not transferFunction is None and not isinstance(transferFunction,(_X3DTexture2DNode,_X3DTexture3DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(transferFunction) + ' does not match required node type (_X3DTexture2DNode,_X3DTexture3DNode,ProtoInstance) and is invalid')
        self.__transferFunction = transferFunction
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.transferFunction
    # output function - - - - - - - - - -

class OrientationChaser(_X3DChaserNode):
    """
    OrientationChaser generates a series of 4-tuple axis-angle SFRotation values that progressively change from initial value to destination value.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'OrientationChaser'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#OrientationChaser'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#OrientationChaser'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('duration', 1, FieldType.SFTime, AccessType.initializeOnly, 'X3DChaserNode'),
        ('initialDestination', (0, 1, 0, 0), FieldType.SFRotation, AccessType.initializeOnly, 'OrientationChaser'),
        ('initialValue', (0, 1, 0, 0), FieldType.SFRotation, AccessType.initializeOnly, 'OrientationChaser'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        duration=1,
        initialDestination=(0, 1, 0, 0),
        initialValue=(0, 1, 0, 0),
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode OrientationChaser __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.duration = duration
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def duration(self):
        """[0,+infinity) duration is the time interval for filter response in seconds."""
        return self.__duration
    @duration.setter
    def duration(self, duration):
        if  duration is None:
            duration = 1  # default
        assertValidSFTime(duration)
        assertNonNegative('duration', duration)
        self.__duration = duration
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = (0, 1, 0, 0)  # default
        assertValidSFRotation(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = (0, 1, 0, 0)  # default
        assertValidSFRotation(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class OrientationDamper(_X3DDamperNode):
    """
    OrientationDamper generates a series of 4-tuple axis-angle SFRotation values that progressively change from initial value to destination value.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'OrientationDamper'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#OrientationDamper'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#OrientationDamper'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('initialDestination', (0, 1, 0, 0), FieldType.SFRotation, AccessType.initializeOnly, 'OrientationDamper'),
        ('initialValue', (0, 1, 0, 0), FieldType.SFRotation, AccessType.initializeOnly, 'OrientationDamper'),
        ('order', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DDamperNode'),
        ('tau', 0.3, FieldType.SFTime, AccessType.inputOutput, 'X3DDamperNode'),
        ('tolerance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DDamperNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        initialDestination=(0, 1, 0, 0),
        initialValue=(0, 1, 0, 0),
        order=3,
        tau=0.3,
        tolerance=-1,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode OrientationDamper __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.order = order
        self.tau = tau
        self.tolerance = tolerance
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = (0, 1, 0, 0)  # default
        assertValidSFRotation(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = (0, 1, 0, 0)  # default
        assertValidSFRotation(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def order(self):
        """[0,5] order defines the number of internal filters (larger means smoother response, longer delay)."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3  # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 0)
        assertLessThanEquals('order', order, 5)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tau(self):
        """[0,+infinity) tau is the exponential-decay time constant for filter response in seconds."""
        return self.__tau
    @tau.setter
    def tau(self, tau):
        if  tau is None:
            tau = 0.3  # default
        assertValidSFTime(tau)
        assertNonNegative('tau', tau)
        self.__tau = tau
    @property # getter - - - - - - - - - -
    def tolerance(self):
        """[0,+infinity) or -1."""
        return self.__tolerance
    @tolerance.setter
    def tolerance(self, tolerance):
        if  tolerance is None:
            tolerance = -1  # default
        assertValidSFFloat(tolerance)
        self.__tolerance = tolerance
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class OrientationInterpolator(_X3DInterpolatorNode):
    """
    OrientationInterpolator generates a series of 4-tuple axis-angle SFRotation values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'OrientationInterpolator'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#OrientationInterpolator'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#OrientationInterpolator'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('key', [], FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
        ('keyValue', [], FieldType.MFRotation, AccessType.inputOutput, 'OrientationInterpolator'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        key=None,
        keyValue=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode OrientationInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFRotation.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFRotation.DEFAULT_VALUE()))
        assertValidMFRotation(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class OrthoViewpoint(_X3DViewpointNode):
    """
    OrthoViewpoint provides an orthographic perspective-free view of a scene from a specific location and direction.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'OrthoViewpoint'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/navigation.html#OrthoViewpoint'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#OrthoViewpoint'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('centerOfRotation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'OrthoViewpoint'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DViewpointNode'),
        ('farDistance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DViewpointNode'),
        ('fieldOfView', [-1, -1, 1, 1], FieldType.MFFloat, AccessType.inputOutput, 'OrthoViewpoint'),
        ('jump', True, FieldType.SFBool, AccessType.inputOutput, 'X3DViewpointNode'),
        ('nearDistance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DViewpointNode'),
        ('orientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'X3DViewpointNode'),
        ('position', (0, 0, 10), FieldType.SFVec3f, AccessType.inputOutput, 'OrthoViewpoint'),
        ('retainUserOffsets', False, FieldType.SFBool, AccessType.inputOutput, 'X3DViewpointNode'),
        ('viewAll', False, FieldType.SFBool, AccessType.inputOutput, 'X3DViewpointNode'),
        ('navigationInfo', None, FieldType.SFNode, AccessType.inputOutput, 'X3DViewpointNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        centerOfRotation=(0, 0, 0),
        description='',
        farDistance=-1,
        fieldOfView=None,
        jump=True,
        nearDistance=-1,
        orientation=(0, 0, 1, 0),
        position=(0, 0, 10),
        retainUserOffsets=False,
        viewAll=False,
        navigationInfo=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode OrthoViewpoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.centerOfRotation = centerOfRotation
        self.description = description
        self.farDistance = farDistance
        self.fieldOfView = fieldOfView
        self.jump = jump
        self.nearDistance = nearDistance
        self.orientation = orientation
        self.position = position
        self.retainUserOffsets = retainUserOffsets
        self.viewAll = viewAll
        self.navigationInfo = navigationInfo
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def centerOfRotation(self):
        """centerOfRotation specifies center point about which to rotate user's eyepoint when in EXAMINE or LOOKAT mode."""
        return self.__centerOfRotation
    @centerOfRotation.setter
    def centerOfRotation(self, centerOfRotation):
        if  centerOfRotation is None:
            centerOfRotation = (0, 0, 0)  # default
        assertValidSFVec3f(centerOfRotation)
        self.__centerOfRotation = centerOfRotation
    @property # getter - - - - - - - - - -
    def description(self):
        """Text description or navigation hint to describe the significance of this model Viewpoint."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def farDistance(self):
        """or (0,+infinity) farDistance defines maximum clipping plane distance allowed for object display."""
        return self.__farDistance
    @farDistance.setter
    def farDistance(self, farDistance):
        if  farDistance is None:
            farDistance = -1  # default
        assertValidSFFloat(farDistance)
        self.__farDistance = farDistance
    @property # getter - - - - - - - - - -
    def fieldOfView(self):
        """Minimum and maximum extents of view in units of local coordinate system."""
        return self.__fieldOfView
    @fieldOfView.setter
    def fieldOfView(self, fieldOfView):
        if  fieldOfView is None:
            fieldOfView = [-1, -1, 1, 1]  # default
        assertValidMFFloat(fieldOfView)
        self.__fieldOfView = fieldOfView
    @property # getter - - - - - - - - - -
    def jump(self):
        """Transition instantly by jumping, otherwise smoothly adjust offsets in place when changing to this Viewpoint."""
        return self.__jump
    @jump.setter
    def jump(self, jump):
        if  jump is None:
            jump = True  # default
        assertValidSFBool(jump)
        self.__jump = jump
    @property # getter - - - - - - - - - -
    def nearDistance(self):
        """or (0,+infinity) nearDistance defines minimum clipping plane distance necessary for object display."""
        return self.__nearDistance
    @nearDistance.setter
    def nearDistance(self, nearDistance):
        if  nearDistance is None:
            nearDistance = -1  # default
        assertValidSFFloat(nearDistance)
        self.__nearDistance = nearDistance
    @property # getter - - - - - - - - - -
    def orientation(self):
        """Rotation (axis, angle in radians) of Viewpoint, relative to default -Z axis direction in local coordinate system."""
        return self.__orientation
    @orientation.setter
    def orientation(self, orientation):
        if  orientation is None:
            orientation = (0, 0, 1, 0)  # default
        assertValidSFRotation(orientation)
        self.__orientation = orientation
    @property # getter - - - - - - - - - -
    def position(self):
        """position (x, y, z in meters) relative to local coordinate system."""
        return self.__position
    @position.setter
    def position(self, position):
        if  position is None:
            position = (0, 0, 10)  # default
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def retainUserOffsets(self):
        """Retain (true) or reset to zero (false) any prior user navigation offsets from defined viewpoint position, orientation."""
        return self.__retainUserOffsets
    @retainUserOffsets.setter
    def retainUserOffsets(self, retainUserOffsets):
        if  retainUserOffsets is None:
            retainUserOffsets = False  # default
        assertValidSFBool(retainUserOffsets)
        self.__retainUserOffsets = retainUserOffsets
    @property # getter - - - - - - - - - -
    def viewAll(self):
        """Viewpoint is automatically adjusted to view all visible geometry."""
        return self.__viewAll
    @viewAll.setter
    def viewAll(self, viewAll):
        if  viewAll is None:
            viewAll = False  # default
        assertValidSFBool(viewAll)
        self.__viewAll = viewAll
    @property # getter - - - - - - - - - -
    def navigationInfo(self):
        """[NavigationInfo] The navigationInfo field defines a dedicated NavigationInfo node for this X3DViewpointNode."""
        return self.__navigationInfo
    @navigationInfo.setter
    def navigationInfo(self, navigationInfo):
        if  navigationInfo is None:
            navigationInfo = None  # default
        assertValidSFNode(navigationInfo)
        if not navigationInfo is None and not isinstance(navigationInfo,(NavigationInfo,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(navigationInfo) + ' does not match required node type (NavigationInfo,ProtoInstance) and is invalid')
        self.__navigationInfo = navigationInfo
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.navigationInfo
    # output function - - - - - - - - - -

class OscillatorSource(_X3DSoundSourceNode):
    """
    OscillatorSource node represents an audio source generating a periodic waveform, providing a constant tone.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'OscillatorSource'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#OscillatorSource'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#OscillatorSource'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('detune', 0, FieldType.SFFloat, AccessType.inputOutput, 'OscillatorSource'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundSourceNode'),
        ('frequency', 440, FieldType.SFFloat, AccessType.inputOutput, 'OscillatorSource'),
        ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundSourceNode'),
        ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        description='',
        detune=0,
        enabled=True,
        frequency=440,
        gain=1,
        pauseTime=0,
        resumeTime=0,
        startTime=0,
        stopTime=0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode OscillatorSource __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.detune = detune
        self.enabled = enabled
        self.frequency = frequency
        self.gain = gain
        self.pauseTime = pauseTime
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def detune(self):
        """(0,+infinity) The detune ffield is an a-rate AudioParam representing detuning of oscillation in cents (though the AudioParam returned is read-only, the value it represents is not)."""
        return self.__detune
    @detune.setter
    def detune(self, detune):
        if  detune is None:
            detune = 0  # default
        assertValidSFFloat(detune)
        assertNonNegative('detune', detune)
        self.__detune = detune
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def frequency(self):
        """The frequency of oscillation in hertz."""
        return self.__frequency
    @frequency.setter
    def frequency(self, frequency):
        if  frequency is None:
            frequency = 440  # default
        assertValidSFFloat(frequency)
        assertNonNegative('frequency', frequency)
        self.__frequency = frequency
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1  # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0  # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0  # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0  # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0  # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class PackagedShader(_X3DShaderNode):  # , _X3DUrlObject, _X3DProgrammableShaderObject  # TODO fix additional inheritance method resolution order (MRO)
    """
    PackagedShader can contain field declarations, but no CDATA section of plain-text source code.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'PackagedShader'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shaders.html#PackagedShader'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PackagedShader'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('autoRefresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('autoRefreshTimeLimit', 3600, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DUrlObject'),
        ('language', '', FieldType.SFString, AccessType.initializeOnly, 'X3DShaderNode'),
        ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
        ('url', [], FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
        ('field', [], FieldType.MFNode, AccessType.inputOutput, 'PackagedShader'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'PackagedShader'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'PackagedShader'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        autoRefresh=0,
        autoRefreshTimeLimit=3600,
        description='',
        language='',
        load=True,
        url=None,
        field=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode PackagedShader __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.autoRefresh = autoRefresh
        self.autoRefreshTimeLimit = autoRefreshTimeLimit
        self.description = description
        self.language = language
        self.load = load
        self.url = url
        self.field = field
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def autoRefresh(self):
        """autoRefresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__autoRefresh
    @autoRefresh.setter
    def autoRefresh(self, autoRefresh):
        if  autoRefresh is None:
            autoRefresh = 0  # default
        assertValidSFTime(autoRefresh)
        assertNonNegative('autoRefresh', autoRefresh)
        self.__autoRefresh = autoRefresh
    @property # getter - - - - - - - - - -
    def autoRefreshTimeLimit(self):
        """autoRefreshTimeLimit defines maximum duration that automatic refresh activity can occur."""
        return self.__autoRefreshTimeLimit
    @autoRefreshTimeLimit.setter
    def autoRefreshTimeLimit(self, autoRefreshTimeLimit):
        if  autoRefreshTimeLimit is None:
            autoRefreshTimeLimit = 3600  # default
        assertValidSFTime(autoRefreshTimeLimit)
        assertNonNegative('autoRefreshTimeLimit', autoRefreshTimeLimit)
        self.__autoRefreshTimeLimit = autoRefreshTimeLimit
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def language(self):
        """The language field indicates to the X3D player which shading language is used."""
        return self.__language
    @language.setter
    def language(self, language):
        if  language is None:
            language = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(language)
        self.__language = language
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True  # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def url(self):
        """url points to a shader source-code file that may contain a number of shaders and combined effects."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def field(self):
        """Include a field statement for each field declaration in the PackagedShader node."""
        return self.__field
    @field.setter
    def field(self, field):
        if  field is None:
            field = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        # TODO type-aware checks for field
        if field: # walk each child in list, if any (avoid empty list recursion)
            for each in field:
                assertValidFieldInitializationValue(each.name, each.type, each.value, parent='PackagedShader')
        self.__field = field
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.field) > 0)
    # output function - - - - - - - - - -

class ParticleSystem(_X3DShapeNode):
    """
    ParticleSystem specifies a complete particle system.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ParticleSystem'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#ParticleSystem'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ParticleSystem'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DShapeNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DShapeNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DShapeNode'),
        ('castShadow', True, FieldType.SFBool, AccessType.inputOutput, 'X3DShapeNode'),
        ('colorKey', [], FieldType.MFFloat, AccessType.initializeOnly, 'ParticleSystem'),
        ('createParticles', True, FieldType.SFBool, AccessType.inputOutput, 'ParticleSystem'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'ParticleSystem'),
        ('geometryType', 'QUAD', FieldType.SFString, AccessType.initializeOnly, 'ParticleSystem'),
        ('lifetimeVariation', 0.25, FieldType.SFFloat, AccessType.inputOutput, 'ParticleSystem'),
        ('maxParticles', 200, FieldType.SFInt32, AccessType.inputOutput, 'ParticleSystem'),
        ('particleLifetime', 5, FieldType.SFFloat, AccessType.inputOutput, 'ParticleSystem'),
        ('particleSize', (0.02, 0.02), FieldType.SFVec2f, AccessType.inputOutput, 'ParticleSystem'),
        ('texCoordKey', [], FieldType.MFFloat, AccessType.initializeOnly, 'ParticleSystem'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DShapeNode'),
        ('appearance', None, FieldType.SFNode, AccessType.inputOutput, 'X3DShapeNode'),
        ('color', None, FieldType.SFNode, AccessType.initializeOnly, 'ParticleSystem'),
        ('emitter', None, FieldType.SFNode, AccessType.initializeOnly, 'ParticleSystem'),
        ('geometry', None, FieldType.SFNode, AccessType.inputOutput, 'ParticleSystem'),
        ('texCoord', None, FieldType.SFNode, AccessType.initializeOnly, 'ParticleSystem'),
        ('physics', [], FieldType.MFNode, AccessType.initializeOnly, 'ParticleSystem'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        castShadow=True,
        colorKey=None,
        createParticles=True,
        enabled=True,
        geometryType='QUAD',
        lifetimeVariation=0.25,
        maxParticles=200,
        particleLifetime=5,
        particleSize=(0.02, 0.02),
        texCoordKey=None,
        visible=True,
        appearance=None,
        color=None,
        emitter=None,
        geometry=None,
        texCoord=None,
        physics=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ParticleSystem __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.castShadow = castShadow
        self.colorKey = colorKey
        self.createParticles = createParticles
        self.enabled = enabled
        self.geometryType = geometryType
        self.lifetimeVariation = lifetimeVariation
        self.maxParticles = maxParticles
        self.particleLifetime = particleLifetime
        self.particleSize = particleSize
        self.texCoordKey = texCoordKey
        self.visible = visible
        self.appearance = appearance
        self.color = color
        self.emitter = emitter
        self.geometry = geometry
        self.texCoord = texCoord
        self.physics = physics
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def castShadow(self):
        """The castShadow field defines whether this Shape casts shadows as produced by lighting nodes."""
        return self.__castShadow
    @castShadow.setter
    def castShadow(self, castShadow):
        if  castShadow is None:
            castShadow = True  # default
        assertValidSFBool(castShadow)
        self.__castShadow = castShadow
    @property # getter - - - - - - - - - -
    def colorKey(self):
        """[0,+infinity) Array of time intervals in seconds, corresponding to particle lifetime, that are used to interpolate color array values."""
        return self.__colorKey
    @colorKey.setter
    def colorKey(self, colorKey):
        if  colorKey is None:
            colorKey = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(colorKey)
        assertNonNegative('colorKey', colorKey)
        self.__colorKey = colorKey
    @property # getter - - - - - - - - - -
    def createParticles(self):
        """Enables/disables creation of new particles, while any existing particles remain in existence and continue to animate until the end of their lifetimes."""
        return self.__createParticles
    @createParticles.setter
    def createParticles(self, createParticles):
        if  createParticles is None:
            createParticles = True  # default
        assertValidSFBool(createParticles)
        self.__createParticles = createParticles
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def geometryType(self):
        """specifies type of geometry used to represent individual particles."""
        return self.__geometryType
    @geometryType.setter
    def geometryType(self, geometryType):
        if  geometryType is None:
            geometryType = 'QUAD'  # default
        assertValidSFString(geometryType)
        self.__geometryType = geometryType
    @property # getter - - - - - - - - - -
    def lifetimeVariation(self):
        """[0,1) TODO not properly defined in X3D spedification."""
        return self.__lifetimeVariation
    @lifetimeVariation.setter
    def lifetimeVariation(self, lifetimeVariation):
        if  lifetimeVariation is None:
            lifetimeVariation = 0.25  # default
        assertValidSFFloat(lifetimeVariation)
        assertZeroToOne('lifetimeVariation', lifetimeVariation)
        self.__lifetimeVariation = lifetimeVariation
    @property # getter - - - - - - - - - -
    def maxParticles(self):
        """[0,+infinity) Maximum number of particles to be generated at one time (subject to player limitations)."""
        return self.__maxParticles
    @maxParticles.setter
    def maxParticles(self, maxParticles):
        if  maxParticles is None:
            maxParticles = 200  # default
        assertValidSFInt32(maxParticles)
        assertNonNegative('maxParticles', maxParticles)
        self.__maxParticles = maxParticles
    @property # getter - - - - - - - - - -
    def particleLifetime(self):
        """[0,+infinity) TODO not properly defined in X3D spedification."""
        return self.__particleLifetime
    @particleLifetime.setter
    def particleLifetime(self, particleLifetime):
        if  particleLifetime is None:
            particleLifetime = 5  # default
        assertValidSFFloat(particleLifetime)
        assertNonNegative('particleLifetime', particleLifetime)
        self.__particleLifetime = particleLifetime
    @property # getter - - - - - - - - - -
    def particleSize(self):
        """[0,+infinity) particleSize describes width and height dimensions for each particle in length base units (default is meters)."""
        return self.__particleSize
    @particleSize.setter
    def particleSize(self, particleSize):
        if  particleSize is None:
            particleSize = (0.02, 0.02)  # default
        assertValidSFVec2f(particleSize)
        assertNonNegative('particleSize', particleSize)
        self.__particleSize = particleSize
    @property # getter - - - - - - - - - -
    def texCoordKey(self):
        """[0,+infinity) Array of time intervals in seconds, corresponding to particle lifetime, that are used to sequence texCoord array values."""
        return self.__texCoordKey
    @texCoordKey.setter
    def texCoordKey(self, texCoordKey):
        if  texCoordKey is None:
            texCoordKey = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(texCoordKey)
        assertNonNegative('texCoordKey', texCoordKey)
        self.__texCoordKey = texCoordKey
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def appearance(self):
        """[X3DAppearanceNode] The appearance field holds an Appearance node that is used for the geometry."""
        return self.__appearance
    @appearance.setter
    def appearance(self, appearance):
        if  appearance is None:
            appearance = None  # default
        assertValidSFNode(appearance)
        if not appearance is None and not isinstance(appearance,(_X3DAppearanceNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(appearance) + ' does not match required node type (_X3DAppearanceNode,ProtoInstance) and is invalid')
        self.__appearance = appearance
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] The color field contains Color|ColorRGBA nodes as a series of color values to be used at the given colorKey points in time."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None  # default
        assertValidSFNode(color)
        if not color is None and not isinstance(color,(_X3DColorNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not match required node type (_X3DColorNode,ProtoInstance) and is invalid')
        self.__color = color
    @property # getter - - - - - - - - - -
    def emitter(self):
        """[X3DParticleEmitterNode] The emitter field specifies the type of emitter geometry and properties that the particles are given for their initial positions."""
        return self.__emitter
    @emitter.setter
    def emitter(self, emitter):
        if  emitter is None:
            emitter = None  # default
        assertValidSFNode(emitter)
        if not emitter is None and not isinstance(emitter,(_X3DParticleEmitterNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(emitter) + ' does not match required node type (_X3DParticleEmitterNode,ProtoInstance) and is invalid')
        self.__emitter = emitter
    @property # getter - - - - - - - - - -
    def geometry(self):
        """[X3DGeometryNode] Single contained geometry node provides geometry used for each particle when geometryType=GEOMETRY."""
        return self.__geometry
    @geometry.setter
    def geometry(self, geometry):
        if  geometry is None:
            geometry = None  # default
        assertValidSFNode(geometry)
        if not geometry is None and not isinstance(geometry,(_X3DGeometryNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(geometry) + ' does not match required node type (_X3DGeometryNode,ProtoInstance) and is invalid')
        self.__geometry = geometry
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[TextureCoordinate|TextureCoordinateGenerator] texture coordinates of the provided texture(s) in the Appearance node, over time."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None  # default
        assertValidSFNode(texCoord)
        if not texCoord is None and not isinstance(texCoord,(TextureCoordinate,TextureCoordinateGenerator,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not match required node type (TextureCoordinate,TextureCoordinateGenerator,ProtoInstance) and is invalid')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def physics(self):
        """[X3DParticlePhysicsModelNode] After being created, the individual particles are then manipulated according to the physics model(s) specified in the physics field."""
        return self.__physics
    @physics.setter
    def physics(self, physics):
        if  physics is None:
            physics = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(physics)
        self.__physics = physics
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.appearance or self.color or self.emitter or self.geometry or self.IS or self.metadata or self.texCoord or (len(self.physics) > 0)
    # output function - - - - - - - - - -

class PeriodicWave(_X3DSoundNode):
    """
    PeriodicWave defines a periodic waveform that can be used to shape the output of an Oscillator.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'PeriodicWave'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#PeriodicWave'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PeriodicWave'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSoundNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundNode'),
        ('optionsImag', [], FieldType.MFFloat, AccessType.inputOutput, 'PeriodicWave'),
        ('optionsReal', [], FieldType.MFFloat, AccessType.inputOutput, 'PeriodicWave'),
        ('type', 'SQUARE', FieldType.SFString, AccessType.inputOutput, 'PeriodicWave'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        description='',
        enabled=True,
        optionsImag=None,
        optionsReal=None,
        type='SQUARE',
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode PeriodicWave __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.enabled = enabled
        self.optionsImag = optionsImag
        self.optionsReal = optionsReal
        self.type = type
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def optionsImag(self):
        """imaginary coefficients for defining a waveform."""
        return self.__optionsImag
    @optionsImag.setter
    def optionsImag(self, optionsImag):
        if  optionsImag is None:
            optionsImag = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(optionsImag)
        self.__optionsImag = optionsImag
    @property # getter - - - - - - - - - -
    def optionsReal(self):
        """real coefficients for defining a waveform."""
        return self.__optionsReal
    @optionsReal.setter
    def optionsReal(self, optionsReal):
        if  optionsReal is None:
            optionsReal = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(optionsReal)
        self.__optionsReal = optionsReal
    @property # getter - - - - - - - - - -
    def type(self):
        """The type field specifies shape of waveform to play, which can be one of several provided values or else 'custom' to indicate that real and imaginary coefficient arrays define a custom waveform."""
        return self.__type
    @type.setter
    def type(self, type):
        if  type is None:
            type = 'SQUARE'  # default
        assertValidSFString(type)
        assertValidPeriodicWaveType('type', type)
        self.__type = type
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class PhysicalMaterial(_X3DOneSidedMaterialNode):
    """
    PhysicalMaterial specifies surface rendering properties for associated geometry nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'PhysicalMaterial'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#PhysicalMaterial'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PhysicalMaterial'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('baseColor', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'PhysicalMaterial'),
        ('baseTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'PhysicalMaterial'),
        ('emissiveColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput, 'PhysicalMaterial'),
        ('emissiveTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
        ('metallic', 1, FieldType.SFFloat, AccessType.inputOutput, 'PhysicalMaterial'),
        ('metallicRoughnessTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'PhysicalMaterial'),
        ('normalScale', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
        ('normalTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
        ('occlusionStrength', 1, FieldType.SFFloat, AccessType.inputOutput, 'PhysicalMaterial'),
        ('occlusionTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'PhysicalMaterial'),
        ('roughness', 1, FieldType.SFFloat, AccessType.inputOutput, 'PhysicalMaterial'),
        ('transparency', 0, FieldType.SFFloat, AccessType.inputOutput, 'PhysicalMaterial'),
        ('baseTexture', None, FieldType.SFNode, AccessType.inputOutput, 'PhysicalMaterial'),
        ('emissiveTexture', None, FieldType.SFNode, AccessType.inputOutput, 'PhysicalMaterial'),
        ('metallicRoughnessTexture', None, FieldType.SFNode, AccessType.inputOutput, 'PhysicalMaterial'),
        ('normalTexture', None, FieldType.SFNode, AccessType.inputOutput, 'PhysicalMaterial'),
        ('occlusionTexture', None, FieldType.SFNode, AccessType.inputOutput, 'PhysicalMaterial'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        baseColor=(1, 1, 1),
        baseTextureMapping='',
        emissiveColor=(0, 0, 0),
        emissiveTextureMapping='',
        metallic=1,
        metallicRoughnessTextureMapping='',
        normalScale=1,
        normalTextureMapping='',
        occlusionStrength=1,
        occlusionTextureMapping='',
        roughness=1,
        transparency=0,
        baseTexture=None,
        emissiveTexture=None,
        metallicRoughnessTexture=None,
        normalTexture=None,
        occlusionTexture=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode PhysicalMaterial __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.baseColor = baseColor
        self.baseTextureMapping = baseTextureMapping
        self.emissiveColor = emissiveColor
        self.emissiveTextureMapping = emissiveTextureMapping
        self.metallic = metallic
        self.metallicRoughnessTextureMapping = metallicRoughnessTextureMapping
        self.normalScale = normalScale
        self.normalTextureMapping = normalTextureMapping
        self.occlusionStrength = occlusionStrength
        self.occlusionTextureMapping = occlusionTextureMapping
        self.roughness = roughness
        self.transparency = transparency
        self.baseTexture = baseTexture
        self.emissiveTexture = emissiveTexture
        self.metallicRoughnessTexture = metallicRoughnessTexture
        self.normalTexture = normalTexture
        self.occlusionTexture = occlusionTexture
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def baseColor(self):
        """[0,1] similar to diffuseColor, TODO define more precisely."""
        return self.__baseColor
    @baseColor.setter
    def baseColor(self, baseColor):
        if  baseColor is None:
            baseColor = (1, 1, 1)  # default
        assertValidSFColor(baseColor)
        assertZeroToOne('baseColor', baseColor)
        self.__baseColor = baseColor
    @property # getter - - - - - - - - - -
    def baseTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__baseTextureMapping
    @baseTextureMapping.setter
    def baseTextureMapping(self, baseTextureMapping):
        if  baseTextureMapping is None:
            baseTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(baseTextureMapping)
        self.__baseTextureMapping = baseTextureMapping
    @property # getter - - - - - - - - - -
    def emissiveColor(self):
        """[0,1] how much glowing light is emitted from this object."""
        return self.__emissiveColor
    @emissiveColor.setter
    def emissiveColor(self, emissiveColor):
        if  emissiveColor is None:
            emissiveColor = (0, 0, 0)  # default
        assertValidSFColor(emissiveColor)
        assertZeroToOne('emissiveColor', emissiveColor)
        self.__emissiveColor = emissiveColor
    @property # getter - - - - - - - - - -
    def emissiveTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__emissiveTextureMapping
    @emissiveTextureMapping.setter
    def emissiveTextureMapping(self, emissiveTextureMapping):
        if  emissiveTextureMapping is None:
            emissiveTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(emissiveTextureMapping)
        self.__emissiveTextureMapping = emissiveTextureMapping
    @property # getter - - - - - - - - - -
    def metallic(self):
        """[0,1] metallic is a PBR parameter (TODO elaborate)."""
        return self.__metallic
    @metallic.setter
    def metallic(self, metallic):
        if  metallic is None:
            metallic = 1  # default
        assertValidSFFloat(metallic)
        assertZeroToOne('metallic', metallic)
        self.__metallic = metallic
    @property # getter - - - - - - - - - -
    def metallicRoughnessTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__metallicRoughnessTextureMapping
    @metallicRoughnessTextureMapping.setter
    def metallicRoughnessTextureMapping(self, metallicRoughnessTextureMapping):
        if  metallicRoughnessTextureMapping is None:
            metallicRoughnessTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(metallicRoughnessTextureMapping)
        self.__metallicRoughnessTextureMapping = metallicRoughnessTextureMapping
    @property # getter - - - - - - - - - -
    def normalScale(self):
        """[0,infinity] normalScale controls the degree to which normalTexture RGB values apply XYZ-normal bump mapping to pixels in the parent material."""
        return self.__normalScale
    @normalScale.setter
    def normalScale(self, normalScale):
        if  normalScale is None:
            normalScale = 1  # default
        assertValidSFFloat(normalScale)
        assertNonNegative('normalScale', normalScale)
        self.__normalScale = normalScale
    @property # getter - - - - - - - - - -
    def normalTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__normalTextureMapping
    @normalTextureMapping.setter
    def normalTextureMapping(self, normalTextureMapping):
        if  normalTextureMapping is None:
            normalTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(normalTextureMapping)
        self.__normalTextureMapping = normalTextureMapping
    @property # getter - - - - - - - - - -
    def occlusionStrength(self):
        """[0,1] occlusionStrength indicates areas of indirect lighting, typically called ambient occlusion."""
        return self.__occlusionStrength
    @occlusionStrength.setter
    def occlusionStrength(self, occlusionStrength):
        if  occlusionStrength is None:
            occlusionStrength = 1  # default
        assertValidSFFloat(occlusionStrength)
        assertZeroToOne('occlusionStrength', occlusionStrength)
        self.__occlusionStrength = occlusionStrength
    @property # getter - - - - - - - - - -
    def occlusionTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__occlusionTextureMapping
    @occlusionTextureMapping.setter
    def occlusionTextureMapping(self, occlusionTextureMapping):
        if  occlusionTextureMapping is None:
            occlusionTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(occlusionTextureMapping)
        self.__occlusionTextureMapping = occlusionTextureMapping
    @property # getter - - - - - - - - - -
    def roughness(self):
        """[0,1] roughness is a PBR parameter (TODO elaborate)."""
        return self.__roughness
    @roughness.setter
    def roughness(self, roughness):
        if  roughness is None:
            roughness = 1  # default
        assertValidSFFloat(roughness)
        assertZeroToOne('roughness', roughness)
        self.__roughness = roughness
    @property # getter - - - - - - - - - -
    def transparency(self):
        """[0,1] how "clear" an object is: 1."""
        return self.__transparency
    @transparency.setter
    def transparency(self, transparency):
        if  transparency is None:
            transparency = 0  # default
        assertValidSFFloat(transparency)
        assertZeroToOne('transparency', transparency)
        self.__transparency = transparency
    @property # getter - - - - - - - - - -
    def baseTexture(self):
        """[X3DSingleTextureNode] When applying baseColor for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__baseTexture
    @baseTexture.setter
    def baseTexture(self, baseTexture):
        if  baseTexture is None:
            baseTexture = None  # default
        assertValidSFNode(baseTexture)
        if not baseTexture is None and not isinstance(baseTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(baseTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__baseTexture = baseTexture
    @property # getter - - - - - - - - - -
    def emissiveTexture(self):
        """[X3DSingleTextureNode] When applying emissiveColor for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__emissiveTexture
    @emissiveTexture.setter
    def emissiveTexture(self, emissiveTexture):
        if  emissiveTexture is None:
            emissiveTexture = None  # default
        assertValidSFNode(emissiveTexture)
        if not emissiveTexture is None and not isinstance(emissiveTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(emissiveTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__emissiveTexture = emissiveTexture
    @property # getter - - - - - - - - - -
    def metallicRoughnessTexture(self):
        """[X3DSingleTextureNode] When applying metallic for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__metallicRoughnessTexture
    @metallicRoughnessTexture.setter
    def metallicRoughnessTexture(self, metallicRoughnessTexture):
        if  metallicRoughnessTexture is None:
            metallicRoughnessTexture = None  # default
        assertValidSFNode(metallicRoughnessTexture)
        if not metallicRoughnessTexture is None and not isinstance(metallicRoughnessTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(metallicRoughnessTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__metallicRoughnessTexture = metallicRoughnessTexture
    @property # getter - - - - - - - - - -
    def normalTexture(self):
        """[X3DSingleTextureNode] When applying normalScale for this material node, the contained texture modulates the texture across the surface."""
        return self.__normalTexture
    @normalTexture.setter
    def normalTexture(self, normalTexture):
        if  normalTexture is None:
            normalTexture = None  # default
        assertValidSFNode(normalTexture)
        if not normalTexture is None and not isinstance(normalTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(normalTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__normalTexture = normalTexture
    @property # getter - - - - - - - - - -
    def occlusionTexture(self):
        """[X3DSingleTextureNode] When applying occlusionStrength for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__occlusionTexture
    @occlusionTexture.setter
    def occlusionTexture(self, occlusionTexture):
        if  occlusionTexture is None:
            occlusionTexture = None  # default
        assertValidSFNode(occlusionTexture)
        if not occlusionTexture is None and not isinstance(occlusionTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(occlusionTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__occlusionTexture = occlusionTexture
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.baseTexture or self.emissiveTexture or self.IS or self.metadata or self.metallicRoughnessTexture or self.normalTexture or self.occlusionTexture
    # output function - - - - - - - - - -

class PickableGroup(_X3DGroupingNode, _X3DPickableObject):
    """
    PickableGroup is a Grouping node that can contain most nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'PickableGroup'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/picking.html#PickableGroup'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PickableGroup'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'PickableGroup'),
        ('objectType', ["ALL"], FieldType.MFString, AccessType.inputOutput, 'X3DPickableObject'),
        ('pickable', True, FieldType.SFBool, AccessType.inputOutput, 'X3DPickableObject'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        description='',
        objectType=None,
        pickable=True,
        visible=True,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode PickableGroup __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.description = description
        self.objectType = objectType
        self.pickable = pickable
        self.visible = visible
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def objectType(self):
        """The objectType field specifies a set of labels used in the picking process."""
        return self.__objectType
    @objectType.setter
    def objectType(self, objectType):
        if  objectType is None:
            objectType = ["ALL"]  # default
        assertValidMFString(objectType)
        self.__objectType = objectType
    @property # getter - - - - - - - - - -
    def pickable(self):
        """The pickable field determines whether pick traversal is performed on this node or its children."""
        return self.__pickable
    @pickable.setter
    def pickable(self, pickable):
        if  pickable is None:
            pickable = True  # default
        assertValidSFBool(pickable)
        self.__pickable = pickable
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class PixelTexture(_X3DTexture2DNode):
    """
    PixelTexture creates a 2D-image texture map using a numeric array of pixel values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'PixelTexture'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#PixelTexture'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PixelTexture'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureNode'),
        ('image', [0, 0, 0], FieldType.SFImage, AccessType.inputOutput, 'PixelTexture'),
        ('repeatS', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture2DNode'),
        ('repeatT', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture2DNode'),
        ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly, 'X3DTexture2DNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        description='',
        image=[0, 0, 0],
        repeatS=True,
        repeatT=True,
        textureProperties=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode PixelTexture __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.image = image
        self.repeatS = repeatS
        self.repeatT = repeatT
        self.textureProperties = textureProperties
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def image(self):
        """Defines image: width, height, number_of_components per each pixel value, and list of pixel_values."""
        return self.__image
    @image.setter
    def image(self, image):
        if  image is None:
            image = [0, 0, 0]  # default
        assertValidSFImage(image)
        self.__image = image
    @property # getter - - - - - - - - - -
    def repeatS(self):
        """Whether to repeat texture along S axis horizontally from left to right."""
        return self.__repeatS
    @repeatS.setter
    def repeatS(self, repeatS):
        if  repeatS is None:
            repeatS = True  # default
        assertValidSFBool(repeatS)
        self.__repeatS = repeatS
    @property # getter - - - - - - - - - -
    def repeatT(self):
        """Whether to repeat texture along T axis vertically from top to bottom."""
        return self.__repeatT
    @repeatT.setter
    def repeatT(self, repeatT):
        if  repeatT is None:
            repeatT = True  # default
        assertValidSFBool(repeatT)
        self.__repeatT = repeatT
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        """[TextureProperties] Single contained TextureProperties node that can specify additional visual attributes applied to corresponding texture images."""
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties):
        if  textureProperties is None:
            textureProperties = None  # default
        assertValidSFNode(textureProperties)
        if not textureProperties is None and not isinstance(textureProperties,(TextureProperties,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(textureProperties) + ' does not match required node type (TextureProperties,ProtoInstance) and is invalid')
        self.__textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.textureProperties
    # output function - - - - - - - - - -

class PixelTexture3D(_X3DTexture3DNode):
    """
    PixelTexture3D defines a 3D image-based texture map as an explicit array of pixel values (image field).
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'PixelTexture3D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texture3D.html#PixelTexture3D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PixelTexture3D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureNode'),
        ('image', [0, 0, 0, 0], FieldType.MFInt32, AccessType.inputOutput, 'PixelTexture3D'),
        ('repeatR', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture3DNode'),
        ('repeatS', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture3DNode'),
        ('repeatT', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture3DNode'),
        ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly, 'X3DTexture3DNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        description='',
        image=None,
        repeatR=False,
        repeatS=False,
        repeatT=False,
        textureProperties=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode PixelTexture3D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.image = image
        self.repeatR = repeatR
        self.repeatS = repeatS
        self.repeatT = repeatT
        self.textureProperties = textureProperties
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def image(self):
        """image describes raw data for this 3D texture: number of components to the image [0,4], width, height and depth of the texture, followed by (width x height x depth) pixel values."""
        return self.__image
    @image.setter
    def image(self, image):
        if  image is None:
            image = [0, 0, 0, 0]  # default
        assertValidMFInt32(image)
        self.__image = image
    @property # getter - - - - - - - - - -
    def repeatR(self):
        """Whether to repeat texture along R axis from front to back."""
        return self.__repeatR
    @repeatR.setter
    def repeatR(self, repeatR):
        if  repeatR is None:
            repeatR = False  # default
        assertValidSFBool(repeatR)
        self.__repeatR = repeatR
    @property # getter - - - - - - - - - -
    def repeatS(self):
        """Whether to repeat texture along S axis horizontally from left to right."""
        return self.__repeatS
    @repeatS.setter
    def repeatS(self, repeatS):
        if  repeatS is None:
            repeatS = False  # default
        assertValidSFBool(repeatS)
        self.__repeatS = repeatS
    @property # getter - - - - - - - - - -
    def repeatT(self):
        """Whether to repeat texture along T axis vertically from top to bottom."""
        return self.__repeatT
    @repeatT.setter
    def repeatT(self, repeatT):
        if  repeatT is None:
            repeatT = False  # default
        assertValidSFBool(repeatT)
        self.__repeatT = repeatT
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        """[TextureProperties] Single contained TextureProperties node that can specify additional visual attributes applied to corresponding texture images."""
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties):
        if  textureProperties is None:
            textureProperties = None  # default
        assertValidSFNode(textureProperties)
        if not textureProperties is None and not isinstance(textureProperties,(TextureProperties,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(textureProperties) + ' does not match required node type (TextureProperties,ProtoInstance) and is invalid')
        self.__textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.textureProperties
    # output function - - - - - - - - - -

class PlaneSensor(_X3DDragSensorNode):
    """
    PlaneSensor converts pointing device motion into 2D translation parallel to the local Z=0 plane.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'PlaneSensor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/pointingDeviceSensor.html#PlaneSensor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PlaneSensor'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('autoOffset', True, FieldType.SFBool, AccessType.inputOutput, 'X3DDragSensorNode'),
        ('axisRotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'PlaneSensor'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSensorNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('maxPosition', (-1, -1), FieldType.SFVec2f, AccessType.inputOutput, 'PlaneSensor'),
        ('minPosition', (0, 0), FieldType.SFVec2f, AccessType.inputOutput, 'PlaneSensor'),
        ('offset', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'PlaneSensor'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        autoOffset=True,
        axisRotation=(0, 0, 1, 0),
        description='',
        enabled=True,
        maxPosition=(-1, -1),
        minPosition=(0, 0),
        offset=(0, 0, 0),
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode PlaneSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.autoOffset = autoOffset
        self.axisRotation = axisRotation
        self.description = description
        self.enabled = enabled
        self.maxPosition = maxPosition
        self.minPosition = minPosition
        self.offset = offset
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def autoOffset(self):
        """Determines whether previous offset values are remembered/accumulated."""
        return self.__autoOffset
    @autoOffset.setter
    def autoOffset(self, autoOffset):
        if  autoOffset is None:
            autoOffset = True  # default
        assertValidSFBool(autoOffset)
        self.__autoOffset = autoOffset
    @property # getter - - - - - - - - - -
    def axisRotation(self):
        """axisRotation determines local sensor coordinate system by rotating the local coordinate system."""
        return self.__axisRotation
    @axisRotation.setter
    def axisRotation(self, axisRotation):
        if  axisRotation is None:
            axisRotation = (0, 0, 1, 0)  # default
        assertValidSFRotation(axisRotation)
        self.__axisRotation = axisRotation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def maxPosition(self):
        """minPosition and maxPosition clamp translations to a range of values measured from origin of Z=0 plane default maxPosition < minPosition means no clamping."""
        return self.__maxPosition
    @maxPosition.setter
    def maxPosition(self, maxPosition):
        if  maxPosition is None:
            maxPosition = (-1, -1)  # default
        assertValidSFVec2f(maxPosition)
        self.__maxPosition = maxPosition
    @property # getter - - - - - - - - - -
    def minPosition(self):
        """minPosition and maxPosition clamp translations to a range of values measured from origin of Z=0 plane default maxPosition < minPosition means no clamping."""
        return self.__minPosition
    @minPosition.setter
    def minPosition(self, minPosition):
        if  minPosition is None:
            minPosition = (0, 0)  # default
        assertValidSFVec2f(minPosition)
        self.__minPosition = minPosition
    @property # getter - - - - - - - - - -
    def offset(self):
        """Sends event and remembers last value sensed."""
        return self.__offset
    @offset.setter
    def offset(self, offset):
        if  offset is None:
            offset = (0, 0, 0)  # default
        assertValidSFVec3f(offset)
        self.__offset = offset
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class PointEmitter(_X3DParticleEmitterNode):
    """
    PointEmitter generates particles from a specific point in space using the specified direction and speed.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'PointEmitter'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#PointEmitter'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PointEmitter'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('direction', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'PointEmitter'),
        ('mass', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('on', True, FieldType.SFBool, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('position', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'PointEmitter'),
        ('speed', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('surfaceArea', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('variation', 0.25, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        direction=(0, 1, 0),
        mass=0,
        on=True,
        position=(0, 0, 0),
        speed=0,
        surfaceArea=0,
        variation=0.25,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode PointEmitter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.direction = direction
        self.mass = mass
        self.on = on
        self.position = position
        self.speed = speed
        self.surfaceArea = surfaceArea
        self.variation = variation
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def direction(self):
        """Initial direction from which particles emanate."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (0, 1, 0)  # default
        assertValidSFVec3f(direction)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def mass(self):
        """[0,+infinity) Basic mass of each particle, defined in mass base units (default is kilograms)."""
        return self.__mass
    @mass.setter
    def mass(self, mass):
        if  mass is None:
            mass = 0  # default
        assertValidSFFloat(mass)
        assertNonNegative('mass', mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def on(self):
        """Enables/disables production of particles from this emitter node."""
        return self.__on
    @on.setter
    def on(self, on):
        if  on is None:
            on = True  # default
        assertValidSFBool(on)
        self.__on = on
    @property # getter - - - - - - - - - -
    def position(self):
        """Point from which particles emanate."""
        return self.__position
    @position.setter
    def position(self, position):
        if  position is None:
            position = (0, 0, 0)  # default
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def speed(self):
        """[0,+infinity) Initial linear speed (default is m/s) imparted to all particles along their direction of movement."""
        return self.__speed
    @speed.setter
    def speed(self, speed):
        if  speed is None:
            speed = 0  # default
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def surfaceArea(self):
        """[0,+infinity) Particle surface area in area base units (default is meters squared)."""
        return self.__surfaceArea
    @surfaceArea.setter
    def surfaceArea(self, surfaceArea):
        if  surfaceArea is None:
            surfaceArea = 0  # default
        assertValidSFFloat(surfaceArea)
        assertNonNegative('surfaceArea', surfaceArea)
        self.__surfaceArea = surfaceArea
    @property # getter - - - - - - - - - -
    def variation(self):
        """[0,+infinity) Multiplier for the randomness used to control the range of possible output values."""
        return self.__variation
    @variation.setter
    def variation(self, variation):
        if  variation is None:
            variation = 0.25  # default
        assertValidSFFloat(variation)
        assertNonNegative('variation', variation)
        self.__variation = variation
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class PointLight(_X3DLightNode):
    """
    Linear attenuation may occur at level 2, full support at level 3.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'PointLight'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/lighting.html#PointLight'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PointLight'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('ambientIntensity', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
        ('attenuation', (1, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'PointLight'),
        ('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'X3DLightNode'),
        ('global_', True, FieldType.SFBool, AccessType.inputOutput, 'PointLight'),
        ('intensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
        ('location', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'PointLight'),
        ('on', True, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
        ('radius', 100, FieldType.SFFloat, AccessType.inputOutput, 'PointLight'),
        ('shadowIntensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
        ('shadows', False, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        ambientIntensity=0,
        attenuation=(1, 0, 0),
        color=(1, 1, 1),
        global_=True,
        intensity=1,
        location=(0, 0, 0),
        on=True,
        radius=100,
        shadowIntensity=1,
        shadows=False,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode PointLight __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ambientIntensity = ambientIntensity
        self.attenuation = attenuation
        self.color = color
        self.global_ = global_
        self.intensity = intensity
        self.location = location
        self.on = on
        self.radius = radius
        self.shadowIntensity = shadowIntensity
        self.shadows = shadows
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def ambientIntensity(self):
        """[0,1] Brightness of ambient (nondirectional background) emission from the light."""
        return self.__ambientIntensity
    @ambientIntensity.setter
    def ambientIntensity(self, ambientIntensity):
        if  ambientIntensity is None:
            ambientIntensity = 0  # default
        assertValidSFFloat(ambientIntensity)
        assertZeroToOne('ambientIntensity', ambientIntensity)
        self.__ambientIntensity = ambientIntensity
    @property # getter - - - - - - - - - -
    def attenuation(self):
        """Constant, linear-distance and squared-distance dropoff factors as radial distance increases from the source."""
        return self.__attenuation
    @attenuation.setter
    def attenuation(self, attenuation):
        if  attenuation is None:
            attenuation = (1, 0, 0)  # default
        assertValidSFVec3f(attenuation)
        assertNonNegative('attenuation', attenuation)
        self.__attenuation = attenuation
    @property # getter - - - - - - - - - -
    def color(self):
        """[0,1] color of light, applied to colors of objects."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = (1, 1, 1)  # default
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def global_(self):
        """Global lights illuminate all objects within their volume of lighting influence."""
        return self.__global_
    @global_.setter
    def global_(self, global_):
        if  global_ is None:
            global_ = True  # default
        assertValidSFBool(global_)
        self.__global_ = global_
    @property # getter - - - - - - - - - -
    def intensity(self):
        """[0,+infinity] Brightness of direct emission from the light."""
        return self.__intensity
    @intensity.setter
    def intensity(self, intensity):
        if  intensity is None:
            intensity = 1  # default
        assertValidSFFloat(intensity)
        assertNonNegative('intensity', intensity)
        self.__intensity = intensity
    @property # getter - - - - - - - - - -
    def location(self):
        """Position of light relative to local coordinate system."""
        return self.__location
    @location.setter
    def location(self, location):
        if  location is None:
            location = (0, 0, 0)  # default
        assertValidSFVec3f(location)
        self.__location = location
    @property # getter - - - - - - - - - -
    def on(self):
        """Enables/disables this light source."""
        return self.__on
    @on.setter
    def on(self, on):
        if  on is None:
            on = True  # default
        assertValidSFBool(on)
        self.__on = on
    @property # getter - - - - - - - - - -
    def radius(self):
        """Maximum effective distance of light relative to local light position, affected by ancestor scaling."""
        return self.__radius
    @radius.setter
    def radius(self, radius):
        if  radius is None:
            radius = 100  # default
        assertValidSFFloat(radius)
        assertNonNegative('radius', radius)
        self.__radius = radius
    @property # getter - - - - - - - - - -
    def shadowIntensity(self):
        """[0,1] shadowIntensity field defines how much light is obscured by shapes that cast shadows, ranging from 0 (light not obscured, no visible shadows) to 1 (light completely obscured, full-intensity shadows)."""
        return self.__shadowIntensity
    @shadowIntensity.setter
    def shadowIntensity(self, shadowIntensity):
        if  shadowIntensity is None:
            shadowIntensity = 1  # default
        assertValidSFFloat(shadowIntensity)
        assertZeroToOne('shadowIntensity', shadowIntensity)
        self.__shadowIntensity = shadowIntensity
    @property # getter - - - - - - - - - -
    def shadows(self):
        """shadows field indicates whether or not this light casts a shadow behind illuminated X3DShapeNode geometry."""
        return self.__shadows
    @shadows.setter
    def shadows(self, shadows):
        if  shadows is None:
            shadows = False  # default
        assertValidSFBool(shadows)
        self.__shadows = shadows
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class PointPickSensor(_X3DPickSensorNode):
    """
    PointPickSensor tests one or more pickingGeometry points in space as lying inside the provided pickTarget geometry.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'PointPickSensor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/picking.html#PointPickSensor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PointPickSensor'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSensorNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('intersectionType', 'BOUNDS', FieldType.SFString, AccessType.initializeOnly, 'X3DPickSensorNode'),
        ('matchCriterion', 'MATCH_ANY', FieldType.SFString, AccessType.inputOutput, 'X3DPickSensorNode'),
        ('objectType', ["ALL"], FieldType.MFString, AccessType.inputOutput, 'X3DPickSensorNode'),
        ('sortOrder', 'CLOSEST', FieldType.SFString, AccessType.initializeOnly, 'X3DPickSensorNode'),
        ('pickingGeometry', None, FieldType.SFNode, AccessType.inputOutput, 'X3DPickSensorNode'),
        ('pickTarget', [], FieldType.MFNode, AccessType.inputOutput, 'X3DPickSensorNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        description='',
        enabled=True,
        intersectionType='BOUNDS',
        matchCriterion='MATCH_ANY',
        objectType=None,
        sortOrder='CLOSEST',
        pickingGeometry=None,
        pickTarget=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode PointPickSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.enabled = enabled
        self.intersectionType = intersectionType
        self.matchCriterion = matchCriterion
        self.objectType = objectType
        self.sortOrder = sortOrder
        self.pickingGeometry = pickingGeometry
        self.pickTarget = pickTarget
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def intersectionType(self):
        """intersectionType specifies precision of the collision computation."""
        return self.__intersectionType
    @intersectionType.setter
    def intersectionType(self, intersectionType):
        if  intersectionType is None:
            intersectionType = 'BOUNDS'  # default
        assertValidSFString(intersectionType)
        self.__intersectionType = intersectionType
    @property # getter - - - - - - - - - -
    def matchCriterion(self):
        """defines whether the intersection test (i."""
        return self.__matchCriterion
    @matchCriterion.setter
    def matchCriterion(self, matchCriterion):
        if  matchCriterion is None:
            matchCriterion = 'MATCH_ANY'  # default
        assertValidSFString(matchCriterion)
        assertValidPickSensorMatchCriterion('matchCriterion', matchCriterion)
        self.__matchCriterion = matchCriterion
    @property # getter - - - - - - - - - -
    def objectType(self):
        """The objectType field specifies a set of labels used in the picking process."""
        return self.__objectType
    @objectType.setter
    def objectType(self, objectType):
        if  objectType is None:
            objectType = ["ALL"]  # default
        assertValidMFString(objectType)
        self.__objectType = objectType
    @property # getter - - - - - - - - - -
    def sortOrder(self):
        """The sortOrder field determines the order provided for picked output events."""
        return self.__sortOrder
    @sortOrder.setter
    def sortOrder(self, sortOrder):
        if  sortOrder is None:
            sortOrder = 'CLOSEST'  # default
        assertValidSFString(sortOrder)
        self.__sortOrder = sortOrder
    @property # getter - - - - - - - - - -
    def pickingGeometry(self):
        """[PointSet] pickingGeometry specifies the exact geometry coordinates that are used to perform the intersection testing of the picking operation."""
        return self.__pickingGeometry
    @pickingGeometry.setter
    def pickingGeometry(self, pickingGeometry):
        if  pickingGeometry is None:
            pickingGeometry = None  # default
        assertValidSFNode(pickingGeometry)
        if not pickingGeometry is None and not isinstance(pickingGeometry,(_X3DGeometryNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(pickingGeometry) + ' does not match required node type (_X3DGeometryNode,ProtoInstance) and is invalid')
        self.__pickingGeometry = pickingGeometry
    @property # getter - - - - - - - - - -
    def pickTarget(self):
        """[X3DGroupingNode|X3DShapeNode|Inline] pickTarget specifies the list of nodes against which picking operations are performed."""
        return self.__pickTarget
    @pickTarget.setter
    def pickTarget(self, pickTarget):
        if  pickTarget is None:
            pickTarget = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(pickTarget)
        self.__pickTarget = pickTarget
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.pickingGeometry or (len(self.pickTarget) > 0)
    # output function - - - - - - - - - -

class PointProperties(_X3DAppearanceChildNode):
    """
    PointProperties allows precise fine-grained control over the rendering style of PointSet node points inside the same Shape.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'PointProperties'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://github.com/Web3DConsortium/X3D/blob/master/ISO-IEC19775/ISO-IEC19775-1/ISO-IEC19775-1v4.0/ISO-IEC19775-1v4-WD1/Part01/components/shape.html'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PointProperties'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('attenuation', (1, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'PointProperties'),
        ('pointSizeMaxValue', 1, FieldType.SFFloat, AccessType.inputOutput, 'PointProperties'),
        ('pointSizeMinValue', 1, FieldType.SFFloat, AccessType.inputOutput, 'PointProperties'),
        ('pointSizeScaleFactor', 1, FieldType.SFFloat, AccessType.inputOutput, 'PointProperties'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        attenuation=(1, 0, 0),
        pointSizeMaxValue=1,
        pointSizeMinValue=1,
        pointSizeScaleFactor=1,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode PointProperties __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.attenuation = attenuation
        self.pointSizeMaxValue = pointSizeMaxValue
        self.pointSizeMinValue = pointSizeMinValue
        self.pointSizeScaleFactor = pointSizeScaleFactor
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def attenuation(self):
        """[0,+infinity) attenuation array values [a, b, c] are set to default values if undefined."""
        return self.__attenuation
    @attenuation.setter
    def attenuation(self, attenuation):
        if  attenuation is None:
            attenuation = (1, 0, 0)  # default
        assertValidSFVec3f(attenuation)
        self.__attenuation = attenuation
    @property # getter - - - - - - - - - -
    def pointSizeMaxValue(self):
        """[0,+infinity) pointSizeMaxValue is maximum allowed scaling factor on nominal browser point scaling."""
        return self.__pointSizeMaxValue
    @pointSizeMaxValue.setter
    def pointSizeMaxValue(self, pointSizeMaxValue):
        if  pointSizeMaxValue is None:
            pointSizeMaxValue = 1  # default
        assertValidSFFloat(pointSizeMaxValue)
        assertNonNegative('pointSizeMaxValue', pointSizeMaxValue)
        self.__pointSizeMaxValue = pointSizeMaxValue
    @property # getter - - - - - - - - - -
    def pointSizeMinValue(self):
        """[0,+infinity) pointSizeMinValue is minimum allowed scaling factor on nominal browser point scaling."""
        return self.__pointSizeMinValue
    @pointSizeMinValue.setter
    def pointSizeMinValue(self, pointSizeMinValue):
        if  pointSizeMinValue is None:
            pointSizeMinValue = 1  # default
        assertValidSFFloat(pointSizeMinValue)
        assertNonNegative('pointSizeMinValue', pointSizeMinValue)
        self.__pointSizeMinValue = pointSizeMinValue
    @property # getter - - - - - - - - - -
    def pointSizeScaleFactor(self):
        """[1,+infinity) Nominal rendered point size is a browser-dependent minimum renderable point size, which is then multiplied by an additional pointSizeScaleFactor (which is greater than or equal to 1)."""
        return self.__pointSizeScaleFactor
    @pointSizeScaleFactor.setter
    def pointSizeScaleFactor(self, pointSizeScaleFactor):
        if  pointSizeScaleFactor is None:
            pointSizeScaleFactor = 1  # default
        assertValidSFFloat(pointSizeScaleFactor)
        assertGreaterThanEquals('pointSizeScaleFactor', pointSizeScaleFactor, 1)
        self.__pointSizeScaleFactor = pointSizeScaleFactor
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class PointSet(_X3DGeometryNode):
    """
    PointSet is a node that contains a set of colored 3D points, represented by contained Color|ColorRGBA and Coordinate|CoordinateDouble nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'PointSet'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#PointSet'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PointSet'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('color', None, FieldType.SFNode, AccessType.inputOutput, 'PointSet'),
        ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'PointSet'),
        ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'PointSet'),
        ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'PointSet'),
        ('attrib', [], FieldType.MFNode, AccessType.inputOutput, 'PointSet'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        color=None,
        coord=None,
        fogCoord=None,
        normal=None,
        attrib=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode PointSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.attrib = attrib
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that can specify color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None  # default
        assertValidSFNode(color)
        if not color is None and not isinstance(color,(_X3DColorNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not match required node type (_X3DColorNode,ProtoInstance) and is invalid')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that can specify a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None  # default
        assertValidSFNode(coord)
        if not coord is None and not isinstance(coord,(_X3DCoordinateNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not match required node type (_X3DCoordinateNode,ProtoInstance) and is invalid')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that can specify depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None  # default
        assertValidSFNode(fogCoord)
        if not fogCoord is None and not isinstance(fogCoord,(FogCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not match required node type (FogCoordinate,ProtoInstance) and is invalid')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that can specify perpendicular vectors for corresponding vertices to support rendering computations."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None  # default
        assertValidSFNode(normal)
        if not normal is None and not isinstance(normal,(_X3DNormalNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not match required node type (_X3DNormalNode,ProtoInstance) and is invalid')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that can specify list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(attrib)
        self.__attrib = attrib
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or (len(self.attrib) > 0)
    # output function - - - - - - - - - -

class Polyline2D(_X3DGeometryNode):
    """
    Polyline2D is a geometry node that defines a connected set of vertices in a contiguous set of line segments in X-Y plane.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Polyline2D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry2D.html#Polyline2D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Polyline2D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('lineSegments', [], FieldType.MFVec2f, AccessType.initializeOnly, 'Polyline2D'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        lineSegments=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Polyline2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.lineSegments = lineSegments
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def lineSegments(self):
        """Coordinates of vertices connected into contiguous Polyline2D."""
        return self.__lineSegments
    @lineSegments.setter
    def lineSegments(self, lineSegments):
        if  lineSegments is None:
            lineSegments = MFVec2f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec2f.DEFAULT_VALUE()))
        assertValidMFVec2f(lineSegments)
        self.__lineSegments = lineSegments
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class PolylineEmitter(_X3DParticleEmitterNode):
    """
    PolylineEmitter emits particles along a single polyline.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'PolylineEmitter'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#PolylineEmitter'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PolylineEmitter'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('coordIndex', [-1], FieldType.MFInt32, AccessType.initializeOnly, 'PolylineEmitter'),
        ('direction', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'PolylineEmitter'),
        ('mass', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('on', True, FieldType.SFBool, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('speed', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('surfaceArea', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('variation', 0.25, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'PolylineEmitter'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        coordIndex=None,
        direction=(0, 1, 0),
        mass=0,
        on=True,
        speed=0,
        surfaceArea=0,
        variation=0.25,
        coord=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode PolylineEmitter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.coordIndex = coordIndex
        self.direction = direction
        self.mass = mass
        self.on = on
        self.speed = speed
        self.surfaceArea = surfaceArea
        self.variation = variation
        self.coord = coord
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def coordIndex(self):
        """[-1,+infinity) coordIndex indices are applied to contained Coordinate values in order to define randomly generated initial geometry of the particles."""
        return self.__coordIndex
    @coordIndex.setter
    def coordIndex(self, coordIndex):
        if  coordIndex is None:
            coordIndex = [-1]  # default
        assertValidMFInt32(coordIndex)
        assertGreaterThanEquals('coordIndex', coordIndex, -1)
        self.__coordIndex = coordIndex
    @property # getter - - - - - - - - - -
    def direction(self):
        """Initial direction from which particles emanate."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (0, 1, 0)  # default
        assertValidSFVec3f(direction)
        assertGreaterThanEquals('direction', direction, -1)
        assertLessThanEquals('direction', direction, 1)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def mass(self):
        """[0,+infinity) Basic mass of each particle, defined in mass base units (default is kilograms)."""
        return self.__mass
    @mass.setter
    def mass(self, mass):
        if  mass is None:
            mass = 0  # default
        assertValidSFFloat(mass)
        assertNonNegative('mass', mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def on(self):
        """Enables/disables production of particles from this emitter node."""
        return self.__on
    @on.setter
    def on(self, on):
        if  on is None:
            on = True  # default
        assertValidSFBool(on)
        self.__on = on
    @property # getter - - - - - - - - - -
    def speed(self):
        """[0,+infinity) Initial linear speed (default is m/s) imparted to all particles along their direction of movement."""
        return self.__speed
    @speed.setter
    def speed(self, speed):
        if  speed is None:
            speed = 0  # default
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def surfaceArea(self):
        """[0,+infinity) Particle surface area in area base units (default is meters squared)."""
        return self.__surfaceArea
    @surfaceArea.setter
    def surfaceArea(self, surfaceArea):
        if  surfaceArea is None:
            surfaceArea = 0  # default
        assertValidSFFloat(surfaceArea)
        assertNonNegative('surfaceArea', surfaceArea)
        self.__surfaceArea = surfaceArea
    @property # getter - - - - - - - - - -
    def variation(self):
        """[0,+infinity) Multiplier for the randomness used to control the range of possible output values."""
        return self.__variation
    @variation.setter
    def variation(self, variation):
        if  variation is None:
            variation = 0.25  # default
        assertValidSFFloat(variation)
        assertNonNegative('variation', variation)
        self.__variation = variation
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Coordinates for the line along which particles are randomly generated."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None  # default
        assertValidSFNode(coord)
        if not coord is None and not isinstance(coord,(_X3DCoordinateNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not match required node type (_X3DCoordinateNode,ProtoInstance) and is invalid')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.coord or self.IS or self.metadata
    # output function - - - - - - - - - -

class Polypoint2D(_X3DGeometryNode):
    """
    Polypoint2D is a geometry node that defines a set of 2D points in X-Y plane.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Polypoint2D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry2D.html#Polypoint2D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Polypoint2D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('point', [], FieldType.MFVec2f, AccessType.inputOutput, 'Polypoint2D'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        point=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Polypoint2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.point = point
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def point(self):
        """2D coordinates of vertices."""
        return self.__point
    @point.setter
    def point(self, point):
        if  point is None:
            point = MFVec2f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec2f.DEFAULT_VALUE()))
        assertValidMFVec2f(point)
        self.__point = point
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class PositionChaser(_X3DChaserNode):
    """
    PositionChaser generates a series of position values that progressively change from initial value to destination value.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'PositionChaser'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#PositionChaser'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PositionChaser'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('duration', 1, FieldType.SFTime, AccessType.initializeOnly, 'X3DChaserNode'),
        ('initialDestination', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'PositionChaser'),
        ('initialValue', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'PositionChaser'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        duration=1,
        initialDestination=(0, 0, 0),
        initialValue=(0, 0, 0),
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode PositionChaser __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.duration = duration
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def duration(self):
        """[0,+infinity) duration is the time interval for filter response in seconds."""
        return self.__duration
    @duration.setter
    def duration(self, duration):
        if  duration is None:
            duration = 1  # default
        assertValidSFTime(duration)
        assertNonNegative('duration', duration)
        self.__duration = duration
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = (0, 0, 0)  # default
        assertValidSFVec3f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = (0, 0, 0)  # default
        assertValidSFVec3f(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class PositionChaser2D(_X3DChaserNode):
    """
    PositionChaser2D generates a series of 2D position values that progressively change from initial value to destination value.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'PositionChaser2D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#PositionChaser2D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PositionChaser2D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('duration', 1, FieldType.SFTime, AccessType.initializeOnly, 'X3DChaserNode'),
        ('initialDestination', (0, 0), FieldType.SFVec2f, AccessType.initializeOnly, 'PositionChaser2D'),
        ('initialValue', (0, 0), FieldType.SFVec2f, AccessType.initializeOnly, 'PositionChaser2D'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        duration=1,
        initialDestination=(0, 0),
        initialValue=(0, 0),
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode PositionChaser2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.duration = duration
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def duration(self):
        """[0,+infinity) duration is the time interval for filter response in seconds."""
        return self.__duration
    @duration.setter
    def duration(self, duration):
        if  duration is None:
            duration = 1  # default
        assertValidSFTime(duration)
        assertNonNegative('duration', duration)
        self.__duration = duration
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = (0, 0)  # default
        assertValidSFVec2f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = (0, 0)  # default
        assertValidSFVec2f(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class PositionDamper(_X3DDamperNode):
    """
    PositionDamper generates a series of position values that progressively change from initial value to destination value.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'PositionDamper'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#PositionDamper'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PositionDamper'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('initialDestination', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'PositionDamper'),
        ('initialValue', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'PositionDamper'),
        ('order', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DDamperNode'),
        ('tau', 0.3, FieldType.SFTime, AccessType.inputOutput, 'X3DDamperNode'),
        ('tolerance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DDamperNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        initialDestination=(0, 0, 0),
        initialValue=(0, 0, 0),
        order=3,
        tau=0.3,
        tolerance=-1,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode PositionDamper __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.order = order
        self.tau = tau
        self.tolerance = tolerance
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = (0, 0, 0)  # default
        assertValidSFVec3f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = (0, 0, 0)  # default
        assertValidSFVec3f(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def order(self):
        """[0,5] order defines the number of internal filters (larger means smoother response, longer delay)."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3  # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 0)
        assertLessThanEquals('order', order, 5)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tau(self):
        """[0,+infinity) tau is the exponential-decay time constant for filter response in seconds."""
        return self.__tau
    @tau.setter
    def tau(self, tau):
        if  tau is None:
            tau = 0.3  # default
        assertValidSFTime(tau)
        assertNonNegative('tau', tau)
        self.__tau = tau
    @property # getter - - - - - - - - - -
    def tolerance(self):
        """[0,+infinity) or -1."""
        return self.__tolerance
    @tolerance.setter
    def tolerance(self, tolerance):
        if  tolerance is None:
            tolerance = -1  # default
        assertValidSFFloat(tolerance)
        self.__tolerance = tolerance
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class PositionDamper2D(_X3DDamperNode):
    """
    PositionDamper2D generates a series of 2D floating-point values that progressively change from initial value to destination value.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'PositionDamper2D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#PositionDamper2D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PositionDamper2D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('initialDestination', (0, 0), FieldType.SFVec2f, AccessType.initializeOnly, 'PositionDamper2D'),
        ('initialValue', (0, 0), FieldType.SFVec2f, AccessType.initializeOnly, 'PositionDamper2D'),
        ('order', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DDamperNode'),
        ('tau', 0.3, FieldType.SFTime, AccessType.inputOutput, 'X3DDamperNode'),
        ('tolerance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DDamperNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        initialDestination=(0, 0),
        initialValue=(0, 0),
        order=3,
        tau=0.3,
        tolerance=-1,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode PositionDamper2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.order = order
        self.tau = tau
        self.tolerance = tolerance
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = (0, 0)  # default
        assertValidSFVec2f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = (0, 0)  # default
        assertValidSFVec2f(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def order(self):
        """[0,5] order defines the number of internal filters (larger means smoother response, longer delay)."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3  # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 0)
        assertLessThanEquals('order', order, 5)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tau(self):
        """[0,+infinity) tau is the exponential-decay time constant for filter response in seconds."""
        return self.__tau
    @tau.setter
    def tau(self, tau):
        if  tau is None:
            tau = 0.3  # default
        assertValidSFTime(tau)
        assertNonNegative('tau', tau)
        self.__tau = tau
    @property # getter - - - - - - - - - -
    def tolerance(self):
        """[0,+infinity) or -1."""
        return self.__tolerance
    @tolerance.setter
    def tolerance(self, tolerance):
        if  tolerance is None:
            tolerance = -1  # default
        assertValidSFFloat(tolerance)
        self.__tolerance = tolerance
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class PositionInterpolator(_X3DInterpolatorNode):
    """
    PositionInterpolator generates a series of 3-tuple SFVec3f values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'PositionInterpolator'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#PositionInterpolator'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PositionInterpolator'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('key', [], FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
        ('keyValue', [], FieldType.MFVec3f, AccessType.inputOutput, 'PositionInterpolator'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        key=None,
        keyValue=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode PositionInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFVec3f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec3f.DEFAULT_VALUE()))
        assertValidMFVec3f(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class PositionInterpolator2D(_X3DInterpolatorNode):
    """
    PositionInterpolator2D generates a series of SFVec2f values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'PositionInterpolator2D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#PositionInterpolator2D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PositionInterpolator2D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('key', [], FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
        ('keyValue', [], FieldType.MFVec2f, AccessType.inputOutput, 'PositionInterpolator2D'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        key=None,
        keyValue=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode PositionInterpolator2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFVec2f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec2f.DEFAULT_VALUE()))
        assertValidMFVec2f(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class PrimitivePickSensor(_X3DPickSensorNode):
    """
    If a non-uniform scale is applied to the pick sensor, correct results may require level 3 support.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'PrimitivePickSensor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/picking.html#PrimitivePickSensor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PrimitivePickSensor'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSensorNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('intersectionType', 'BOUNDS', FieldType.SFString, AccessType.initializeOnly, 'X3DPickSensorNode'),
        ('matchCriterion', 'MATCH_ANY', FieldType.SFString, AccessType.inputOutput, 'X3DPickSensorNode'),
        ('objectType', ["ALL"], FieldType.MFString, AccessType.inputOutput, 'X3DPickSensorNode'),
        ('sortOrder', 'CLOSEST', FieldType.SFString, AccessType.initializeOnly, 'X3DPickSensorNode'),
        ('pickingGeometry', None, FieldType.SFNode, AccessType.inputOutput, 'X3DPickSensorNode'),
        ('pickTarget', [], FieldType.MFNode, AccessType.inputOutput, 'X3DPickSensorNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        description='',
        enabled=True,
        intersectionType='BOUNDS',
        matchCriterion='MATCH_ANY',
        objectType=None,
        sortOrder='CLOSEST',
        pickingGeometry=None,
        pickTarget=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode PrimitivePickSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.enabled = enabled
        self.intersectionType = intersectionType
        self.matchCriterion = matchCriterion
        self.objectType = objectType
        self.sortOrder = sortOrder
        self.pickingGeometry = pickingGeometry
        self.pickTarget = pickTarget
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def intersectionType(self):
        """intersectionType specifies precision of the collision computation."""
        return self.__intersectionType
    @intersectionType.setter
    def intersectionType(self, intersectionType):
        if  intersectionType is None:
            intersectionType = 'BOUNDS'  # default
        assertValidSFString(intersectionType)
        self.__intersectionType = intersectionType
    @property # getter - - - - - - - - - -
    def matchCriterion(self):
        """defines whether the intersection test (i."""
        return self.__matchCriterion
    @matchCriterion.setter
    def matchCriterion(self, matchCriterion):
        if  matchCriterion is None:
            matchCriterion = 'MATCH_ANY'  # default
        assertValidSFString(matchCriterion)
        assertValidPickSensorMatchCriterion('matchCriterion', matchCriterion)
        self.__matchCriterion = matchCriterion
    @property # getter - - - - - - - - - -
    def objectType(self):
        """The objectType field specifies a set of labels used in the picking process."""
        return self.__objectType
    @objectType.setter
    def objectType(self, objectType):
        if  objectType is None:
            objectType = ["ALL"]  # default
        assertValidMFString(objectType)
        self.__objectType = objectType
    @property # getter - - - - - - - - - -
    def sortOrder(self):
        """The sortOrder field determines the order provided for picked output events."""
        return self.__sortOrder
    @sortOrder.setter
    def sortOrder(self, sortOrder):
        if  sortOrder is None:
            sortOrder = 'CLOSEST'  # default
        assertValidSFString(sortOrder)
        self.__sortOrder = sortOrder
    @property # getter - - - - - - - - - -
    def pickingGeometry(self):
        """[Cone|Cylinder|Sphere|Box] pickingGeometry specifies the exact geometry coordinates that are used to perform the intersection testing of the picking operation."""
        return self.__pickingGeometry
    @pickingGeometry.setter
    def pickingGeometry(self, pickingGeometry):
        if  pickingGeometry is None:
            pickingGeometry = None  # default
        assertValidSFNode(pickingGeometry)
        if not pickingGeometry is None and not isinstance(pickingGeometry,(_X3DGeometryNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(pickingGeometry) + ' does not match required node type (_X3DGeometryNode,ProtoInstance) and is invalid')
        self.__pickingGeometry = pickingGeometry
    @property # getter - - - - - - - - - -
    def pickTarget(self):
        """[X3DGroupingNode|X3DShapeNode|Inline] pickTarget specifies the list of nodes against which picking operations are performed."""
        return self.__pickTarget
    @pickTarget.setter
    def pickTarget(self, pickTarget):
        if  pickTarget is None:
            pickTarget = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(pickTarget)
        self.__pickTarget = pickTarget
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.pickingGeometry or (len(self.pickTarget) > 0)
    # output function - - - - - - - - - -

class ProgramShader(_X3DShaderNode):  #   # TODO fix additional inheritance method resolution order (MRO)
    """
    ProgramShader contains no field declarations and no plain-text source code.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ProgramShader'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shaders.html#ProgramShader'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProgramShader'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('language', '', FieldType.SFString, AccessType.initializeOnly, 'X3DShaderNode'),
        ('programs', [], FieldType.MFNode, AccessType.inputOutput, 'ProgramShader'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        language='',
        programs=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ProgramShader __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.language = language
        self.programs = programs
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def language(self):
        """The language field indicates to the X3D player which shading language is used."""
        return self.__language
    @language.setter
    def language(self, language):
        if  language is None:
            language = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(language)
        self.__language = language
    @property # getter - - - - - - - - - -
    def programs(self):
        """[ShaderProgram] ProgramShader contains zero or more ShaderProgram node instances."""
        return self.__programs
    @programs.setter
    def programs(self, programs):
        if  programs is None:
            programs = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(programs)
        self.__programs = programs
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.programs) > 0)
    # output function - - - - - - - - - -

class ProjectionVolumeStyle(_X3DVolumeRenderStyleNode):
    """
    ProjectionVolumeStyle uses voxel data to directly generate output color.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ProjectionVolumeStyle'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#ProjectionVolumeStyle'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProjectionVolumeStyle'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeRenderStyleNode'),
        ('intensityThreshold', 0, FieldType.SFFloat, AccessType.inputOutput, 'ProjectionVolumeStyle'),
        ('type', 'MAX', FieldType.SFString, AccessType.inputOutput, 'ProjectionVolumeStyle'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        enabled=True,
        intensityThreshold=0,
        type='MAX',
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ProjectionVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.intensityThreshold = intensityThreshold
        self.type = type
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def intensityThreshold(self):
        """[0,1] Threshold value used when type=MIN (LMIP) or type=MAX (MIP)."""
        return self.__intensityThreshold
    @intensityThreshold.setter
    def intensityThreshold(self, intensityThreshold):
        if  intensityThreshold is None:
            intensityThreshold = 0  # default
        assertValidSFFloat(intensityThreshold)
        assertZeroToOne('intensityThreshold', intensityThreshold)
        self.__intensityThreshold = intensityThreshold
    @property # getter - - - - - - - - - -
    def type(self):
        """If type=MAX then Maximum Intensity Projection (MIP) or Least MIP (LMIP) algorithm is used to generate output color."""
        return self.__type
    @type.setter
    def type(self, type):
        if  type is None:
            type = 'MAX'  # default
        assertValidSFString(type)
        assertValidProjectionVolumeStyleType('type', type)
        self.__type = type
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class ProtoInstance(_X3DPrototypeInstance, _X3DChildNode):
    """
    ProtoInstance can override field default values via fieldValue initializations. Non-recursive nested ProtoInstance and ProtoDeclare statements are allowed within a ProtoDeclare.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ProtoInstance'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#ProtoInstanceAndFieldValueStatement'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProtoInstance'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('name', '', FieldType.SFString, AccessType.inputOutput, 'ProtoInstance'),
        ('fieldValue', [], FieldType.MFNode, AccessType.inputOutput, 'ProtoInstance'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        name='',
        fieldValue=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ProtoInstance __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.fieldValue = fieldValue
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def name(self):
        """name of the prototype node being instanced."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def fieldValue(self):
        """Include fieldValue statements if this ProtoInstance overrides default values in any of the original field declarations."""
        return self.__fieldValue
    @fieldValue.setter
    def fieldValue(self, fieldValue):
        if  fieldValue is None:
            fieldValue = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        # TODO type-aware checks for fieldValue
        if fieldValue: # walk each child in list, if any (avoid empty list recursion)
            for each in fieldValue:
                assertValidFieldInitializationValue(each.name, type(each.value), each.value, parent='fieldValue')
        self.__fieldValue = fieldValue
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.fieldValue) > 0)
    # output function - - - - - - - - - -

class ProximitySensor(_X3DEnvironmentalSensorNode):
    """
    ProximitySensor generates events when the viewer enters, exits and moves within a region of space (defined by a box).
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ProximitySensor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalSensor.html#ProximitySensor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProximitySensor'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'ProximitySensor'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSensorNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('size', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'X3DEnvironmentalSensorNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        center=(0, 0, 0),
        description='',
        enabled=True,
        size=(0, 0, 0),
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ProximitySensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.center = center
        self.description = description
        self.enabled = enabled
        self.size = size
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def center(self):
        """Position offset from origin of local coordinate system."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0)  # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def size(self):
        """[0,+infinity) size of Proximity box around center location, oriented within local transformation frame."""
        return self.__size
    @size.setter
    def size(self, size):
        if  size is None:
            size = (0, 0, 0)  # default
        assertValidSFVec3f(size)
        assertNonNegative('size', size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class QuadSet(_X3DComposedGeometryNode):
    """
    QuadSet is a geometry node that defines quadrilaterals.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'QuadSet'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/CADGeometry.html#QuadSet'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#QuadSet'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('color', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('attrib', [], FieldType.MFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        ccw=True,
        colorPerVertex=True,
        normalPerVertex=True,
        solid=True,
        color=None,
        coord=None,
        fogCoord=None,
        normal=None,
        texCoord=None,
        attrib=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode QuadSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True  # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color|ColorRGBA values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True  # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True  # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that can specify color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None  # default
        assertValidSFNode(color)
        if not color is None and not isinstance(color,(_X3DColorNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not match required node type (_X3DColorNode,ProtoInstance) and is invalid')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that can specify a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None  # default
        assertValidSFNode(coord)
        if not coord is None and not isinstance(coord,(_X3DCoordinateNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not match required node type (_X3DCoordinateNode,ProtoInstance) and is invalid')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that can specify depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None  # default
        assertValidSFNode(fogCoord)
        if not fogCoord is None and not isinstance(fogCoord,(FogCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not match required node type (FogCoordinate,ProtoInstance) and is invalid')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that can specify perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None  # default
        assertValidSFNode(normal)
        if not normal is None and not isinstance(normal,(_X3DNormalNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not match required node type (_X3DNormalNode,ProtoInstance) and is invalid')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that can specify coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None  # default
        assertValidSFNode(texCoord)
        if not texCoord is None and not isinstance(texCoord,(_X3DSingleTextureCoordinateNode,MultiTextureCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not match required node type (_X3DSingleTextureCoordinateNode,MultiTextureCoordinate,ProtoInstance) and is invalid')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that can specify list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(attrib)
        self.__attrib = attrib
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or self.texCoord or (len(self.attrib) > 0)
    # output function - - - - - - - - - -

class ReceiverPdu(_X3DNetworkSensorNode, _X3DBoundedObject):
    """
    ReceiverPdu is a networked Protocol Data Unit (PDU) information node that transmits the state of radio frequency (RF) receivers modeled in a simulation.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ReceiverPdu'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/dis.html#ReceiverPdu'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ReceiverPdu'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('address', 'localhost', FieldType.SFString, AccessType.inputOutput, 'ReceiverPdu'),
        ('applicationID', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSensorNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('entityID', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
        ('geoCoords', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput, 'ReceiverPdu'),
        ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'ReceiverPdu'),
        ('multicastRelayHost', '', FieldType.SFString, AccessType.inputOutput, 'ReceiverPdu'),
        ('multicastRelayPort', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
        ('networkMode', 'standAlone', FieldType.SFString, AccessType.inputOutput, 'ReceiverPdu'),
        ('port', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
        ('radioID', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
        ('readInterval', 0.1, FieldType.SFTime, AccessType.inputOutput, 'ReceiverPdu'),
        ('receivedPower', 0.0, FieldType.SFFloat, AccessType.inputOutput, 'ReceiverPdu'),
        ('receiverState', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
        ('rtpHeaderExpected', False, FieldType.SFBool, AccessType.inputOutput, 'ReceiverPdu'),
        ('siteID', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
        ('transmitterApplicationID', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
        ('transmitterEntityID', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
        ('transmitterRadioID', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
        ('transmitterSiteID', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('whichGeometry', 1, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
        ('writeInterval', 1.0, FieldType.SFTime, AccessType.inputOutput, 'ReceiverPdu'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        address='localhost',
        applicationID=0,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        description='',
        enabled=True,
        entityID=0,
        geoCoords=(0, 0, 0),
        geoSystem=None,
        multicastRelayHost='',
        multicastRelayPort=0,
        networkMode='standAlone',
        port=0,
        radioID=0,
        readInterval=0.1,
        receivedPower=0.0,
        receiverState=0,
        rtpHeaderExpected=False,
        siteID=0,
        transmitterApplicationID=0,
        transmitterEntityID=0,
        transmitterRadioID=0,
        transmitterSiteID=0,
        visible=True,
        whichGeometry=1,
        writeInterval=1.0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ReceiverPdu __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.address = address
        self.applicationID = applicationID
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.description = description
        self.enabled = enabled
        self.entityID = entityID
        self.geoCoords = geoCoords
        self.geoSystem = geoSystem
        self.multicastRelayHost = multicastRelayHost
        self.multicastRelayPort = multicastRelayPort
        self.networkMode = networkMode
        self.port = port
        self.radioID = radioID
        self.readInterval = readInterval
        self.receivedPower = receivedPower
        self.receiverState = receiverState
        self.rtpHeaderExpected = rtpHeaderExpected
        self.siteID = siteID
        self.transmitterApplicationID = transmitterApplicationID
        self.transmitterEntityID = transmitterEntityID
        self.transmitterRadioID = transmitterRadioID
        self.transmitterSiteID = transmitterSiteID
        self.visible = visible
        self.whichGeometry = whichGeometry
        self.writeInterval = writeInterval
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def address(self):
        """Multicast network address, or else 'localhost'; Example: 224."""
        return self.__address
    @address.setter
    def address(self, address):
        if  address is None:
            address = 'localhost'  # default
        assertValidSFString(address)
        self.__address = address
    @property # getter - - - - - - - - - -
    def applicationID(self):
        """Each simulation application that can respond to simulation management PDUs needs to have a unique applicationID."""
        return self.__applicationID
    @applicationID.setter
    def applicationID(self, applicationID):
        if  applicationID is None:
            applicationID = 0  # default
        assertValidSFInt32(applicationID)
        self.__applicationID = applicationID
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables the sensor node."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def entityID(self):
        """EntityID unique ID for entity within that application."""
        return self.__entityID
    @entityID.setter
    def entityID(self, entityID):
        if  entityID is None:
            entityID = 0  # default
        assertValidSFInt32(entityID)
        self.__entityID = entityID
    @property # getter - - - - - - - - - -
    def geoCoords(self):
        """Geographic location (specified in current geoSystem coordinates) for children geometry (specified in relative coordinate system, in meters)."""
        return self.__geoCoords
    @geoCoords.setter
    def geoCoords(self, geoCoords):
        if  geoCoords is None:
            geoCoords = (0, 0, 0)  # default
        assertValidSFVec3d(geoCoords)
        self.__geoCoords = geoCoords
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"]  # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def multicastRelayHost(self):
        """Fallback server address if multicast not available locally."""
        return self.__multicastRelayHost
    @multicastRelayHost.setter
    def multicastRelayHost(self, multicastRelayHost):
        if  multicastRelayHost is None:
            multicastRelayHost = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(multicastRelayHost)
        self.__multicastRelayHost = multicastRelayHost
    @property # getter - - - - - - - - - -
    def multicastRelayPort(self):
        """Fallback server port if multicast not available locally."""
        return self.__multicastRelayPort
    @multicastRelayPort.setter
    def multicastRelayPort(self, multicastRelayPort):
        if  multicastRelayPort is None:
            multicastRelayPort = 0  # default
        assertValidSFInt32(multicastRelayPort)
        self.__multicastRelayPort = multicastRelayPort
    @property # getter - - - - - - - - - -
    def networkMode(self):
        """Whether this entity is ignoring the network, sending DIS packets to the network, or receiving DIS packets from the network."""
        return self.__networkMode
    @networkMode.setter
    def networkMode(self, networkMode):
        if  networkMode is None:
            networkMode = 'standAlone'  # default
        assertValidSFString(networkMode)
        assertValidNetworkMode('networkMode', networkMode)
        self.__networkMode = networkMode
    @property # getter - - - - - - - - - -
    def port(self):
        """Multicast network port, for example: 3000."""
        return self.__port
    @port.setter
    def port(self, port):
        if  port is None:
            port = 0  # default
        assertValidSFInt32(port)
        self.__port = port
    @property # getter - - - - - - - - - -
    def radioID(self):
        """Identifies a particular radio within a given entity."""
        return self.__radioID
    @radioID.setter
    def radioID(self, radioID):
        if  radioID is None:
            radioID = 0  # default
        assertValidSFInt32(radioID)
        self.__radioID = radioID
    @property # getter - - - - - - - - - -
    def readInterval(self):
        """[0,+infinity) Seconds between read updates, 0 means no reading."""
        return self.__readInterval
    @readInterval.setter
    def readInterval(self, readInterval):
        if  readInterval is None:
            readInterval = 0.1  # default
        assertValidSFTime(readInterval)
        assertNonNegative('readInterval', readInterval)
        self.__readInterval = readInterval
    @property # getter - - - - - - - - - -
    def receivedPower(self):
        """receivedPower indicates radio frequency (RF) power received, in units of decibel-milliwatts (dBm), after applying any propagation loss and antenna gain."""
        return self.__receivedPower
    @receivedPower.setter
    def receivedPower(self, receivedPower):
        if  receivedPower is None:
            receivedPower = 0.0  # default
        assertValidSFFloat(receivedPower)
        self.__receivedPower = receivedPower
    @property # getter - - - - - - - - - -
    def receiverState(self):
        """receiverState indicates if receiver is currently idle or busy via one of these enumerated values: 0 = off, 1 = on but not receiving, or 2 = on and receiving."""
        return self.__receiverState
    @receiverState.setter
    def receiverState(self, receiverState):
        if  receiverState is None:
            receiverState = 0  # default
        assertValidSFInt32(receiverState)
        self.__receiverState = receiverState
    @property # getter - - - - - - - - - -
    def rtpHeaderExpected(self):
        """Whether RTP headers are prepended to DIS PDUs."""
        return self.__rtpHeaderExpected
    @rtpHeaderExpected.setter
    def rtpHeaderExpected(self, rtpHeaderExpected):
        if  rtpHeaderExpected is None:
            rtpHeaderExpected = False  # default
        assertValidSFBool(rtpHeaderExpected)
        self.__rtpHeaderExpected = rtpHeaderExpected
    @property # getter - - - - - - - - - -
    def siteID(self):
        """Simulation/exercise siteID of the participating LAN or organization."""
        return self.__siteID
    @siteID.setter
    def siteID(self, siteID):
        if  siteID is None:
            siteID = 0  # default
        assertValidSFInt32(siteID)
        self.__siteID = siteID
    @property # getter - - - - - - - - - -
    def transmitterApplicationID(self):
        """Simulation/exercise transmitterApplicationID is unique for transmitter application at that site."""
        return self.__transmitterApplicationID
    @transmitterApplicationID.setter
    def transmitterApplicationID(self, transmitterApplicationID):
        if  transmitterApplicationID is None:
            transmitterApplicationID = 0  # default
        assertValidSFInt32(transmitterApplicationID)
        self.__transmitterApplicationID = transmitterApplicationID
    @property # getter - - - - - - - - - -
    def transmitterEntityID(self):
        """Simulation/exercise transmitterEntityID is a unique ID for a single entity within that application."""
        return self.__transmitterEntityID
    @transmitterEntityID.setter
    def transmitterEntityID(self, transmitterEntityID):
        if  transmitterEntityID is None:
            transmitterEntityID = 0  # default
        assertValidSFInt32(transmitterEntityID)
        self.__transmitterEntityID = transmitterEntityID
    @property # getter - - - - - - - - - -
    def transmitterRadioID(self):
        """Identifies a particular radio within a given entity."""
        return self.__transmitterRadioID
    @transmitterRadioID.setter
    def transmitterRadioID(self, transmitterRadioID):
        if  transmitterRadioID is None:
            transmitterRadioID = 0  # default
        assertValidSFInt32(transmitterRadioID)
        self.__transmitterRadioID = transmitterRadioID
    @property # getter - - - - - - - - - -
    def transmitterSiteID(self):
        """Simulation/exercise transmitterSiteID of the participating LAN or organization."""
        return self.__transmitterSiteID
    @transmitterSiteID.setter
    def transmitterSiteID(self, transmitterSiteID):
        if  transmitterSiteID is None:
            transmitterSiteID = 0  # default
        assertValidSFInt32(transmitterSiteID)
        self.__transmitterSiteID = transmitterSiteID
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def whichGeometry(self):
        """Select geometry to render: -1 for no geometry, 0 for text trace, 1 for default geometry, (optional) higher values to render different states."""
        return self.__whichGeometry
    @whichGeometry.setter
    def whichGeometry(self, whichGeometry):
        if  whichGeometry is None:
            whichGeometry = 1  # default
        assertValidSFInt32(whichGeometry)
        self.__whichGeometry = whichGeometry
    @property # getter - - - - - - - - - -
    def writeInterval(self):
        """[0,+infinity) Seconds between write updates, 0 means no writing (sending)."""
        return self.__writeInterval
    @writeInterval.setter
    def writeInterval(self, writeInterval):
        if  writeInterval is None:
            writeInterval = 1.0  # default
        assertValidSFTime(writeInterval)
        assertNonNegative('writeInterval', writeInterval)
        self.__writeInterval = writeInterval
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class Rectangle2D(_X3DGeometryNode):
    """
    Rectangle2D is a geometry node that defines a 2D rectangle in X-Y plane.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Rectangle2D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry2D.html#Rectangle2D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Rectangle2D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('size', (2, 2), FieldType.SFVec2f, AccessType.initializeOnly, 'Rectangle2D'),
        ('solid', False, FieldType.SFBool, AccessType.initializeOnly, 'Rectangle2D'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        size=(2, 2),
        solid=False,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Rectangle2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.size = size
        self.solid = solid
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def size(self):
        """2D dimensions of Rectangle2D."""
        return self.__size
    @size.setter
    def size(self, size):
        if  size is None:
            size = (2, 2)  # default
        assertValidSFVec2f(size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = False  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class RigidBody(_X3DChildNode):  # , _X3DBoundedObject  # TODO fix additional inheritance method resolution order (MRO)
    """
    RigidBody describes a collection of shapes with a mass distribution that is affected by the physics model.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'RigidBody'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#RigidBody'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#RigidBody'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('angularDampingFactor', 0.001, FieldType.SFFloat, AccessType.inputOutput, 'RigidBody'),
        ('angularVelocity', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'RigidBody'),
        ('autoDamp', False, FieldType.SFBool, AccessType.inputOutput, 'RigidBody'),
        ('autoDisable', False, FieldType.SFBool, AccessType.inputOutput, 'RigidBody'),
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('centerOfMass', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'RigidBody'),
        ('disableAngularSpeed', 0, FieldType.SFFloat, AccessType.inputOutput, 'RigidBody'),
        ('disableLinearSpeed', 0, FieldType.SFFloat, AccessType.inputOutput, 'RigidBody'),
        ('disableTime', 0, FieldType.SFTime, AccessType.inputOutput, 'RigidBody'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'RigidBody'),
        ('finiteRotationAxis', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'RigidBody'),
        ('fixed', False, FieldType.SFBool, AccessType.inputOutput, 'RigidBody'),
        ('forces', [], FieldType.MFVec3f, AccessType.inputOutput, 'RigidBody'),
        ('inertia', (1, 0, 0, 0, 1, 0, 0, 0, 1), FieldType.SFMatrix3f, AccessType.inputOutput, 'RigidBody'),
        ('linearDampingFactor', 0.001, FieldType.SFFloat, AccessType.inputOutput, 'RigidBody'),
        ('linearVelocity', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'RigidBody'),
        ('mass', 1, FieldType.SFFloat, AccessType.inputOutput, 'RigidBody'),
        ('orientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'RigidBody'),
        ('position', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'RigidBody'),
        ('torques', [], FieldType.MFVec3f, AccessType.inputOutput, 'RigidBody'),
        ('useFiniteRotation', False, FieldType.SFBool, AccessType.inputOutput, 'RigidBody'),
        ('useGlobalGravity', True, FieldType.SFBool, AccessType.inputOutput, 'RigidBody'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('massDensityModel', None, FieldType.SFNode, AccessType.inputOutput, 'RigidBody'),
        ('geometry', [], FieldType.MFNode, AccessType.inputOutput, 'RigidBody'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        angularDampingFactor=0.001,
        angularVelocity=(0, 0, 0),
        autoDamp=False,
        autoDisable=False,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        centerOfMass=(0, 0, 0),
        disableAngularSpeed=0,
        disableLinearSpeed=0,
        disableTime=0,
        enabled=True,
        finiteRotationAxis=(0, 1, 0),
        fixed=False,
        forces=None,
        inertia=(1, 0, 0, 0, 1, 0, 0, 0, 1),
        linearDampingFactor=0.001,
        linearVelocity=(0, 0, 0),
        mass=1,
        orientation=(0, 0, 1, 0),
        position=(0, 0, 0),
        torques=None,
        useFiniteRotation=False,
        useGlobalGravity=True,
        visible=True,
        massDensityModel=None,
        geometry=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode RigidBody __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.angularDampingFactor = angularDampingFactor
        self.angularVelocity = angularVelocity
        self.autoDamp = autoDamp
        self.autoDisable = autoDisable
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.centerOfMass = centerOfMass
        self.disableAngularSpeed = disableAngularSpeed
        self.disableLinearSpeed = disableLinearSpeed
        self.disableTime = disableTime
        self.enabled = enabled
        self.finiteRotationAxis = finiteRotationAxis
        self.fixed = fixed
        self.forces = forces
        self.inertia = inertia
        self.linearDampingFactor = linearDampingFactor
        self.linearVelocity = linearVelocity
        self.mass = mass
        self.orientation = orientation
        self.position = position
        self.torques = torques
        self.useFiniteRotation = useFiniteRotation
        self.useGlobalGravity = useGlobalGravity
        self.visible = visible
        self.massDensityModel = massDensityModel
        self.geometry = geometry
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def angularDampingFactor(self):
        """[0,1] angularDampingFactor automatically damps a portion of body motion over time."""
        return self.__angularDampingFactor
    @angularDampingFactor.setter
    def angularDampingFactor(self, angularDampingFactor):
        if  angularDampingFactor is None:
            angularDampingFactor = 0.001  # default
        assertValidSFFloat(angularDampingFactor)
        self.__angularDampingFactor = angularDampingFactor
    @property # getter - - - - - - - - - -
    def angularVelocity(self):
        """angularVelocity sets constant velocity value to object every frame, and reports updates by physics model."""
        return self.__angularVelocity
    @angularVelocity.setter
    def angularVelocity(self, angularVelocity):
        if  angularVelocity is None:
            angularVelocity = (0, 0, 0)  # default
        assertValidSFVec3f(angularVelocity)
        self.__angularVelocity = angularVelocity
    @property # getter - - - - - - - - - -
    def autoDamp(self):
        """autoDamp enables/disables angularDampingFactor and linearDampingFactor."""
        return self.__autoDamp
    @autoDamp.setter
    def autoDamp(self, autoDamp):
        if  autoDamp is None:
            autoDamp = False  # default
        assertValidSFBool(autoDamp)
        self.__autoDamp = autoDamp
    @property # getter - - - - - - - - - -
    def autoDisable(self):
        """autoDisable toggles operation of disableAngularSpeed, disableLinearSpeed, disableTime."""
        return self.__autoDisable
    @autoDisable.setter
    def autoDisable(self, autoDisable):
        if  autoDisable is None:
            autoDisable = False  # default
        assertValidSFBool(autoDisable)
        self.__autoDisable = autoDisable
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def centerOfMass(self):
        """centerOfMass defines local center of mass for physics calculations."""
        return self.__centerOfMass
    @centerOfMass.setter
    def centerOfMass(self, centerOfMass):
        if  centerOfMass is None:
            centerOfMass = (0, 0, 0)  # default
        assertValidSFVec3f(centerOfMass)
        self.__centerOfMass = centerOfMass
    @property # getter - - - - - - - - - -
    def disableAngularSpeed(self):
        """[0,+infinity) disableAngularSpeed defines lower-limit tolerance value when body is considered at rest and not part of rigid body calculations, reducing numeric instabilities."""
        return self.__disableAngularSpeed
    @disableAngularSpeed.setter
    def disableAngularSpeed(self, disableAngularSpeed):
        if  disableAngularSpeed is None:
            disableAngularSpeed = 0  # default
        assertValidSFFloat(disableAngularSpeed)
        self.__disableAngularSpeed = disableAngularSpeed
    @property # getter - - - - - - - - - -
    def disableLinearSpeed(self):
        """[0,+infinity) disableLinearSpeed defines lower-limit tolerance value when body is considered at rest and not part of rigid body calculation, reducing numeric instabilitiess."""
        return self.__disableLinearSpeed
    @disableLinearSpeed.setter
    def disableLinearSpeed(self, disableLinearSpeed):
        if  disableLinearSpeed is None:
            disableLinearSpeed = 0  # default
        assertValidSFFloat(disableLinearSpeed)
        self.__disableLinearSpeed = disableLinearSpeed
    @property # getter - - - - - - - - - -
    def disableTime(self):
        """[0,+infinity) disableTime defines interval when body becomes at rest and not part of rigid body calculations, reducing numeric instabilities."""
        return self.__disableTime
    @disableTime.setter
    def disableTime(self, disableTime):
        if  disableTime is None:
            disableTime = 0  # default
        assertValidSFTime(disableTime)
        assertNonNegative('disableTime', disableTime)
        self.__disableTime = disableTime
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def finiteRotationAxis(self):
        """finiteRotationAxis specifies vector around which the object rotates."""
        return self.__finiteRotationAxis
    @finiteRotationAxis.setter
    def finiteRotationAxis(self, finiteRotationAxis):
        if  finiteRotationAxis is None:
            finiteRotationAxis = (0, 1, 0)  # default
        assertValidSFVec3f(finiteRotationAxis)
        self.__finiteRotationAxis = finiteRotationAxis
    @property # getter - - - - - - - - - -
    def fixed(self):
        """fixed indicates whether body is able to move."""
        return self.__fixed
    @fixed.setter
    def fixed(self, fixed):
        if  fixed is None:
            fixed = False  # default
        assertValidSFBool(fixed)
        self.__fixed = fixed
    @property # getter - - - - - - - - - -
    def forces(self):
        """forces defines linear force values applied to the object every frame."""
        return self.__forces
    @forces.setter
    def forces(self, forces):
        if  forces is None:
            forces = MFVec3f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec3f.DEFAULT_VALUE()))
        assertValidMFVec3f(forces)
        self.__forces = forces
    @property # getter - - - - - - - - - -
    def inertia(self):
        """inertia matrix defines a 3x2 inertia tensor matrix."""
        return self.__inertia
    @inertia.setter
    def inertia(self, inertia):
        if  inertia is None:
            inertia = (1, 0, 0, 0, 1, 0, 0, 0, 1)  # default
        assertValidSFMatrix3f(inertia)
        self.__inertia = inertia
    @property # getter - - - - - - - - - -
    def linearDampingFactor(self):
        """[0,1] linearDampingFactor automatically damps a portion of body motion over time."""
        return self.__linearDampingFactor
    @linearDampingFactor.setter
    def linearDampingFactor(self, linearDampingFactor):
        if  linearDampingFactor is None:
            linearDampingFactor = 0.001  # default
        assertValidSFFloat(linearDampingFactor)
        self.__linearDampingFactor = linearDampingFactor
    @property # getter - - - - - - - - - -
    def linearVelocity(self):
        """linearVelocity sets constant velocity value to object every frame, and reports updates by physics model."""
        return self.__linearVelocity
    @linearVelocity.setter
    def linearVelocity(self, linearVelocity):
        if  linearVelocity is None:
            linearVelocity = (0, 0, 0)  # default
        assertValidSFVec3f(linearVelocity)
        self.__linearVelocity = linearVelocity
    @property # getter - - - - - - - - - -
    def mass(self):
        """(0,1] mass of the body in kilograms."""
        return self.__mass
    @mass.setter
    def mass(self, mass):
        if  mass is None:
            mass = 1  # default
        assertValidSFFloat(mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def orientation(self):
        """orientation sets body direction in world space, then reports physics updates."""
        return self.__orientation
    @orientation.setter
    def orientation(self, orientation):
        if  orientation is None:
            orientation = (0, 0, 1, 0)  # default
        assertValidSFRotation(orientation)
        self.__orientation = orientation
    @property # getter - - - - - - - - - -
    def position(self):
        """position sets body location in world space, then reports physics updates."""
        return self.__position
    @position.setter
    def position(self, position):
        if  position is None:
            position = (0, 0, 0)  # default
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def torques(self):
        """torques defines rotational force values applied to the object every frame."""
        return self.__torques
    @torques.setter
    def torques(self, torques):
        if  torques is None:
            torques = MFVec3f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec3f.DEFAULT_VALUE()))
        assertValidMFVec3f(torques)
        self.__torques = torques
    @property # getter - - - - - - - - - -
    def useFiniteRotation(self):
        """useFiniteRotation enables/disables higher-resolution, higher-cost computational method for calculating rotations."""
        return self.__useFiniteRotation
    @useFiniteRotation.setter
    def useFiniteRotation(self, useFiniteRotation):
        if  useFiniteRotation is None:
            useFiniteRotation = False  # default
        assertValidSFBool(useFiniteRotation)
        self.__useFiniteRotation = useFiniteRotation
    @property # getter - - - - - - - - - -
    def useGlobalGravity(self):
        """useGlobalGravity indicates whether this particular body is influenced by parent RigidBodyCollection's gravity setting."""
        return self.__useGlobalGravity
    @useGlobalGravity.setter
    def useGlobalGravity(self, useGlobalGravity):
        if  useGlobalGravity is None:
            useGlobalGravity = True  # default
        assertValidSFBool(useGlobalGravity)
        self.__useGlobalGravity = useGlobalGravity
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def massDensityModel(self):
        """[Sphere,Box,Cone] The massDensityModel field is used to describe the geometry type and dimensions used to calculate the mass density in the physics model."""
        return self.__massDensityModel
    @massDensityModel.setter
    def massDensityModel(self, massDensityModel):
        if  massDensityModel is None:
            massDensityModel = None  # default
        assertValidSFNode(massDensityModel)
        if not massDensityModel is None and not isinstance(massDensityModel,(Sphere,Box,Cone,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(massDensityModel) + ' does not match required node type (Sphere,Box,Cone,ProtoInstance) and is invalid')
        self.__massDensityModel = massDensityModel
    @property # getter - - - - - - - - - -
    def geometry(self):
        """[X3DNBodyCollidableNode] The geometry field is used to connect the body modelled by the physics engine implementation to the real geometry of the scene through the use of collidable nodes."""
        return self.__geometry
    @geometry.setter
    def geometry(self, geometry):
        if  geometry is None:
            geometry = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(geometry)
        self.__geometry = geometry
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.massDensityModel or self.metadata or (len(self.geometry) > 0)
    # output function - - - - - - - - - -

class RigidBodyCollection(_X3DChildNode):  # , _X3DBoundedObject  # TODO fix additional inheritance method resolution order (MRO)
    """
    RigidBodyCollection represents a system of bodies that interact within a single physics model.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'RigidBodyCollection'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#RigidBodyCollection'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#RigidBodyCollection'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('autoDisable', False, FieldType.SFBool, AccessType.inputOutput, 'RigidBodyCollection'),
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('constantForceMix', 0.0001, FieldType.SFFloat, AccessType.inputOutput, 'RigidBodyCollection'),
        ('contactSurfaceThickness', 0, FieldType.SFFloat, AccessType.inputOutput, 'RigidBodyCollection'),
        ('disableAngularSpeed', 0, FieldType.SFFloat, AccessType.inputOutput, 'RigidBodyCollection'),
        ('disableLinearSpeed', 0, FieldType.SFFloat, AccessType.inputOutput, 'RigidBodyCollection'),
        ('disableTime', 0, FieldType.SFTime, AccessType.inputOutput, 'RigidBodyCollection'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'RigidBodyCollection'),
        ('errorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'RigidBodyCollection'),
        ('gravity', (0, -9.8, 0), FieldType.SFVec3f, AccessType.inputOutput, 'RigidBodyCollection'),
        ('iterations', 10, FieldType.SFInt32, AccessType.inputOutput, 'RigidBodyCollection'),
        ('maxCorrectionSpeed', -1, FieldType.SFFloat, AccessType.inputOutput, 'RigidBodyCollection'),
        ('preferAccuracy', False, FieldType.SFBool, AccessType.inputOutput, 'RigidBodyCollection'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('collider', None, FieldType.SFNode, AccessType.initializeOnly, 'RigidBodyCollection'),
        ('bodies', [], FieldType.MFNode, AccessType.inputOutput, 'RigidBodyCollection'),
        ('joints', [], FieldType.MFNode, AccessType.inputOutput, 'RigidBodyCollection'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        autoDisable=False,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        constantForceMix=0.0001,
        contactSurfaceThickness=0,
        disableAngularSpeed=0,
        disableLinearSpeed=0,
        disableTime=0,
        enabled=True,
        errorCorrection=0.8,
        gravity=(0, -9.8, 0),
        iterations=10,
        maxCorrectionSpeed=-1,
        preferAccuracy=False,
        visible=True,
        collider=None,
        bodies=None,
        joints=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode RigidBodyCollection __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.autoDisable = autoDisable
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.constantForceMix = constantForceMix
        self.contactSurfaceThickness = contactSurfaceThickness
        self.disableAngularSpeed = disableAngularSpeed
        self.disableLinearSpeed = disableLinearSpeed
        self.disableTime = disableTime
        self.enabled = enabled
        self.errorCorrection = errorCorrection
        self.gravity = gravity
        self.iterations = iterations
        self.maxCorrectionSpeed = maxCorrectionSpeed
        self.preferAccuracy = preferAccuracy
        self.visible = visible
        self.collider = collider
        self.bodies = bodies
        self.joints = joints
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def autoDisable(self):
        """autoDisable toggles operation of disableAngularSpeed, disableLinearSpeed, disableTime."""
        return self.__autoDisable
    @autoDisable.setter
    def autoDisable(self, autoDisable):
        if  autoDisable is None:
            autoDisable = False  # default
        assertValidSFBool(autoDisable)
        self.__autoDisable = autoDisable
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def constantForceMix(self):
        """[0,+infinity) constantForceMix modifies damping calculations by violating normal constraints while applying small, constant forces in those calculations."""
        return self.__constantForceMix
    @constantForceMix.setter
    def constantForceMix(self, constantForceMix):
        if  constantForceMix is None:
            constantForceMix = 0.0001  # default
        assertValidSFFloat(constantForceMix)
        self.__constantForceMix = constantForceMix
    @property # getter - - - - - - - - - -
    def contactSurfaceThickness(self):
        """[0,+infinity) contactSurfaceThickness defines how far bodies may interpenetrate after a collision, allowing simulation of softer bodies that deform somewhat during collision."""
        return self.__contactSurfaceThickness
    @contactSurfaceThickness.setter
    def contactSurfaceThickness(self, contactSurfaceThickness):
        if  contactSurfaceThickness is None:
            contactSurfaceThickness = 0  # default
        assertValidSFFloat(contactSurfaceThickness)
        self.__contactSurfaceThickness = contactSurfaceThickness
    @property # getter - - - - - - - - - -
    def disableAngularSpeed(self):
        """[0,+infinity) disableAngularSpeed defines lower-limit tolerance value when body is considered at rest and not part of rigid body calculations, reducing numeric instabilities."""
        return self.__disableAngularSpeed
    @disableAngularSpeed.setter
    def disableAngularSpeed(self, disableAngularSpeed):
        if  disableAngularSpeed is None:
            disableAngularSpeed = 0  # default
        assertValidSFFloat(disableAngularSpeed)
        self.__disableAngularSpeed = disableAngularSpeed
    @property # getter - - - - - - - - - -
    def disableLinearSpeed(self):
        """[0,+infinity) disableLinearSpeed defines lower-limit tolerance value when body is considered at rest and not part of rigid body calculation, reducing numeric instabilitiess."""
        return self.__disableLinearSpeed
    @disableLinearSpeed.setter
    def disableLinearSpeed(self, disableLinearSpeed):
        if  disableLinearSpeed is None:
            disableLinearSpeed = 0  # default
        assertValidSFFloat(disableLinearSpeed)
        self.__disableLinearSpeed = disableLinearSpeed
    @property # getter - - - - - - - - - -
    def disableTime(self):
        """[0,+infinity) disableTime defines interval when body becomes at rest and not part of rigid body calculations, reducing numeric instabilities."""
        return self.__disableTime
    @disableTime.setter
    def disableTime(self, disableTime):
        if  disableTime is None:
            disableTime = 0  # default
        assertValidSFTime(disableTime)
        assertNonNegative('disableTime', disableTime)
        self.__disableTime = disableTime
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def errorCorrection(self):
        """[0,1] errorCorrection describes how quickly intersection errors due to floating-point inaccuracies are resolved (0=no correction, 1=all corrected in single step)."""
        return self.__errorCorrection
    @errorCorrection.setter
    def errorCorrection(self, errorCorrection):
        if  errorCorrection is None:
            errorCorrection = 0.8  # default
        assertValidSFFloat(errorCorrection)
        self.__errorCorrection = errorCorrection
    @property # getter - - - - - - - - - -
    def gravity(self):
        """gravity indicates direction and strength of local gravity vector for this collection of bodies (units m/sec^2)."""
        return self.__gravity
    @gravity.setter
    def gravity(self, gravity):
        if  gravity is None:
            gravity = (0, -9.8, 0)  # default
        assertValidSFVec3f(gravity)
        self.__gravity = gravity
    @property # getter - - - - - - - - - -
    def iterations(self):
        """[0,+infinity) iterations controls number of iterations performed over collectioned joints and bodies during each evaluation."""
        return self.__iterations
    @iterations.setter
    def iterations(self, iterations):
        if  iterations is None:
            iterations = 10  # default
        assertValidSFInt32(iterations)
        self.__iterations = iterations
    @property # getter - - - - - - - - - -
    def maxCorrectionSpeed(self):
        """[0,+infinity) or -1, maxCorrectionSpeed."""
        return self.__maxCorrectionSpeed
    @maxCorrectionSpeed.setter
    def maxCorrectionSpeed(self, maxCorrectionSpeed):
        if  maxCorrectionSpeed is None:
            maxCorrectionSpeed = -1  # default
        assertValidSFFloat(maxCorrectionSpeed)
        self.__maxCorrectionSpeed = maxCorrectionSpeed
    @property # getter - - - - - - - - - -
    def preferAccuracy(self):
        """preferAccuracy provides hint for performance preference: higher accuracy or faster computational speed."""
        return self.__preferAccuracy
    @preferAccuracy.setter
    def preferAccuracy(self, preferAccuracy):
        if  preferAccuracy is None:
            preferAccuracy = False  # default
        assertValidSFBool(preferAccuracy)
        self.__preferAccuracy = preferAccuracy
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def collider(self):
        """[CollisionCollection] The collider field associates a collision collection with this rigid body collection allowing seamless updates and integration without the need to use the X3D event model."""
        return self.__collider
    @collider.setter
    def collider(self, collider):
        if  collider is None:
            collider = None  # default
        assertValidSFNode(collider)
        if not collider is None and not isinstance(collider,(CollisionCollection,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(collider) + ' does not match required node type (CollisionCollection,ProtoInstance) and is invalid')
        self.__collider = collider
    @property # getter - - - - - - - - - -
    def bodies(self):
        """[RigidBody] Collection of top-level nodes that comprise a set of bodies evaluated as a single set of interactions."""
        return self.__bodies
    @bodies.setter
    def bodies(self, bodies):
        if  bodies is None:
            bodies = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(bodies)
        self.__bodies = bodies
    @property # getter - - - - - - - - - -
    def joints(self):
        """[X3DRigidJointNode] The joints field is used to register all joints between bodies contained in this collection."""
        return self.__joints
    @joints.setter
    def joints(self, joints):
        if  joints is None:
            joints = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(joints)
        self.__joints = joints
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.collider or self.IS or self.metadata or (len(self.bodies) > 0) or (len(self.joints) > 0)
    # output function - - - - - - - - - -

class ScalarChaser(_X3DChaserNode):
    """
    ScalarChaser generates a series of single floating-point values that progressively change from initial value to destination value.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ScalarChaser'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#ScalarChaser'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ScalarChaser'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('duration', 1, FieldType.SFTime, AccessType.initializeOnly, 'X3DChaserNode'),
        ('initialDestination', 0, FieldType.SFFloat, AccessType.initializeOnly, 'ScalarChaser'),
        ('initialValue', 0, FieldType.SFFloat, AccessType.initializeOnly, 'ScalarChaser'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        duration=1,
        initialDestination=0,
        initialValue=0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ScalarChaser __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.duration = duration
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def duration(self):
        """[0,+infinity) duration is the time interval for filter response in seconds."""
        return self.__duration
    @duration.setter
    def duration(self, duration):
        if  duration is None:
            duration = 1  # default
        assertValidSFTime(duration)
        assertNonNegative('duration', duration)
        self.__duration = duration
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = 0  # default
        assertValidSFFloat(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = 0  # default
        assertValidSFFloat(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class ScalarDamper(_X3DDamperNode):
    """
    ScalarDamper generates a series of floating-point values that progressively change from initial value to destination value.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ScalarDamper'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#ScalarDamper'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ScalarDamper'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('initialDestination', 0, FieldType.SFFloat, AccessType.initializeOnly, 'ScalarDamper'),
        ('initialValue', 0, FieldType.SFFloat, AccessType.initializeOnly, 'ScalarDamper'),
        ('order', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DDamperNode'),
        ('tau', 0.3, FieldType.SFTime, AccessType.inputOutput, 'X3DDamperNode'),
        ('tolerance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DDamperNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        initialDestination=0,
        initialValue=0,
        order=3,
        tau=0.3,
        tolerance=-1,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ScalarDamper __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.order = order
        self.tau = tau
        self.tolerance = tolerance
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = 0  # default
        assertValidSFFloat(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = 0  # default
        assertValidSFFloat(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def order(self):
        """[0,5] order defines the number of internal filters (larger means smoother response, longer delay)."""

        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3  # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 0)
        assertLessThanEquals('order', order, 5)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tau(self):
        """[0,+infinity) tau is the exponential-decay time constant for filter response in seconds."""
        return self.__tau
    @tau.setter
    def tau(self, tau):
        if  tau is None:
            tau = 0.3  # default
        assertValidSFTime(tau)
        assertNonNegative('tau', tau)
        self.__tau = tau
    @property # getter - - - - - - - - - -
    def tolerance(self):
        """[0,+infinity) or -1."""
        return self.__tolerance
    @tolerance.setter
    def tolerance(self, tolerance):
        if  tolerance is None:
            tolerance = -1  # default
        assertValidSFFloat(tolerance)
        self.__tolerance = tolerance
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class ScalarInterpolator(_X3DInterpolatorNode):
    """
    ScalarInterpolator generates piecewise-linear SFFloat values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ScalarInterpolator'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#ScalarInterpolator'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ScalarInterpolator'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('key', [], FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
        ('keyValue', [], FieldType.MFFloat, AccessType.inputOutput, 'ScalarInterpolator'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        key=None,
        keyValue=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ScalarInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class ScreenFontStyle(_X3DFontStyleNode):
    """
    ScreenFontStyle is an X3DFontStyleNode defines the size, family, justification, and other styles used within a screen layout.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ScreenFontStyle'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/layout.html#ScreenFontStyle'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ScreenFontStyle'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('family', ["SERIF"], FieldType.MFString, AccessType.inputOutput, 'ScreenFontStyle'),
        ('horizontal', True, FieldType.SFBool, AccessType.inputOutput, 'ScreenFontStyle'),
        ('justify', ["BEGIN"], FieldType.MFString, AccessType.inputOutput, 'ScreenFontStyle'),
        ('language', '', FieldType.SFString, AccessType.inputOutput, 'ScreenFontStyle'),
        ('leftToRight', True, FieldType.SFBool, AccessType.inputOutput, 'ScreenFontStyle'),
        ('pointSize', 12.0, FieldType.SFFloat, AccessType.inputOutput, 'ScreenFontStyle'),
        ('spacing', 1.0, FieldType.SFFloat, AccessType.inputOutput, 'ScreenFontStyle'),
        ('topToBottom', True, FieldType.SFBool, AccessType.inputOutput, 'ScreenFontStyle'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', 'PLAIN', FieldType.SFString, AccessType.inputOutput, 'ScreenFontStyle')]
    def __init__(self,
        family=None,
        horizontal=True,
        justify=None,
        language='',
        leftToRight=True,
        pointSize=12.0,
        spacing=1.0,
        topToBottom=True,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_='PLAIN'):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ScreenFontStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.family = family
        self.horizontal = horizontal
        self.justify = justify
        self.language = language
        self.leftToRight = leftToRight
        self.pointSize = pointSize
        self.spacing = spacing
        self.topToBottom = topToBottom
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def family(self):
        """Array of quoted font family names in preference order, browsers use the first supported family."""
        return self.__family
    @family.setter
    def family(self, family):
        if  family is None:
            family = ["SERIF"]  # default
        assertValidMFString(family)
        self.__family = family
    @property # getter - - - - - - - - - -
    def horizontal(self):
        """Whether text direction is horizontal (true) or vertical (false)."""
        return self.__horizontal
    @horizontal.setter
    def horizontal(self, horizontal):
        if  horizontal is None:
            horizontal = True  # default
        assertValidSFBool(horizontal)
        self.__horizontal = horizontal
    @property # getter - - - - - - - - - -
    def justify(self):
        """The justify field determines horizontal and vertical alignment of text layout, relative to the origin of the object coordinate system."""
        return self.__justify
    @justify.setter
    def justify(self, justify):
        if  justify is None:
            justify = ["BEGIN"]  # default
        assertValidMFString(justify)
        assertValidJustify('justify', justify)
        self.__justify = justify
    @property # getter - - - - - - - - - -
    def language(self):
        """Language codes consist of a primary code and a (possibly empty) series of subcodes."""
        return self.__language
    @language.setter
    def language(self, language):
        if  language is None:
            language = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(language)
        self.__language = language
    @property # getter - - - - - - - - - -
    def leftToRight(self):
        """Whether text direction is left-to-right (true) or right-to-left (false)."""
        return self.__leftToRight
    @leftToRight.setter
    def leftToRight(self, leftToRight):
        if  leftToRight is None:
            leftToRight = True  # default
        assertValidSFBool(leftToRight)
        self.__leftToRight = leftToRight
    @property # getter - - - - - - - - - -
    def pointSize(self):
        """(0,+infinity) pointSize field specifies the size of text in points."""
        return self.__pointSize
    @pointSize.setter
    def pointSize(self, pointSize):
        if  pointSize is None:
            pointSize = 12.0  # default
        assertValidSFFloat(pointSize)
        assertPositive('pointSize', pointSize)
        self.__pointSize = pointSize
    @property # getter - - - - - - - - - -
    def spacing(self):
        """[0,+infinity) Adjustment factor for line spacing between adjacent lines of text."""
        return self.__spacing
    @spacing.setter
    def spacing(self, spacing):
        if  spacing is None:
            spacing = 1.0  # default
        assertValidSFFloat(spacing)
        assertNonNegative('spacing', spacing)
        self.__spacing = spacing
    @property # getter - - - - - - - - - -
    def topToBottom(self):
        """Whether text direction is top-to-bottom (true) or bottom-to-top (false)."""
        return self.__topToBottom
    @topToBottom.setter
    def topToBottom(self, topToBottom):
        if  topToBottom is None:
            topToBottom = True  # default
        assertValidSFBool(topToBottom)
        self.__topToBottom = topToBottom
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = 'PLAIN'  # default
        assertValidSFString(style_)
        assertValidFontStyle('style_', style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class ScreenGroup(_X3DGroupingNode):
    """
    ScreenGroup is a Grouping node that can contain most nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ScreenGroup'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/layout.html#ScreenGroup'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ScreenGroup'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        visible=True,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ScreenGroup __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.visible = visible
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class Script(_X3DScriptNode):
    """
    Script contains author-programmed event behaviors for a scene.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Script'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/scripting.html#Script'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Script'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('autoRefresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DScriptNode'),
        ('autoRefreshTimeLimit', 3600, FieldType.SFTime, AccessType.inputOutput, 'X3DScriptNode'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DScriptNode'),
        ('directOutput', False, FieldType.SFBool, AccessType.initializeOnly, 'Script'),
        ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DScriptNode'),
        ('mustEvaluate', False, FieldType.SFBool, AccessType.initializeOnly, 'Script'),
        ('sourceCode', '', FieldType.SFString, AccessType.inputOutput, 'Script'),
        ('url', [], FieldType.MFString, AccessType.inputOutput, 'X3DScriptNode'),
        ('field', [], FieldType.MFNode, AccessType.inputOutput, 'Script'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        autoRefresh=0,
        autoRefreshTimeLimit=3600,
        description='',
        directOutput=False,
        load=True,
        mustEvaluate=False,
        sourceCode='',
        url=None,
        field=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Script __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.autoRefresh = autoRefresh
        self.autoRefreshTimeLimit = autoRefreshTimeLimit
        self.description = description
        self.directOutput = directOutput
        self.load = load
        self.mustEvaluate = mustEvaluate
        self.sourceCode = sourceCode
        self.url = url
        self.field = field
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def autoRefresh(self):
        """autoRefresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__autoRefresh
    @autoRefresh.setter
    def autoRefresh(self, autoRefresh):
        if  autoRefresh is None:
            autoRefresh = 0  # default
        assertValidSFTime(autoRefresh)
        assertNonNegative('autoRefresh', autoRefresh)
        self.__autoRefresh = autoRefresh
    @property # getter - - - - - - - - - -
    def autoRefreshTimeLimit(self):
        """autoRefreshTimeLimit defines maximum duration that automatic refresh activity can occur."""
        return self.__autoRefreshTimeLimit
    @autoRefreshTimeLimit.setter
    def autoRefreshTimeLimit(self, autoRefreshTimeLimit):
        if  autoRefreshTimeLimit is None:
            autoRefreshTimeLimit = 3600  # default
        assertValidSFTime(autoRefreshTimeLimit)
        assertNonNegative('autoRefreshTimeLimit', autoRefreshTimeLimit)
        self.__autoRefreshTimeLimit = autoRefreshTimeLimit
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def directOutput(self):
        """Set directOutput true if Script has field reference(s) of type SFNode/MFNode, and also uses direct access to modify attributes of a referenced node in the Scene."""
        return self.__directOutput
    @directOutput.setter
    def directOutput(self, directOutput):
        if  directOutput is None:
            directOutput = False  # default
        assertValidSFBool(directOutput)
        self.__directOutput = directOutput
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True  # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def mustEvaluate(self):
        """If mustEvaluate false, then the X3D player may delay sending input events to Script until output events are needed."""
        return self.__mustEvaluate
    @mustEvaluate.setter
    def mustEvaluate(self, mustEvaluate):
        if  mustEvaluate is None:
            mustEvaluate = False  # default
        assertValidSFBool(mustEvaluate)
        self.__mustEvaluate = mustEvaluate
    @property # getter - - - - - - - - - -
    def sourceCode(self):
        """ Embedded source code for a local program. """
        return self.__sourceCode
    @sourceCode.setter
    def sourceCode(self, sourceCode):
        if  sourceCode is None:
            sourceCode = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(sourceCode)
        self.__sourceCode = sourceCode
    @property # getter - - - - - - - - - -
    def url(self):
        """List of address links for runnable script files."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def field(self):
        """Include a field statement for each field declaration in this Script node."""
        return self.__field
    @field.setter
    def field(self, field):
        if  field is None:
            field = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        # TODO type-aware checks for field
        if field: # walk each child in list, if any (avoid empty list recursion)
            for each in field:
                assertValidFieldInitializationValue(each.name, each.type, each.value, parent='Script')
        self.__field = field
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.field) > 0)
    # output function - - - - - - - - - -

class SegmentedVolumeData(_X3DVolumeDataNode):
    """
    SegmentedVolumeData displays a segmented voxel dataset with different RenderStyle nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'SegmentedVolumeData'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#SegmentedVolumeData'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SegmentedVolumeData'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DVolumeDataNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeDataNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DVolumeDataNode'),
        ('dimensions', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'X3DVolumeDataNode'),
        ('segmentEnabled', [], FieldType.MFBool, AccessType.inputOutput, 'SegmentedVolumeData'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeDataNode'),
        ('segmentIdentifiers', None, FieldType.SFNode, AccessType.inputOutput, 'SegmentedVolumeData'),
        ('voxels', None, FieldType.SFNode, AccessType.inputOutput, 'SegmentedVolumeData'),
        ('renderStyle', [], FieldType.MFNode, AccessType.inputOutput, 'SegmentedVolumeData'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        dimensions=(1, 1, 1),
        segmentEnabled=None,
        visible=True,
        segmentIdentifiers=None,
        voxels=None,
        renderStyle=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode SegmentedVolumeData __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.dimensions = dimensions
        self.segmentEnabled = segmentEnabled
        self.visible = visible
        self.segmentIdentifiers = segmentIdentifiers
        self.voxels = voxels
        self.renderStyle = renderStyle
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def dimensions(self):
        """Actual-size X-Y-Z dimensions of volume data in local coordinate system."""
        return self.__dimensions
    @dimensions.setter
    def dimensions(self, dimensions):
        if  dimensions is None:
            dimensions = (1, 1, 1)  # default
        assertValidSFVec3f(dimensions)
        assertPositive('dimensions', dimensions)
        self.__dimensions = dimensions
    @property # getter - - - - - - - - - -
    def segmentEnabled(self):
        """Array of boolean values that indicates whether to draw each segment, with indices corresponding to the segment identifier."""
        return self.__segmentEnabled
    @segmentEnabled.setter
    def segmentEnabled(self, segmentEnabled):
        if  segmentEnabled is None:
            segmentEnabled = MFBool.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFBool.DEFAULT_VALUE()))
        assertValidMFBool(segmentEnabled)
        self.__segmentEnabled = segmentEnabled
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def segmentIdentifiers(self):
        """[X3DTexture3DNode] Single contained X3DTexture3DNode (ComposedTexture3D, ImageTexture3D, PixelTexture3D) holds component texture that provides corresponding segment identifier."""
        return self.__segmentIdentifiers
    @segmentIdentifiers.setter
    def segmentIdentifiers(self, segmentIdentifiers):
        if  segmentIdentifiers is None:
            segmentIdentifiers = None  # default
        assertValidSFNode(segmentIdentifiers)
        if not segmentIdentifiers is None and not isinstance(segmentIdentifiers,(_X3DTexture3DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(segmentIdentifiers) + ' does not match required node type (_X3DTexture3DNode,ProtoInstance) and is invalid')
        self.__segmentIdentifiers = segmentIdentifiers
    @property # getter - - - - - - - - - -
    def voxels(self):
        """[X3DTexture3DNode] Single contained X3DTexture3DNode (ComposedTexture3D, ImageTexture3D, PixelTexture3D) that provides raw voxel information utilized by corresponding rendering styles."""
        return self.__voxels
    @voxels.setter
    def voxels(self, voxels):
        if  voxels is None:
            voxels = None  # default
        assertValidSFNode(voxels)
        if not voxels is None and not isinstance(voxels,(_X3DTexture3DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(voxels) + ' does not match required node type (_X3DTexture3DNode,ProtoInstance) and is invalid')
        self.__voxels = voxels
    @property # getter - - - - - - - - - -
    def renderStyle(self):
        """[X3DVolumeRenderStyleNode] Multiple contained X3DVolumeRenderStyleNode nodes corresponding to each isosurface that define specific rendering technique for this volumetric object."""
        return self.__renderStyle
    @renderStyle.setter
    def renderStyle(self, renderStyle):
        if  renderStyle is None:
            renderStyle = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(renderStyle)
        self.__renderStyle = renderStyle
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.segmentIdentifiers or self.voxels or (len(self.renderStyle) > 0)
    # output function - - - - - - - - - -

class ShadedVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    All fields fully supported except shadows supported with at least Phong shading at level 3. All fields fully supported with at least Phong shading and Henyey-Greenstein phase function, shadows fully supported at level 4.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ShadedVolumeStyle'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#ShadedVolumeStyle'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ShadedVolumeStyle'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeRenderStyleNode'),
        ('lighting', False, FieldType.SFBool, AccessType.inputOutput, 'ShadedVolumeStyle'),
        ('phaseFunction', 'Henyey-Greenstein', FieldType.SFString, AccessType.initializeOnly, 'ShadedVolumeStyle'),
        ('shadows', False, FieldType.SFBool, AccessType.inputOutput, 'ShadedVolumeStyle'),
        ('material', None, FieldType.SFNode, AccessType.inputOutput, 'ShadedVolumeStyle'),
        ('surfaceNormals', None, FieldType.SFNode, AccessType.inputOutput, 'ShadedVolumeStyle'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        enabled=True,
        lighting=False,
        phaseFunction='Henyey-Greenstein',
        shadows=False,
        material=None,
        surfaceNormals=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ShadedVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.lighting = lighting
        self.phaseFunction = phaseFunction
        self.shadows = shadows
        self.material = material
        self.surfaceNormals = surfaceNormals
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def lighting(self):
        """Whether rendering calculates and applies shading effects to visual output."""
        return self.__lighting
    @lighting.setter
    def lighting(self, lighting):
        if  lighting is None:
            lighting = False  # default
        assertValidSFBool(lighting)
        self.__lighting = lighting
    @property # getter - - - - - - - - - -
    def phaseFunction(self):
        """define scattering model for implementations using global illumination (NONE or Henyey-Greenstein phase function)."""
        return self.__phaseFunction
    @phaseFunction.setter
    def phaseFunction(self, phaseFunction):
        if  phaseFunction is None:
            phaseFunction = 'Henyey-Greenstein'  # default
        assertValidSFString(phaseFunction)
        self.__phaseFunction = phaseFunction
    @property # getter - - - - - - - - - -
    def shadows(self):
        """Whether rendering calculates and applies shadows to visual output (using global illumination model)."""
        return self.__shadows
    @shadows.setter
    def shadows(self, shadows):
        if  shadows is None:
            shadows = False  # default
        assertValidSFBool(shadows)
        self.__shadows = shadows
    @property # getter - - - - - - - - - -
    def material(self):
        """[X3DMaterialNode] Colour and opacity is determined based on whether a value has been specified for the material field."""
        return self.__material
    @material.setter
    def material(self, material):
        if  material is None:
            material = None  # default
        assertValidSFNode(material)
        if not material is None and not isinstance(material,(_X3DMaterialNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(material) + ' does not match required node type (_X3DMaterialNode,ProtoInstance) and is invalid')
        self.__material = material
    @property # getter - - - - - - - - - -
    def surfaceNormals(self):
        """[X3DTexture3DNode] The surfaceNormals field contains a 3D texture with at least three component values."""
        return self.__surfaceNormals
    @surfaceNormals.setter
    def surfaceNormals(self, surfaceNormals):
        if  surfaceNormals is None:
            surfaceNormals = None  # default
        assertValidSFNode(surfaceNormals)
        if not surfaceNormals is None and not isinstance(surfaceNormals,(_X3DTexture3DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(surfaceNormals) + ' does not match required node type (_X3DTexture3DNode,ProtoInstance) and is invalid')
        self.__surfaceNormals = surfaceNormals
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.material or self.metadata or self.surfaceNormals
    # output function - - - - - - - - - -

class ShaderPart(_X3DNode):  # , _X3DUrlObject  # TODO fix additional inheritance method resolution order (MRO)
    """
    ShaderPart can contain a CDATA section of plain-text source code.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ShaderPart'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shaders.html#ShaderPart'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ShaderPart'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('autoRefresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('autoRefreshTimeLimit', 3600, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DUrlObject'),
        ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
        ('sourceCode', '', FieldType.SFString, AccessType.inputOutput, 'ShaderPart'),
        ('type', 'VERTEX', FieldType.SFString, AccessType.initializeOnly, 'ShaderPart'),
        ('url', [], FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        autoRefresh=0,
        autoRefreshTimeLimit=3600,
        description='',
        load=True,
        sourceCode='',
        type='VERTEX',
        url=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ShaderPart __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.autoRefresh = autoRefresh
        self.autoRefreshTimeLimit = autoRefreshTimeLimit
        self.description = description
        self.load = load
        self.sourceCode = sourceCode
        self.type = type
        self.url = url
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def autoRefresh(self):
        """autoRefresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__autoRefresh
    @autoRefresh.setter
    def autoRefresh(self, autoRefresh):
        if  autoRefresh is None:
            autoRefresh = 0  # default
        assertValidSFTime(autoRefresh)
        assertNonNegative('autoRefresh', autoRefresh)
        self.__autoRefresh = autoRefresh
    @property # getter - - - - - - - - - -
    def autoRefreshTimeLimit(self):
        """autoRefreshTimeLimit defines maximum duration that automatic refresh activity can occur."""
        return self.__autoRefreshTimeLimit
    @autoRefreshTimeLimit.setter
    def autoRefreshTimeLimit(self, autoRefreshTimeLimit):
        if  autoRefreshTimeLimit is None:
            autoRefreshTimeLimit = 3600  # default
        assertValidSFTime(autoRefreshTimeLimit)
        assertNonNegative('autoRefreshTimeLimit', autoRefreshTimeLimit)
        self.__autoRefreshTimeLimit = autoRefreshTimeLimit
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True  # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def sourceCode(self):
        """ Embedded source code for a local program. """
        return self.__sourceCode
    @sourceCode.setter
    def sourceCode(self, sourceCode):
        if  sourceCode is None:
            sourceCode = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(sourceCode)
        self.__sourceCode = sourceCode
    @property # getter - - - - - - - - - -
    def type(self):
        """type indicates whether this ShaderProgram is a vertex or fragment (pixel) shader."""
        return self.__type
    @type.setter
    def type(self, type):
        if  type is None:
            type = 'VERTEX'  # default
        assertValidSFString(type)
        self.__type = type
    @property # getter - - - - - - - - - -
    def url(self):
        """Location and filename of shader."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class ShaderProgram(_X3DNode):  # , _X3DUrlObject, _X3DProgrammableShaderObject  # TODO fix additional inheritance method resolution order (MRO)
    """
    ShaderProgram can contain field declarations and a CDATA section of plain-text source code.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ShaderProgram'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shaders.html#ShaderProgram'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ShaderProgram'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('autoRefresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('autoRefreshTimeLimit', 3600, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DUrlObject'),
        ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
        ('sourceCode', '', FieldType.SFString, AccessType.inputOutput, 'ShaderProgram'),
        ('type', 'VERTEX', FieldType.SFString, AccessType.initializeOnly, 'ShaderProgram'),
        ('url', [], FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
        ('field', [], FieldType.MFNode, AccessType.inputOutput, 'ShaderProgram'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        autoRefresh=0,
        autoRefreshTimeLimit=3600,
        description='',
        load=True,
        sourceCode='',
        type='VERTEX',
        url=None,
        field=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ShaderProgram __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.autoRefresh = autoRefresh
        self.autoRefreshTimeLimit = autoRefreshTimeLimit
        self.description = description
        self.load = load
        self.sourceCode = sourceCode
        self.type = type
        self.url = url
        self.field = field
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def autoRefresh(self):
        """autoRefresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__autoRefresh
    @autoRefresh.setter
    def autoRefresh(self, autoRefresh):
        if  autoRefresh is None:
            autoRefresh = 0  # default
        assertValidSFTime(autoRefresh)
        assertNonNegative('autoRefresh', autoRefresh)
        self.__autoRefresh = autoRefresh
    @property # getter - - - - - - - - - -
    def autoRefreshTimeLimit(self):
        """autoRefreshTimeLimit defines maximum duration that automatic refresh activity can occur."""
        return self.__autoRefreshTimeLimit
    @autoRefreshTimeLimit.setter
    def autoRefreshTimeLimit(self, autoRefreshTimeLimit):
        if  autoRefreshTimeLimit is None:
            autoRefreshTimeLimit = 3600  # default
        assertValidSFTime(autoRefreshTimeLimit)
        assertNonNegative('autoRefreshTimeLimit', autoRefreshTimeLimit)
        self.__autoRefreshTimeLimit = autoRefreshTimeLimit
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True  # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def sourceCode(self):
        """ Embedded source code for a local program. """
        return self.__sourceCode
    @sourceCode.setter
    def sourceCode(self, sourceCode):
        if  sourceCode is None:
            sourceCode = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(sourceCode)
        self.__sourceCode = sourceCode
    @property # getter - - - - - - - - - -
    def type(self):
        """type indicates whether this ShaderProgram is a vertex or fragment (pixel) shader."""
        return self.__type
    @type.setter
    def type(self, type):
        if  type is None:
            type = 'VERTEX'  # default
        assertValidSFString(type)
        self.__type = type
    @property # getter - - - - - - - - - -
    def url(self):
        """Location and filename of shader."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def field(self):
        """Include a field statement for each field declaration in the ShaderProgram node."""
        return self.__field
    @field.setter
    def field(self, field):
        if  field is None:
            field = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        # TODO type-aware checks for field
        if field: # walk each child in list, if any (avoid empty list recursion)
            for each in field:
                assertValidFieldInitializationValue(each.name, each.type, each.value, parent='ShaderProgram')
        self.__field = field
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.field) > 0)
    # output function - - - - - - - - - -

class Shape(_X3DShapeNode):
    """
    Shape can appear under any grouping node.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Shape'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#Shape'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Shape'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DShapeNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DShapeNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DShapeNode'),
        ('castShadow', True, FieldType.SFBool, AccessType.inputOutput, 'X3DShapeNode'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DShapeNode'),
        ('appearance', None, FieldType.SFNode, AccessType.inputOutput, 'X3DShapeNode'),
        ('geometry', None, FieldType.SFNode, AccessType.inputOutput, 'X3DShapeNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        castShadow=True,
        visible=True,
        appearance=None,
        geometry=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Shape __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.castShadow = castShadow
        self.visible = visible
        self.appearance = appearance
        self.geometry = geometry
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def castShadow(self):
        """castShadow defines whether this Shape casts shadows as produced by lighting nodes."""
        return self.__castShadow
    @castShadow.setter
    def castShadow(self, castShadow):
        if  castShadow is None:
            castShadow = True  # default
        assertValidSFBool(castShadow)
        self.__castShadow = castShadow
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def appearance(self):
        """[X3DAppearanceNode] Single contained Appearance node that can specify visual attributes (such as material, texture, fillProperties and lineProperties) applied to corresponding geometry."""
        return self.__appearance
    @appearance.setter
    def appearance(self, appearance):
        if  appearance is None:
            appearance = None  # default
        assertValidSFNode(appearance)
        if not appearance is None and not isinstance(appearance,(_X3DAppearanceNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(appearance) + ' does not match required node type (_X3DAppearanceNode,ProtoInstance) and is invalid')
        self.__appearance = appearance
    @property # getter - - - - - - - - - -
    def geometry(self):
        """[X3DGeometryNode] Single contained geometry node that is rendered according to corresponding appearance."""
        return self.__geometry
    @geometry.setter
    def geometry(self, geometry):
        if  geometry is None:
            geometry = None  # default
        assertValidSFNode(geometry)
        if not geometry is None and not isinstance(geometry,(_X3DGeometryNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(geometry) + ' does not match required node type (_X3DGeometryNode,ProtoInstance) and is invalid')
        self.__geometry = geometry
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.appearance or self.geometry or self.IS or self.metadata
    # output function - - - - - - - - - -

class SignalPdu(_X3DNetworkSensorNode, _X3DBoundedObject):
    """
    SignalPdu is a networked Protocol Data Unit (PDU) information node that communicates the transmission of voice, audio or other data modeled in a simulation.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'SignalPdu'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/dis.html#SignalPdu'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SignalPdu'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('address', 'localhost', FieldType.SFString, AccessType.inputOutput, 'SignalPdu'),
        ('applicationID', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('data', [], FieldType.MFInt32, AccessType.inputOutput, 'SignalPdu'),
        ('dataLength', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSensorNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('encodingScheme', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
        ('entityID', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
        ('geoCoords', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput, 'SignalPdu'),
        ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'SignalPdu'),
        ('multicastRelayHost', '', FieldType.SFString, AccessType.inputOutput, 'SignalPdu'),
        ('multicastRelayPort', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
        ('networkMode', 'standAlone', FieldType.SFString, AccessType.inputOutput, 'SignalPdu'),
        ('port', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
        ('radioID', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
        ('readInterval', 0.1, FieldType.SFTime, AccessType.inputOutput, 'SignalPdu'),
        ('rtpHeaderExpected', False, FieldType.SFBool, AccessType.inputOutput, 'SignalPdu'),
        ('sampleRate', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
        ('samples', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
        ('siteID', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
        ('tdlType', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('whichGeometry', 1, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
        ('writeInterval', 1.0, FieldType.SFTime, AccessType.inputOutput, 'SignalPdu'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        address='localhost',
        applicationID=0,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        data=None,
        dataLength=0,
        description='',
        enabled=True,
        encodingScheme=0,
        entityID=0,
        geoCoords=(0, 0, 0),
        geoSystem=None,
        multicastRelayHost='',
        multicastRelayPort=0,
        networkMode='standAlone',
        port=0,
        radioID=0,
        readInterval=0.1,
        rtpHeaderExpected=False,
        sampleRate=0,
        samples=0,
        siteID=0,
        tdlType=0,
        visible=True,
        whichGeometry=1,
        writeInterval=1.0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode SignalPdu __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.address = address
        self.applicationID = applicationID
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.data = data
        self.dataLength = dataLength
        self.description = description
        self.enabled = enabled
        self.encodingScheme = encodingScheme
        self.entityID = entityID
        self.geoCoords = geoCoords
        self.geoSystem = geoSystem
        self.multicastRelayHost = multicastRelayHost
        self.multicastRelayPort = multicastRelayPort
        self.networkMode = networkMode
        self.port = port
        self.radioID = radioID
        self.readInterval = readInterval
        self.rtpHeaderExpected = rtpHeaderExpected
        self.sampleRate = sampleRate
        self.samples = samples
        self.siteID = siteID
        self.tdlType = tdlType
        self.visible = visible
        self.whichGeometry = whichGeometry
        self.writeInterval = writeInterval
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def address(self):
        """Multicast network address, or else 'localhost'."""
        return self.__address
    @address.setter
    def address(self, address):
        if  address is None:
            address = 'localhost'  # default
        assertValidSFString(address)
        self.__address = address
    @property # getter - - - - - - - - - -
    def applicationID(self):

        """Each simulation application that can respond to simulation management PDUs needs to have a unique applicationID."""
        return self.__applicationID
    @applicationID.setter
    def applicationID(self, applicationID):
        if  applicationID is None:
            applicationID = 0  # default
        assertValidSFInt32(applicationID)
        self.__applicationID = applicationID
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def data(self):
        """Holds audio or digital data conveyed by the radio transmission."""
        return self.__data
    @data.setter
    def data(self, data):
        if  data is None:
            data = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(data)
        self.__data = data
    @property # getter - - - - - - - - - -
    def dataLength(self):
        """number of bits of digital voice audio or digital data being sent in the Signal PDU."""
        return self.__dataLength
    @dataLength.setter
    def dataLength(self, dataLength):
        if  dataLength is None:
            dataLength = 0  # default
        assertValidSFInt32(dataLength)
        self.__dataLength = dataLength
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables the sensor node."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def encodingScheme(self):
        """designates both Encoding Class and Encoding Type."""
        return self.__encodingScheme
    @encodingScheme.setter
    def encodingScheme(self, encodingScheme):
        if  encodingScheme is None:
            encodingScheme = 0  # default
        assertValidSFInt32(encodingScheme)
        self.__encodingScheme = encodingScheme
    @property # getter - - - - - - - - - -

    def entityID(self):
        """EntityID unique ID for entity within that application."""
        return self.__entityID
    @entityID.setter
    def entityID(self, entityID):
        if  entityID is None:
            entityID = 0  # default
        assertValidSFInt32(entityID)
        self.__entityID = entityID
    @property # getter - - - - - - - - - -
    def geoCoords(self):
        """Geographic location (specified in current geoSystem coordinates) for children geometry (specified in relative coordinate system, in meters)."""
        return self.__geoCoords
    @geoCoords.setter
    def geoCoords(self, geoCoords):
        if  geoCoords is None:
            geoCoords = (0, 0, 0)  # default
        assertValidSFVec3d(geoCoords)
        self.__geoCoords = geoCoords
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"]  # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def multicastRelayHost(self):
        """Fallback server address if multicast not available locally."""
        return self.__multicastRelayHost
    @multicastRelayHost.setter
    def multicastRelayHost(self, multicastRelayHost):
        if  multicastRelayHost is None:
            multicastRelayHost = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(multicastRelayHost)
        self.__multicastRelayHost = multicastRelayHost
    @property # getter - - - - - - - - - -
    def multicastRelayPort(self):
        """Fallback server port if multicast not available locally."""
        return self.__multicastRelayPort
    @multicastRelayPort.setter
    def multicastRelayPort(self, multicastRelayPort):
        if  multicastRelayPort is None:
            multicastRelayPort = 0  # default
        assertValidSFInt32(multicastRelayPort)
        self.__multicastRelayPort = multicastRelayPort
    @property # getter - - - - - - - - - -
    def networkMode(self):
        """Whether this entity is ignoring the network, sending DIS packets to the network, or receiving DIS packets from the network."""
        return self.__networkMode
    @networkMode.setter
    def networkMode(self, networkMode):
        if  networkMode is None:
            networkMode = 'standAlone'  # default
        assertValidSFString(networkMode)
        assertValidNetworkMode('networkMode', networkMode)
        self.__networkMode = networkMode
    @property # getter - - - - - - - - - -
    def port(self):
        """Multicast network port, for example: 3000."""
        return self.__port
    @port.setter
    def port(self, port):
        if  port is None:
            port = 0  # default
        assertValidSFInt32(port)
        self.__port = port
    @property # getter - - - - - - - - - -
    def radioID(self):
        """Identifies a particular radio within a given entity."""
        return self.__radioID
    @radioID.setter
    def radioID(self, radioID):
        if  radioID is None:
            radioID = 0  # default
        assertValidSFInt32(radioID)
        self.__radioID = radioID
    @property # getter - - - - - - - - - -
    def readInterval(self):
        """[0,+infinity) Seconds between read updates, 0 means no reading."""
        return self.__readInterval
    @readInterval.setter
    def readInterval(self, readInterval):
        if  readInterval is None:
            readInterval = 0.1  # default
        assertValidSFTime(readInterval)
        assertNonNegative('readInterval', readInterval)
        self.__readInterval = readInterval
    @property # getter - - - - - - - - - -
    def rtpHeaderExpected(self):
        """Whether RTP headers are prepended to DIS PDUs."""
        return self.__rtpHeaderExpected
    @rtpHeaderExpected.setter
    def rtpHeaderExpected(self, rtpHeaderExpected):
        if  rtpHeaderExpected is None:
            rtpHeaderExpected = False  # default
        assertValidSFBool(rtpHeaderExpected)
        self.__rtpHeaderExpected = rtpHeaderExpected
    @property # getter - - - - - - - - - -
    def sampleRate(self):
        """sampleRate gives either (1) sample rate in samples per second if Encoding Class is encoded audio, or (2) data rate in bits per second for data transmissions."""
        return self.__sampleRate
    @sampleRate.setter
    def sampleRate(self, sampleRate):
        if  sampleRate is None:
            sampleRate = 0  # default
        assertValidSFInt32(sampleRate)
        self.__sampleRate = sampleRate
    @property # getter - - - - - - - - - -
    def samples(self):
        """Number of samples in the PDU if the Encoding Class is encoded voice, otherwise the field is set to zero."""
        return self.__samples
    @samples.setter
    def samples(self, samples):
        if  samples is None:
            samples = 0  # default
        assertValidSFInt32(samples)
        self.__samples = samples
    @property # getter - - - - - - - - - -
    def siteID(self):
        """Simulation/exercise siteID of the participating LAN or organization."""
        return self.__siteID
    @siteID.setter
    def siteID(self, siteID):
        if  siteID is None:
            siteID = 0  # default
        assertValidSFInt32(siteID)
        self.__siteID = siteID
    @property # getter - - - - - - - - - -
    def tdlType(self):
        """Tactical Data Link (TDL) type as an enumerated value when the Encoding Class is voice, raw binary, application-specific, or database index representation of a TDL message."""
        return self.__tdlType
    @tdlType.setter
    def tdlType(self, tdlType):
        if  tdlType is None:
            tdlType = 0  # default
        assertValidSFInt32(tdlType)
        self.__tdlType = tdlType
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def whichGeometry(self):
        """Select geometry to render: -1 for no geometry, 0 for text trace, 1 for default geometry, (optional) higher values to render different states."""
        return self.__whichGeometry
    @whichGeometry.setter
    def whichGeometry(self, whichGeometry):
        if  whichGeometry is None:
            whichGeometry = 1  # default
        assertValidSFInt32(whichGeometry)
        self.__whichGeometry = whichGeometry
    @property # getter - - - - - - - - - -
    def writeInterval(self):
        """[0,+infinity) Seconds between write updates, 0 means no writing (sending)."""
        return self.__writeInterval
    @writeInterval.setter
    def writeInterval(self, writeInterval):
        if  writeInterval is None:
            writeInterval = 1.0  # default
        assertValidSFTime(writeInterval)
        assertNonNegative('writeInterval', writeInterval)
        self.__writeInterval = writeInterval
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class SilhouetteEnhancementVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    SilhouetteEnhancementVolumeStyle specifies that volumetric data is rendered with silhouette enhancement.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'SilhouetteEnhancementVolumeStyle'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#SilhouetteEnhancementVolumeStyle'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SilhouetteEnhancementVolumeStyle'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeRenderStyleNode'),
        ('silhouetteBoundaryOpacity', 0, FieldType.SFFloat, AccessType.inputOutput, 'SilhouetteEnhancementVolumeStyle'),
        ('silhouetteRetainedOpacity', 1, FieldType.SFFloat, AccessType.inputOutput, 'SilhouetteEnhancementVolumeStyle'),
        ('silhouetteSharpness', 0.5, FieldType.SFFloat, AccessType.inputOutput, 'SilhouetteEnhancementVolumeStyle'),
        ('surfaceNormals', None, FieldType.SFNode, AccessType.inputOutput, 'SilhouetteEnhancementVolumeStyle'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        enabled=True,
        silhouetteBoundaryOpacity=0,
        silhouetteRetainedOpacity=1,
        silhouetteSharpness=0.5,
        surfaceNormals=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode SilhouetteEnhancementVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.silhouetteBoundaryOpacity = silhouetteBoundaryOpacity
        self.silhouetteRetainedOpacity = silhouetteRetainedOpacity
        self.silhouetteSharpness = silhouetteSharpness
        self.surfaceNormals = surfaceNormals
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def silhouetteBoundaryOpacity(self):
        """[0,1] amount of the silhouette enhancement to use."""
        return self.__silhouetteBoundaryOpacity
    @silhouetteBoundaryOpacity.setter
    def silhouetteBoundaryOpacity(self, silhouetteBoundaryOpacity):
        if  silhouetteBoundaryOpacity is None:
            silhouetteBoundaryOpacity = 0  # default
        assertValidSFFloat(silhouetteBoundaryOpacity)
        assertZeroToOne('silhouetteBoundaryOpacity', silhouetteBoundaryOpacity)
        self.__silhouetteBoundaryOpacity = silhouetteBoundaryOpacity
    @property # getter - - - - - - - - - -
    def silhouetteRetainedOpacity(self):
        """[0,1] scaling of non-silhouette regions."""
        return self.__silhouetteRetainedOpacity
    @silhouetteRetainedOpacity.setter
    def silhouetteRetainedOpacity(self, silhouetteRetainedOpacity):
        if  silhouetteRetainedOpacity is None:
            silhouetteRetainedOpacity = 1  # default
        assertValidSFFloat(silhouetteRetainedOpacity)
        assertZeroToOne('silhouetteRetainedOpacity', silhouetteRetainedOpacity)
        self.__silhouetteRetainedOpacity = silhouetteRetainedOpacity
    @property # getter - - - - - - - - - -
    def silhouetteSharpness(self):
        """[0,+infinity) power function to control sharpness of the silhouette."""
        return self.__silhouetteSharpness
    @silhouetteSharpness.setter
    def silhouetteSharpness(self, silhouetteSharpness):
        if  silhouetteSharpness is None:
            silhouetteSharpness = 0.5  # default
        assertValidSFFloat(silhouetteSharpness)
        assertNonNegative('silhouetteSharpness', silhouetteSharpness)
        self.__silhouetteSharpness = silhouetteSharpness
    @property # getter - - - - - - - - - -
    def surfaceNormals(self):
        """[X3DTexture3DNode] The surfaceNormals field contains a 3D texture with at least three component values."""
        return self.__surfaceNormals
    @surfaceNormals.setter
    def surfaceNormals(self, surfaceNormals):
        if  surfaceNormals is None:
            surfaceNormals = None  # default
        assertValidSFNode(surfaceNormals)
        if not surfaceNormals is None and not isinstance(surfaceNormals,(_X3DTexture3DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(surfaceNormals) + ' does not match required node type (_X3DTexture3DNode,ProtoInstance) and is invalid')
        self.__surfaceNormals = surfaceNormals
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.surfaceNormals
    # output function - - - - - - - - - -

class SingleAxisHingeJoint(_X3DRigidJointNode):
    """
    SingleAxisHingeJoint has single axis about which to rotate, similar to a traditional door hinge. Contains two RigidBody nodes (containerField values body1, body2).
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'SingleAxisHingeJoint'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#SingleAxisHingeJoint'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SingleAxisHingeJoint'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('anchorPoint', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'SingleAxisHingeJoint'),
        ('axis', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'SingleAxisHingeJoint'),
        ('forceOutput', ["NONE"], FieldType.MFString, AccessType.inputOutput, 'X3DRigidJointNode'),
        ('maxAngle', 3.141592653, FieldType.SFFloat, AccessType.inputOutput, 'SingleAxisHingeJoint'),
        ('minAngle', -3.141592653, FieldType.SFFloat, AccessType.inputOutput, 'SingleAxisHingeJoint'),
        ('stopBounce', 0, FieldType.SFFloat, AccessType.inputOutput, 'SingleAxisHingeJoint'),
        ('stopErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'SingleAxisHingeJoint'),
        ('body1', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
        ('body2', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        anchorPoint=(0, 0, 0),
        axis=(0, 1, 0),
        forceOutput=None,
        maxAngle=3.141592653,
        minAngle=-3.141592653,
        stopBounce=0,
        stopErrorCorrection=0.8,
        body1=None,
        body2=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode SingleAxisHingeJoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.anchorPoint = anchorPoint
        self.axis = axis
        self.forceOutput = forceOutput
        self.maxAngle = maxAngle
        self.minAngle = minAngle
        self.stopBounce = stopBounce
        self.stopErrorCorrection = stopErrorCorrection
        self.body1 = body1
        self.body2 = body2
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def anchorPoint(self):
        """anchorPoint is joint center, specified in world coordinates."""
        return self.__anchorPoint
    @anchorPoint.setter
    def anchorPoint(self, anchorPoint):
        if  anchorPoint is None:
            anchorPoint = (0, 0, 0)  # default
        assertValidSFVec3f(anchorPoint)
        self.__anchorPoint = anchorPoint
    @property # getter - - - - - - - - - -
    def axis(self):
        """axis defines vector of joint connection between body1 and body2."""
        return self.__axis
    @axis.setter
    def axis(self, axis):
        if  axis is None:
            axis = (0, 1, 0)  # default
        assertValidSFVec3f(axis)
        self.__axis = axis
    @property # getter - - - - - - - - - -
    def forceOutput(self):
        """forceOutput controls which output fields are generated for the next frame."""
        return self.__forceOutput
    @forceOutput.setter
    def forceOutput(self, forceOutput):
        if  forceOutput is None:
            forceOutput = ["NONE"]  # default
        assertValidMFString(forceOutput)
        self.__forceOutput = forceOutput
    @property # getter - - - - - - - - - -
    def maxAngle(self):
        """[-pi,pi] maxAngle is maximum rotation angle for hinge."""
        return self.__maxAngle
    @maxAngle.setter
    def maxAngle(self, maxAngle):
        if  maxAngle is None:
            maxAngle = 3.141592653  # default
        assertValidSFFloat(maxAngle)
        self.__maxAngle = maxAngle
    @property # getter - - - - - - - - - -
    def minAngle(self):
        """[-pi,pi] minAngle is minimum rotation angle for hinge."""
        return self.__minAngle
    @minAngle.setter
    def minAngle(self, minAngle):
        if  minAngle is None:
            minAngle = -3.141592653  # default
        assertValidSFFloat(minAngle)
        self.__minAngle = minAngle
    @property # getter - - - - - - - - - -
    def stopBounce(self):
        """[0,1] stopBounce is velocity factor for bounce back once stop point is reached."""
        return self.__stopBounce
    @stopBounce.setter
    def stopBounce(self, stopBounce):
        if  stopBounce is None:
            stopBounce = 0  # default
        assertValidSFFloat(stopBounce)
        self.__stopBounce = stopBounce
    @property # getter - - - - - - - - - -
    def stopErrorCorrection(self):
        """[0,1] stopErrorCorrection is fraction of error correction performed during time step once stop point is reached."""
        return self.__stopErrorCorrection
    @stopErrorCorrection.setter
    def stopErrorCorrection(self, stopErrorCorrection):
        if  stopErrorCorrection is None:
            stopErrorCorrection = 0.8  # default
        assertValidSFFloat(stopErrorCorrection)
        self.__stopErrorCorrection = stopErrorCorrection
    @property # getter - - - - - - - - - -
    def body1(self):
        """[RigidBody] The body1 and body2 fields indicate the two RigidBody nodes connected by this joint."""
        return self.__body1
    @body1.setter
    def body1(self, body1):
        if  body1 is None:
            body1 = None  # default
        assertValidSFNode(body1)
        if not body1 is None and not isinstance(body1,(RigidBody,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(body1) + ' does not match required node type (RigidBody,ProtoInstance) and is invalid')
        self.__body1 = body1
    @property # getter - - - - - - - - - -
    def body2(self):
        """[RigidBody] The body1 and body2 fields indicate the two RigidBody nodes connected by this joint."""
        return self.__body2
    @body2.setter
    def body2(self, body2):
        if  body2 is None:
            body2 = None  # default
        assertValidSFNode(body2)
        if not body2 is None and not isinstance(body2,(RigidBody,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(body2) + ' does not match required node type (RigidBody,ProtoInstance) and is invalid')
        self.__body2 = body2
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.body1 or self.body2 or self.IS or self.metadata
    # output function - - - - - - - - - -

class SliderJoint(_X3DRigidJointNode):
    """
    SliderJoint constrains all movement between body1 and body2 along a single axis. Contains two RigidBody nodes (containerField values body1, body2).
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'SliderJoint'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#SliderJoint'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SliderJoint'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('axis', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'SliderJoint'),
        ('forceOutput', ["NONE"], FieldType.MFString, AccessType.inputOutput, 'X3DRigidJointNode'),
        ('maxSeparation', 1, FieldType.SFFloat, AccessType.inputOutput, 'SliderJoint'),
        ('minSeparation', 0, FieldType.SFFloat, AccessType.inputOutput, 'SliderJoint'),
        ('sliderForce', 0, FieldType.SFFloat, AccessType.inputOutput, 'SliderJoint'),
        ('stopBounce', 0, FieldType.SFFloat, AccessType.inputOutput, 'SliderJoint'),
        ('stopErrorCorrection', 1, FieldType.SFFloat, AccessType.inputOutput, 'SliderJoint'),
        ('body1', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
        ('body2', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        axis=(0, 1, 0),
        forceOutput=None,
        maxSeparation=1,
        minSeparation=0,
        sliderForce=0,
        stopBounce=0,
        stopErrorCorrection=1,
        body1=None,
        body2=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode SliderJoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.axis = axis
        self.forceOutput = forceOutput
        self.maxSeparation = maxSeparation
        self.minSeparation = minSeparation
        self.sliderForce = sliderForce
        self.stopBounce = stopBounce
        self.stopErrorCorrection = stopErrorCorrection
        self.body1 = body1
        self.body2 = body2
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def axis(self):
        """[0,1] axis is normalized vector specifying direction of motion."""
        return self.__axis
    @axis.setter
    def axis(self, axis):
        if  axis is None:
            axis = (0, 1, 0)  # default
        assertValidSFVec3f(axis)
        self.__axis = axis
    @property # getter - - - - - - - - - -
    def forceOutput(self):
        """forceOutput controls which output fields are generated for the next frame."""
        return self.__forceOutput
    @forceOutput.setter
    def forceOutput(self, forceOutput):
        if  forceOutput is None:
            forceOutput = ["NONE"]  # default
        assertValidMFString(forceOutput)
        self.__forceOutput = forceOutput
    @property # getter - - - - - - - - - -
    def maxSeparation(self):
        """maxSeparation is maximum separation distance between the two bodies."""
        return self.__maxSeparation
    @maxSeparation.setter
    def maxSeparation(self, maxSeparation):
        if  maxSeparation is None:
            maxSeparation = 1  # default
        assertValidSFFloat(maxSeparation)
        self.__maxSeparation = maxSeparation
    @property # getter - - - - - - - - - -
    def minSeparation(self):
        """minSeparation is minimum separation distance between the two bodies."""
        return self.__minSeparation
    @minSeparation.setter
    def minSeparation(self, minSeparation):
        if  minSeparation is None:
            minSeparation = 0  # default
        assertValidSFFloat(minSeparation)
        self.__minSeparation = minSeparation
    @property # getter - - - - - - - - - -
    def sliderForce(self):
        """[-infinity,infinity] sliderForce value is used to apply a force (specified in force base units) along the axis of the slider in equal and opposite directions to the two bodies."""
        return self.__sliderForce
    @sliderForce.setter
    def sliderForce(self, sliderForce):
        if  sliderForce is None:
            sliderForce = 0  # default
        assertValidSFFloat(sliderForce)
        self.__sliderForce = sliderForce
    @property # getter - - - - - - - - - -
    def stopBounce(self):
        """[0,1] stopBounce is velocity factor for bounce back once stop point is reached."""
        return self.__stopBounce
    @stopBounce.setter
    def stopBounce(self, stopBounce):
        if  stopBounce is None:
            stopBounce = 0  # default
        assertValidSFFloat(stopBounce)
        self.__stopBounce = stopBounce
    @property # getter - - - - - - - - - -
    def stopErrorCorrection(self):
        """[0,1] stopErrorCorrection is fraction of error correction performed during time step once stop point is reached."""
        return self.__stopErrorCorrection
    @stopErrorCorrection.setter
    def stopErrorCorrection(self, stopErrorCorrection):
        if  stopErrorCorrection is None:
            stopErrorCorrection = 1  # default
        assertValidSFFloat(stopErrorCorrection)
        self.__stopErrorCorrection = stopErrorCorrection
    @property # getter - - - - - - - - - -
    def body1(self):
        """[RigidBody] The body1 and body2 fields indicate the two RigidBody nodes connected by this joint."""
        return self.__body1
    @body1.setter
    def body1(self, body1):
        if  body1 is None:
            body1 = None  # default
        assertValidSFNode(body1)
        if not body1 is None and not isinstance(body1,(RigidBody,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(body1) + ' does not match required node type (RigidBody,ProtoInstance) and is invalid')
        self.__body1 = body1
    @property # getter - - - - - - - - - -
    def body2(self):
        """[RigidBody] The body1 and body2 fields indicate the two RigidBody nodes connected by this joint."""
        return self.__body2
    @body2.setter
    def body2(self, body2):
        if  body2 is None:
            body2 = None  # default
        assertValidSFNode(body2)
        if not body2 is None and not isinstance(body2,(RigidBody,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(body2) + ' does not match required node type (RigidBody,ProtoInstance) and is invalid')
        self.__body2 = body2
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.body1 or self.body2 or self.IS or self.metadata
    # output function - - - - - - - - - -

class Sound(_X3DSoundNode):
    """
    The Sound node controls the 3D spatialization of sound playback by a child AudioClip or MovieTexture node.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Sound'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#Sound'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Sound'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSoundNode'),
        ('direction', (0, 0, 1), FieldType.SFVec3f, AccessType.inputOutput, 'Sound'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundNode'),
        ('intensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'Sound'),
        ('location', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'Sound'),
        ('maxBack', 10, FieldType.SFFloat, AccessType.inputOutput, 'Sound'),
        ('maxFront', 10, FieldType.SFFloat, AccessType.inputOutput, 'Sound'),
        ('minBack', 1, FieldType.SFFloat, AccessType.inputOutput, 'Sound'),
        ('minFront', 1, FieldType.SFFloat, AccessType.inputOutput, 'Sound'),
        ('priority', 0, FieldType.SFFloat, AccessType.inputOutput, 'Sound'),
        ('spatialize', True, FieldType.SFBool, AccessType.initializeOnly, 'Sound'),
        ('source', None, FieldType.SFNode, AccessType.inputOutput, 'Sound'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        description='',
        direction=(0, 0, 1),
        enabled=True,
        intensity=1,
        location=(0, 0, 0),
        maxBack=10,
        maxFront=10,
        minBack=1,
        minFront=1,
        priority=0,
        spatialize=True,
        source=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Sound __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.direction = direction
        self.enabled = enabled
        self.intensity = intensity
        self.location = location
        self.maxBack = maxBack
        self.maxFront = maxFront
        self.minBack = minBack
        self.minFront = minFront
        self.priority = priority
        self.spatialize = spatialize
        self.source = source
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def direction(self):
        """direction of sound axis, relative to local coordinate system."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (0, 0, 1)  # default
        assertValidSFVec3f(direction)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def intensity(self):
        """Factor [0,1] adjusting loudness (decibels) of emitted sound."""
        return self.__intensity
    @intensity.setter
    def intensity(self, intensity):
        if  intensity is None:
            intensity = 1  # default
        assertValidSFFloat(intensity)
        assertZeroToOne('intensity', intensity)
        self.__intensity = intensity
    @property # getter - - - - - - - - - -
    def location(self):
        """Position of sound ellipsoid center, relative to local coordinate system."""
        return self.__location
    @location.setter
    def location(self, location):
        if  location is None:
            location = (0, 0, 0)  # default
        assertValidSFVec3f(location)
        self.__location = location
    @property # getter - - - - - - - - - -
    def maxBack(self):
        """Outer (zero loudness)ellipsoid distance along back direction."""
        return self.__maxBack
    @maxBack.setter
    def maxBack(self, maxBack):
        if  maxBack is None:
            maxBack = 10  # default
        assertValidSFFloat(maxBack)
        assertNonNegative('maxBack', maxBack)
        self.__maxBack = maxBack
    @property # getter - - - - - - - - - -
    def maxFront(self):
        """Outer (zero loudness)ellipsoid distance along front direction."""
        return self.__maxFront
    @maxFront.setter
    def maxFront(self, maxFront):
        if  maxFront is None:
            maxFront = 10  # default
        assertValidSFFloat(maxFront)
        assertNonNegative('maxFront', maxFront)
        self.__maxFront = maxFront
    @property # getter - - - - - - - - - -
    def minBack(self):
        """Inner (full loudness) ellipsoid distance along back direction."""
        return self.__minBack
    @minBack.setter
    def minBack(self, minBack):
        if  minBack is None:
            minBack = 1  # default
        assertValidSFFloat(minBack)
        assertNonNegative('minBack', minBack)
        self.__minBack = minBack
    @property # getter - - - - - - - - - -
    def minFront(self):
        """Inner (full loudness) ellipsoid distance along front direction."""
        return self.__minFront
    @minFront.setter
    def minFront(self, minFront):
        if  minFront is None:
            minFront = 1  # default
        assertValidSFFloat(minFront)
        assertNonNegative('minFront', minFront)
        self.__minFront = minFront
    @property # getter - - - - - - - - - -
    def priority(self):
        """Player hint [0,1] if needed to choose which sounds to play."""
        return self.__priority
    @priority.setter
    def priority(self, priority):
        if  priority is None:
            priority = 0  # default
        assertValidSFFloat(priority)
        assertZeroToOne('priority', priority)
        self.__priority = priority
    @property # getter - - - - - - - - - -
    def spatialize(self):
        """Whether to spatialize sound playback relative to viewer."""
        return self.__spatialize
    @spatialize.setter
    def spatialize(self, spatialize):
        if  spatialize is None:
            spatialize = True  # default
        assertValidSFBool(spatialize)
        self.__spatialize = spatialize
    @property # getter - - - - - - - - - -
    def source(self):
        """[X3DSoundSourceNode] sound source for the Sound node, either an AudioClip node or a MovieTexture node."""
        return self.__source
    @source.setter
    def source(self, source):
        if  source is None:
            source = None  # default
        assertValidSFNode(source)
        if not source is None and not isinstance(source,(_X3DSoundSourceNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(source) + ' does not match required node type (_X3DSoundSourceNode,ProtoInstance) and is invalid')
        self.__source = source
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.source
    # output function - - - - - - - - - -

class SpatialSound(_X3DSoundNode):
    """
    The SpatialSound node controls the 3D spatialization of sound playback by a child AudioClip or MovieTexture node.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'SpatialSound'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#Sound'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SpatialSound'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('coneInnerAngle', 6.2832, FieldType.SFFloat, AccessType.inputOutput, 'SpatialSound'),
        ('coneOuterAngle', 6.2832, FieldType.SFFloat, AccessType.inputOutput, 'SpatialSound'),
        ('coneOuterGain', 0, FieldType.SFFloat, AccessType.inputOutput, 'SpatialSound'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSoundNode'),
        ('direction', (0, 0, 1), FieldType.SFVec3f, AccessType.inputOutput, 'SpatialSound'),
        ('distanceModel', 'INVERSE', FieldType.SFString, AccessType.inputOutput, 'SpatialSound'),
        ('dopplerEnabled', False, FieldType.SFBool, AccessType.inputOutput, 'SpatialSound'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundNode'),
        ('enableHRTF', False, FieldType.SFBool, AccessType.inputOutput, 'SpatialSound'),
        ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'SpatialSound'),
        ('intensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'SpatialSound'),
        ('location', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'SpatialSound'),
        ('maxDistance', 10000, FieldType.SFFloat, AccessType.inputOutput, 'SpatialSound'),
        ('priority', 0, FieldType.SFFloat, AccessType.inputOutput, 'SpatialSound'),
        ('referenceDistance', 1, FieldType.SFFloat, AccessType.inputOutput, 'SpatialSound'),
        ('rolloffFactor', 1, FieldType.SFFloat, AccessType.inputOutput, 'SpatialSound'),
        ('spatialize', True, FieldType.SFBool, AccessType.initializeOnly, 'SpatialSound'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'SpatialSound'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        coneInnerAngle=6.2832,
        coneOuterAngle=6.2832,
        coneOuterGain=0,
        description='',
        direction=(0, 0, 1),
        distanceModel='INVERSE',
        dopplerEnabled=False,
        enabled=True,
        enableHRTF=False,
        gain=1,
        intensity=1,
        location=(0, 0, 0),
        maxDistance=10000,
        priority=0,
        referenceDistance=1,
        rolloffFactor=1,
        spatialize=True,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode SpatialSound __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.coneInnerAngle = coneInnerAngle
        self.coneOuterAngle = coneOuterAngle
        self.coneOuterGain = coneOuterGain
        self.description = description
        self.direction = direction
        self.distanceModel = distanceModel
        self.dopplerEnabled = dopplerEnabled
        self.enabled = enabled
        self.enableHRTF = enableHRTF
        self.gain = gain
        self.intensity = intensity
        self.location = location
        self.maxDistance = maxDistance
        self.priority = priority
        self.referenceDistance = referenceDistance
        self.rolloffFactor = rolloffFactor
        self.spatialize = spatialize
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def coneInnerAngle(self):
        """[0,2pi] coneInnerAngle is centered along direction and defines the inner conical volume, inside of which no source gain reduction occurs."""
        return self.__coneInnerAngle
    @coneInnerAngle.setter
    def coneInnerAngle(self, coneInnerAngle):
        if  coneInnerAngle is None:
            coneInnerAngle = 6.2832  # default
        assertValidSFFloat(coneInnerAngle)
        assertGreaterThanEquals('coneInnerAngle', coneInnerAngle, 0)
        assertLessThanEquals('coneInnerAngle', coneInnerAngle, 6.2832)
        self.__coneInnerAngle = coneInnerAngle
    @property # getter - - - - - - - - - -
    def coneOuterAngle(self):
        """[0,2pi] coneOuterAngle is centered along direction and defines an outer conical volume, within which the sound gain decreases linearly from full gain to coneOuterGain."""
        return self.__coneOuterAngle
    @coneOuterAngle.setter
    def coneOuterAngle(self, coneOuterAngle):
        if  coneOuterAngle is None:
            coneOuterAngle = 6.2832  # default
        assertValidSFFloat(coneOuterAngle)
        assertGreaterThanEquals('coneOuterAngle', coneOuterAngle, 0)
        assertLessThanEquals('coneOuterAngle', coneOuterAngle, 6.2832)
        self.__coneOuterAngle = coneOuterAngle
    @property # getter - - - - - - - - - -
    def coneOuterGain(self):
        """(-infinity,+infinity) coneOuterGain is minimum gain value found outside coneOuterAngle."""
        return self.__coneOuterGain
    @coneOuterGain.setter
    def coneOuterGain(self, coneOuterGain):
        if  coneOuterGain is None:
            coneOuterGain = 0  # default
        assertValidSFFloat(coneOuterGain)
        self.__coneOuterGain = coneOuterGain
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def direction(self):
        """direction of sound axis, relative to local coordinate system."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (0, 0, 1)  # default
        assertValidSFVec3f(direction)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def distanceModel(self):
        """distanceModel determines how field specifies which algorithm to use for sound attenuation, corresponding to distance between an audio source and a listener, as it moves away from the listener."""
        return self.__distanceModel
    @distanceModel.setter
    def distanceModel(self, distanceModel):
        if  distanceModel is None:
            distanceModel = 'INVERSE'  # default
        assertValidSFString(distanceModel)
        assertValidDistanceModel('distanceModel', distanceModel)
        self.__distanceModel = distanceModel
    @property # getter - - - - - - - - - -
    def dopplerEnabled(self):
        """dopplerEnabled enables/disables whether real-time Doppler effects (due to relation motion between sources and listeners) are computed by browser between virtual sound sources and active listening locations, then applied to received frequency at active listening locations."""
        return self.__dopplerEnabled
    @dopplerEnabled.setter
    def dopplerEnabled(self, dopplerEnabled):
        if  dopplerEnabled is None:
            dopplerEnabled = False  # default
        assertValidSFBool(dopplerEnabled)
        self.__dopplerEnabled = dopplerEnabled
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def enableHRTF(self):
        """enableHRTF enables/disables Head Related Transfer Function (HRTF) auralization, if available."""
        return self.__enableHRTF
    @enableHRTF.setter
    def enableHRTF(self, enableHRTF):
        if  enableHRTF is None:
            enableHRTF = False  # default
        assertValidSFBool(enableHRTF)
        self.__enableHRTF = enableHRTF
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1  # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def intensity(self):
        """Factor [0,1] adjusting loudness (decibels) of emitted sound."""
        return self.__intensity
    @intensity.setter
    def intensity(self, intensity):
        if  intensity is None:
            intensity = 1  # default
        assertValidSFFloat(intensity)
        assertZeroToOne('intensity', intensity)
        self.__intensity = intensity
    @property # getter - - - - - - - - - -
    def location(self):
        """[0,+infinity) Position of sound ellipsoid center, relative to local coordinate system."""
        return self.__location
    @location.setter
    def location(self, location):
        if  location is None:
            location = (0, 0, 0)  # default
        assertValidSFVec3f(location)
        self.__location = location
    @property # getter - - - - - - - - - -
    def maxDistance(self):
        """[0,+infinity) maxDistance is the maximum distance where sound is renderable between source and listener, after which no reduction in sound volume occurs."""
        return self.__maxDistance
    @maxDistance.setter
    def maxDistance(self, maxDistance):
        if  maxDistance is None:
            maxDistance = 10000  # default
        assertValidSFFloat(maxDistance)
        assertNonNegative('maxDistance', maxDistance)
        self.__maxDistance = maxDistance
    @property # getter - - - - - - - - - -
    def priority(self):
        """Player hint [0,1] if needed to choose which sounds to play."""
        return self.__priority
    @priority.setter
    def priority(self, priority):
        if  priority is None:
            priority = 0  # default
        assertValidSFFloat(priority)
        assertZeroToOne('priority', priority)
        self.__priority = priority
    @property # getter - - - - - - - - - -
    def referenceDistance(self):
        """[0,+infinity) referenceDistance for reducing volume as source moves further from the listener."""
        return self.__referenceDistance
    @referenceDistance.setter
    def referenceDistance(self, referenceDistance):
        if  referenceDistance is None:
            referenceDistance = 1  # default
        assertValidSFFloat(referenceDistance)
        assertNonNegative('referenceDistance', referenceDistance)
        self.__referenceDistance = referenceDistance
    @property # getter - - - - - - - - - -
    def rolloffFactor(self):
        """[0,+infinity) rolloffFactor indicates how quickly volume is reduced as source moves further from listener."""
        return self.__rolloffFactor
    @rolloffFactor.setter
    def rolloffFactor(self, rolloffFactor):
        if  rolloffFactor is None:
            rolloffFactor = 1  # default
        assertValidSFFloat(rolloffFactor)
        assertNonNegative('rolloffFactor', rolloffFactor)
        self.__rolloffFactor = rolloffFactor
    @property # getter - - - - - - - - - -
    def spatialize(self):
        """Whether to spatialize sound playback relative to viewer."""
        return self.__spatialize
    @spatialize.setter
    def spatialize(self, spatialize):
        if  spatialize is None:
            spatialize = True  # default
        assertValidSFBool(spatialize)
        self.__spatialize = spatialize
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DSoundChannelNode|X3DSoundProcessingNode|X3DSoundSourceNode] The children field specifies audio-graph sound sources providing input signals for this node."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class Sphere(_X3DGeometryNode):
    """
    Sphere is a geometry node, representing a perfectly round geometrical object that is the surface of a completely round ball.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Sphere'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry3D.html#Sphere'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Sphere'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('radius', 1, FieldType.SFFloat, AccessType.initializeOnly, 'Sphere'),
        ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'Sphere'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        radius=1,
        solid=True,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Sphere __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.radius = radius
        self.solid = solid
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def radius(self):
        """(0,+infinity) Size in meters."""
        return self.__radius
    @radius.setter
    def radius(self, radius):
        if  radius is None:
            radius = 1  # default
        assertValidSFFloat(radius)
        assertPositive('radius', radius)
        self.__radius = radius
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class SphereSensor(_X3DDragSensorNode):
    """
    SphereSensor converts pointing device motion into a spherical rotation about the origin of the local coordinate system.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'SphereSensor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/pointingDeviceSensor.html#SphereSensor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SphereSensor'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('autoOffset', True, FieldType.SFBool, AccessType.inputOutput, 'X3DDragSensorNode'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSensorNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('offset', (0, 1, 0, 0), FieldType.SFRotation, AccessType.inputOutput, 'SphereSensor'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        autoOffset=True,
        description='',
        enabled=True,
        offset=(0, 1, 0, 0),
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode SphereSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.autoOffset = autoOffset
        self.description = description
        self.enabled = enabled
        self.offset = offset
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def autoOffset(self):
        """Determines whether previous offset values are remembered/accumulated."""
        return self.__autoOffset
    @autoOffset.setter
    def autoOffset(self, autoOffset):
        if  autoOffset is None:
            autoOffset = True  # default
        assertValidSFBool(autoOffset)
        self.__autoOffset = autoOffset
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def offset(self):
        """Sends event and remembers last value sensed."""
        return self.__offset
    @offset.setter
    def offset(self, offset):
        if  offset is None:
            offset = (0, 1, 0, 0)  # default
        assertValidSFRotation(offset)
        self.__offset = offset
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class SplinePositionInterpolator(_X3DInterpolatorNode):
    """
    SplinePositionInterpolator performs non-linear interpolation among paired lists of 3-tuple values and velocities to produce an SFVec3f value_changed output event.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'SplinePositionInterpolator'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#SplinePositionInterpolator'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SplinePositionInterpolator'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('closed', False, FieldType.SFBool, AccessType.inputOutput, 'SplinePositionInterpolator'),
        ('key', [], FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
        ('keyValue', [], FieldType.MFVec3f, AccessType.inputOutput, 'SplinePositionInterpolator'),
        ('keyVelocity', [], FieldType.MFVec3f, AccessType.inputOutput, 'SplinePositionInterpolator'),
        ('normalizeVelocity', False, FieldType.SFBool, AccessType.inputOutput, 'SplinePositionInterpolator'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        closed=False,
        key=None,
        keyValue=None,
        keyVelocity=None,
        normalizeVelocity=False,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode SplinePositionInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.closed = closed
        self.key = key
        self.keyValue = keyValue
        self.keyVelocity = keyVelocity
        self.normalizeVelocity = normalizeVelocity
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def closed(self):
        """Whether or not the curve is closed (i."""
        return self.__closed
    @closed.setter
    def closed(self, closed):
        if  closed is None:
            closed = False  # default
        assertValidSFBool(closed)
        self.__closed = closed
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition parameters for nonlinear-interpolation function time intervals, listed in non-decreasing order and corresponding to keyValue, keyVelocity array values."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for nonlinear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFVec3f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec3f.DEFAULT_VALUE()))
        assertValidMFVec3f(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def keyVelocity(self):
        """Output values for nonlinear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyVelocity
    @keyVelocity.setter
    def keyVelocity(self, keyVelocity):
        if  keyVelocity is None:
            keyVelocity = MFVec3f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec3f.DEFAULT_VALUE()))
        assertValidMFVec3f(keyVelocity)
        self.__keyVelocity = keyVelocity
    @property # getter - - - - - - - - - -
    def normalizeVelocity(self):
        """normalizeVelocity field specifies whether the velocity vectors are normalized to produce smooth speed transitions, or transformed into tangency vectors."""
        return self.__normalizeVelocity
    @normalizeVelocity.setter
    def normalizeVelocity(self, normalizeVelocity):
        if  normalizeVelocity is None:
            normalizeVelocity = False  # default
        assertValidSFBool(normalizeVelocity)
        self.__normalizeVelocity = normalizeVelocity
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class SplinePositionInterpolator2D(_X3DInterpolatorNode):
    """
    SplinePositionInterpolator2D performs non-linear interpolation among paired lists of 2-tuple values and velocities to produce an SFVec2f value_changed output event.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'SplinePositionInterpolator2D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#SplinePositionInterpolator2D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SplinePositionInterpolator2D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('closed', False, FieldType.SFBool, AccessType.inputOutput, 'SplinePositionInterpolator2D'),
        ('key', [], FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
        ('keyValue', [], FieldType.MFVec2f, AccessType.inputOutput, 'SplinePositionInterpolator2D'),
        ('keyVelocity', [], FieldType.MFVec2f, AccessType.inputOutput, 'SplinePositionInterpolator2D'),
        ('normalizeVelocity', False, FieldType.SFBool, AccessType.inputOutput, 'SplinePositionInterpolator2D'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        closed=False,
        key=None,
        keyValue=None,
        keyVelocity=None,
        normalizeVelocity=False,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode SplinePositionInterpolator2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.closed = closed
        self.key = key
        self.keyValue = keyValue
        self.keyVelocity = keyVelocity
        self.normalizeVelocity = normalizeVelocity
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def closed(self):
        """Whether or not the curve is closed (i."""
        return self.__closed
    @closed.setter
    def closed(self, closed):
        if  closed is None:
            closed = False  # default
        assertValidSFBool(closed)
        self.__closed = closed
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition parameters for nonlinear-interpolation function time intervals, listed in non-decreasing order and corresponding to keyValue, keyVelocity array values."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for nonlinear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFVec2f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec2f.DEFAULT_VALUE()))
        assertValidMFVec2f(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def keyVelocity(self):
        """Output values for nonlinear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyVelocity
    @keyVelocity.setter
    def keyVelocity(self, keyVelocity):
        if  keyVelocity is None:
            keyVelocity = MFVec2f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec2f.DEFAULT_VALUE()))
        assertValidMFVec2f(keyVelocity)
        self.__keyVelocity = keyVelocity
    @property # getter - - - - - - - - - -
    def normalizeVelocity(self):
        """normalizeVelocity field specifies whether the velocity vectors are normalized to produce smooth speed transitions, or transformed into tangency vectors."""
        return self.__normalizeVelocity
    @normalizeVelocity.setter
    def normalizeVelocity(self, normalizeVelocity):
        if  normalizeVelocity is None:
            normalizeVelocity = False  # default
        assertValidSFBool(normalizeVelocity)
        self.__normalizeVelocity = normalizeVelocity
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class SplineScalarInterpolator(_X3DInterpolatorNode):
    """
    SplineScalarInterpolator performs non-linear interpolation among paired lists of float values and velocities to produce an SFFloat value_changed output event.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'SplineScalarInterpolator'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#SplineScalarInterpolator'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SplineScalarInterpolator'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('closed', False, FieldType.SFBool, AccessType.inputOutput, 'SplineScalarInterpolator'),
        ('key', [], FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
        ('keyValue', [], FieldType.MFFloat, AccessType.inputOutput, 'SplineScalarInterpolator'),
        ('keyVelocity', [], FieldType.MFFloat, AccessType.inputOutput, 'SplineScalarInterpolator'),
        ('normalizeVelocity', False, FieldType.SFBool, AccessType.inputOutput, 'SplineScalarInterpolator'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        closed=False,
        key=None,
        keyValue=None,
        keyVelocity=None,
        normalizeVelocity=False,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode SplineScalarInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.closed = closed
        self.key = key
        self.keyValue = keyValue
        self.keyVelocity = keyVelocity
        self.normalizeVelocity = normalizeVelocity
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def closed(self):
        """Whether or not the curve is closed (i."""
        return self.__closed
    @closed.setter
    def closed(self, closed):
        if  closed is None:
            closed = False  # default
        assertValidSFBool(closed)
        self.__closed = closed
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition parameters for nonlinear-interpolation function time intervals, listed in non-decreasing order and corresponding to keyValue, keyVelocity array values."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for nonlinear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def keyVelocity(self):
        """Output values for nonlinear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyVelocity
    @keyVelocity.setter
    def keyVelocity(self, keyVelocity):
        if  keyVelocity is None:
            keyVelocity = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(keyVelocity)
        self.__keyVelocity = keyVelocity
    @property # getter - - - - - - - - - -
    def normalizeVelocity(self):
        """normalizeVelocity field specifies whether the velocity vectors are normalized to produce smooth speed transitions, or transformed into tangency vectors."""
        return self.__normalizeVelocity
    @normalizeVelocity.setter
    def normalizeVelocity(self, normalizeVelocity):
        if  normalizeVelocity is None:
            normalizeVelocity = False  # default
        assertValidSFBool(normalizeVelocity)
        self.__normalizeVelocity = normalizeVelocity
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class SpotLight(_X3DLightNode):
    """
    Linear attenuation may occur at level 2, full support at level 3.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'SpotLight'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/lighting.html#SpotLight'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SpotLight'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('ambientIntensity', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
        ('attenuation', (1, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'SpotLight'),
        ('beamWidth', 0.589049, FieldType.SFFloat, AccessType.inputOutput, 'SpotLight'),
        ('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'X3DLightNode'),
        ('cutOffAngle', 1.570796, FieldType.SFFloat, AccessType.inputOutput, 'SpotLight'),
        ('direction', (0, 0, -1), FieldType.SFVec3f, AccessType.inputOutput, 'SpotLight'),
        ('global_', True, FieldType.SFBool, AccessType.inputOutput, 'SpotLight'),
        ('intensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
        ('location', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'SpotLight'),
        ('on', True, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
        ('radius', 100, FieldType.SFFloat, AccessType.inputOutput, 'SpotLight'),
        ('shadowIntensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
        ('shadows', False, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        ambientIntensity=0,
        attenuation=(1, 0, 0),
        beamWidth=0.589049,
        color=(1, 1, 1),
        cutOffAngle=1.570796,
        direction=(0, 0, -1),
        global_=True,
        intensity=1,
        location=(0, 0, 0),
        on=True,
        radius=100,
        shadowIntensity=1,
        shadows=False,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode SpotLight __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ambientIntensity = ambientIntensity
        self.attenuation = attenuation
        self.beamWidth = beamWidth
        self.color = color
        self.cutOffAngle = cutOffAngle
        self.direction = direction
        self.global_ = global_
        self.intensity = intensity
        self.location = location
        self.on = on
        self.radius = radius
        self.shadowIntensity = shadowIntensity
        self.shadows = shadows
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def ambientIntensity(self):
        """[0,1] Brightness of ambient (nondirectional background) emission from the light."""
        return self.__ambientIntensity
    @ambientIntensity.setter
    def ambientIntensity(self, ambientIntensity):
        if  ambientIntensity is None:
            ambientIntensity = 0  # default
        assertValidSFFloat(ambientIntensity)
        assertZeroToOne('ambientIntensity', ambientIntensity)
        self.__ambientIntensity = ambientIntensity
    @property # getter - - - - - - - - - -
    def attenuation(self):
        """Constant, linear-distance and squared-distance dropoff factors as radial distance increases from the source."""
        return self.__attenuation
    @attenuation.setter
    def attenuation(self, attenuation):
        if  attenuation is None:
            attenuation = (1, 0, 0)  # default
        assertValidSFVec3f(attenuation)
        assertNonNegative('attenuation', attenuation)
        self.__attenuation = attenuation
    @property # getter - - - - - - - - - -
    def beamWidth(self):
        """[0,1."""
        return self.__beamWidth
    @beamWidth.setter
    def beamWidth(self, beamWidth):
        if  beamWidth is None:
            beamWidth = 0.589049  # default
        assertValidSFFloat(beamWidth)
        assertGreaterThan('beamWidth', beamWidth, 0)
        assertLessThanEquals('beamWidth', beamWidth, 1.570796)
        self.__beamWidth = beamWidth
    @property # getter - - - - - - - - - -
    def color(self):
        """[0,1] color of light, applied to colors of objects."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = (1, 1, 1)  # default
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def cutOffAngle(self):
        """[0,1."""
        return self.__cutOffAngle
    @cutOffAngle.setter
    def cutOffAngle(self, cutOffAngle):
        if  cutOffAngle is None:
            cutOffAngle = 1.570796  # default
        assertValidSFFloat(cutOffAngle)
        assertGreaterThan('cutOffAngle', cutOffAngle, 0)
        assertLessThanEquals('cutOffAngle', cutOffAngle, 1.570796)
        self.__cutOffAngle = cutOffAngle
    @property # getter - - - - - - - - - -
    def direction(self):
        """Orientation vector of light relative to local coordinate system."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (0, 0, -1)  # default
        assertValidSFVec3f(direction)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def global_(self):
        """Global lights illuminate all objects within their volume of lighting influence."""
        return self.__global_
    @global_.setter
    def global_(self, global_):
        if  global_ is None:
            global_ = True  # default
        assertValidSFBool(global_)
        self.__global_ = global_
    @property # getter - - - - - - - - - -
    def intensity(self):
        """[0,+infinity] Brightness of direct emission from the light."""
        return self.__intensity
    @intensity.setter
    def intensity(self, intensity):
        if  intensity is None:
            intensity = 1  # default
        assertValidSFFloat(intensity)
        assertNonNegative('intensity', intensity)
        self.__intensity = intensity
    @property # getter - - - - - - - - - -
    def location(self):
        """Position of light relative to local coordinate system."""
        return self.__location
    @location.setter
    def location(self, location):
        if  location is None:
            location = (0, 0, 0)  # default
        assertValidSFVec3f(location)
        self.__location = location
    @property # getter - - - - - - - - - -
    def on(self):
        """Enables/disables this light source."""
        return self.__on
    @on.setter
    def on(self, on):
        if  on is None:
            on = True  # default
        assertValidSFBool(on)
        self.__on = on
    @property # getter - - - - - - - - - -
    def radius(self):
        """Maximum effective distance of light relative to local light position, affected by ancestor scaling."""
        return self.__radius
    @radius.setter
    def radius(self, radius):
        if  radius is None:
            radius = 100  # default
        assertValidSFFloat(radius)
        assertNonNegative('radius', radius)
        self.__radius = radius
    @property # getter - - - - - - - - - -
    def shadowIntensity(self):
        """[0,1] shadowIntensity field defines how much light is obscured by shapes that cast shadows, ranging from 0 (light not obscured, no visible shadows) to 1 (light completely obscured, full-intensity shadows)."""
        return self.__shadowIntensity
    @shadowIntensity.setter
    def shadowIntensity(self, shadowIntensity):
        if  shadowIntensity is None:
            shadowIntensity = 1  # default
        assertValidSFFloat(shadowIntensity)
        assertZeroToOne('shadowIntensity', shadowIntensity)
        self.__shadowIntensity = shadowIntensity
    @property # getter - - - - - - - - - -
    def shadows(self):
        """shadows field indicates whether or not this light casts a shadow behind illuminated X3DShapeNode geometry."""
        return self.__shadows
    @shadows.setter
    def shadows(self, shadows):
        if  shadows is None:
            shadows = False  # default
        assertValidSFBool(shadows)
        self.__shadows = shadows
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class SquadOrientationInterpolator(_X3DInterpolatorNode):
    """
    SquadOrientationInterpolator performs non-linear interpolation among paired lists of rotation values to produce an SFRotation value_changed output event.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'SquadOrientationInterpolator'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#SquadOrientationInterpolator'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SquadOrientationInterpolator'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('key', [], FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
        ('keyValue', [], FieldType.MFRotation, AccessType.inputOutput, 'SquadOrientationInterpolator'),
        ('normalizeVelocity', False, FieldType.SFBool, AccessType.inputOutput, 'SquadOrientationInterpolator'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        key=None,
        keyValue=None,
        normalizeVelocity=False,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode SquadOrientationInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
        self.normalizeVelocity = normalizeVelocity
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition parameters for nonlinear-interpolation function time intervals, listed in non-decreasing order and corresponding to keyValue, keyVelocity array values."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for nonlinear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFRotation.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFRotation.DEFAULT_VALUE()))
        assertValidMFRotation(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def normalizeVelocity(self):
        """normalizeVelocity field specifies whether the velocity vectors are normalized to produce smooth speed transitions, or transformed into tangency vectors."""
        return self.__normalizeVelocity
    @normalizeVelocity.setter
    def normalizeVelocity(self, normalizeVelocity):
        if  normalizeVelocity is None:
            normalizeVelocity = False  # default
        assertValidSFBool(normalizeVelocity)
        self.__normalizeVelocity = normalizeVelocity
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class StaticGroup(_X3DChildNode, _X3DBoundedObject):
    """
    StaticGroup is similar to Group node but does not allow access to children after creation time.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'StaticGroup'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/grouping.html#StaticGroup'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#StaticGroup'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('children', [], FieldType.MFNode, AccessType.initializeOnly, 'StaticGroup'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        visible=True,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode StaticGroup __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.visible = visible
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class StreamAudioDestination(_X3DSoundDestinationNode):
    """
    StreamAudioDestination node represents the final audio destination via a media stream.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'StreamAudioDestination'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#StreamAudioDestination'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#StreamAudioDestination'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('channelCountMode', 'MAX', FieldType.SFString, AccessType.inputOutput, 'X3DSoundDestinationNode'),
        ('channelInterpretation', 'SPEAKERS', FieldType.SFString, AccessType.inputOutput, 'X3DSoundDestinationNode'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSoundNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundNode'),
        ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundDestinationNode'),
        ('mediaDeviceID', '', FieldType.SFString, AccessType.inputOutput, 'X3DSoundDestinationNode'),
        ('streamIdentifier', '', FieldType.SFString, AccessType.inputOutput, 'StreamAudioDestination'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'StreamAudioDestination'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        channelCountMode='MAX',
        channelInterpretation='SPEAKERS',
        description='',
        enabled=True,
        gain=1,
        mediaDeviceID='',
        streamIdentifier='',
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode StreamAudioDestination __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.mediaDeviceID = mediaDeviceID
        self.streamIdentifier = streamIdentifier
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'MAX'  # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'SPEAKERS'  # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1  # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def mediaDeviceID(self):
        """mediaDeviceID field provides ID parameter functionality."""
        return self.__mediaDeviceID
    @mediaDeviceID.setter
    def mediaDeviceID(self, mediaDeviceID):
        if  mediaDeviceID is None:
            mediaDeviceID = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(mediaDeviceID)
        self.__mediaDeviceID = mediaDeviceID
    @property # getter - - - - - - - - - -
    def streamIdentifier(self):
        """Stream identification TBD Hint: W3C Media Capture and Streams https://www."""
        return self.__streamIdentifier
    @streamIdentifier.setter
    def streamIdentifier(self, streamIdentifier):
        if  streamIdentifier is None:
            streamIdentifier = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(streamIdentifier)
        self.__streamIdentifier = streamIdentifier
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DSoundChannelNode|X3DSoundProcessingNode|X3DSoundSourceNode] The children field specifies audio-graph sound sources providing input signals for this node."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class StreamAudioSource(_X3DSoundSourceNode):
    """
    StreamAudioSource operates as an audio source whose media is received from a MediaStream obtained using the WebRTC or Media Capture and Streams APIs.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'StreamAudioSource'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#StreamAudioSource'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#StreamAudioSource'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('channelCountMode', 'MAX', FieldType.SFString, AccessType.inputOutput, 'StreamAudioSource'),
        ('channelInterpretation', 'SPEAKERS', FieldType.SFString, AccessType.inputOutput, 'StreamAudioSource'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundSourceNode'),
        ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundSourceNode'),
        ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('streamIdentifier', '', FieldType.SFString, AccessType.inputOutput, 'StreamAudioSource'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        channelCountMode='MAX',
        channelInterpretation='SPEAKERS',
        description='',
        enabled=True,
        gain=1,
        pauseTime=0,
        resumeTime=0,
        startTime=0,
        stopTime=0,
        streamIdentifier='',
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode StreamAudioSource __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.pauseTime = pauseTime
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
        self.streamIdentifier = streamIdentifier
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'MAX'  # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'SPEAKERS'  # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1  # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0  # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0  # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0  # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0  # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def streamIdentifier(self):
        """Stream identification TBD Hint: W3C Media Capture and Streams https://www."""
        return self.__streamIdentifier
    @streamIdentifier.setter
    def streamIdentifier(self, streamIdentifier):
        if  streamIdentifier is None:
            streamIdentifier = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(streamIdentifier)
        self.__streamIdentifier = streamIdentifier
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class StringSensor(_X3DKeyDeviceSensorNode):
    """
    StringSensor generates events as the user presses keys on the keyboard.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'StringSensor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/keyDeviceSensor.html#StringSensor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#StringSensor'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('deletionAllowed', True, FieldType.SFBool, AccessType.inputOutput, 'StringSensor'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSensorNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        deletionAllowed=True,
        description='',
        enabled=True,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode StringSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.deletionAllowed = deletionAllowed
        self.description = description
        self.enabled = enabled
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def deletionAllowed(self):
        """If deletionAllowed is true, then previously entered character in enteredText can be removed."""
        return self.__deletionAllowed
    @deletionAllowed.setter
    def deletionAllowed(self, deletionAllowed):
        if  deletionAllowed is None:
            deletionAllowed = True  # default
        assertValidSFBool(deletionAllowed)
        self.__deletionAllowed = deletionAllowed
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the node."""
        return self.__description

    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class SurfaceEmitter(_X3DParticleEmitterNode):
    """
    SurfaceEmitter generates particles from the surface of an object.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'SurfaceEmitter'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#SurfaceEmitter'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SurfaceEmitter'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('mass', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('on', True, FieldType.SFBool, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('speed', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('surfaceArea', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('variation', 0.25, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('surface', None, FieldType.SFNode, AccessType.initializeOnly, 'SurfaceEmitter'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        mass=0,
        on=True,
        speed=0,
        surfaceArea=0,
        variation=0.25,
        surface=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode SurfaceEmitter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.mass = mass
        self.on = on
        self.speed = speed
        self.surfaceArea = surfaceArea
        self.variation = variation
        self.surface = surface
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def mass(self):
        """[0,+infinity) Basic mass of each particle, defined in mass base units (default is kilograms)."""
        return self.__mass
    @mass.setter
    def mass(self, mass):
        if  mass is None:
            mass = 0  # default
        assertValidSFFloat(mass)
        assertNonNegative('mass', mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def on(self):
        """Enables/disables production of particles from this emitter node."""
        return self.__on
    @on.setter
    def on(self, on):
        if  on is None:
            on = True  # default
        assertValidSFBool(on)
        self.__on = on
    @property # getter - - - - - - - - - -
    def speed(self):
        """[0,+infinity) Initial linear speed (default is m/s) imparted to all particles along their direction of movement."""
        return self.__speed
    @speed.setter
    def speed(self, speed):
        if  speed is None:
            speed = 0  # default
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def surfaceArea(self):
        """[0,+infinity) Particle surface area in area base units (default is meters squared)."""
        return self.__surfaceArea
    @surfaceArea.setter
    def surfaceArea(self, surfaceArea):
        if  surfaceArea is None:
            surfaceArea = 0  # default
        assertValidSFFloat(surfaceArea)
        assertNonNegative('surfaceArea', surfaceArea)
        self.__surfaceArea = surfaceArea
    @property # getter - - - - - - - - - -
    def variation(self):
        """[0,+infinity) Multiplier for the randomness used to control the range of possible output values."""
        return self.__variation
    @variation.setter
    def variation(self, variation):
        if  variation is None:
            variation = 0.25  # default
        assertValidSFFloat(variation)
        assertNonNegative('variation', variation)
        self.__variation = variation
    @property # getter - - - - - - - - - -
    def surface(self):
        """[X3DGeometryNode] The geometry node provides geometry used as the emitting surface."""
        return self.__surface
    @surface.setter
    def surface(self, surface):
        if  surface is None:
            surface = None  # default
        assertValidSFNode(surface)
        if not surface is None and not isinstance(surface,(_X3DGeometryNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(surface) + ' does not match required node type (_X3DGeometryNode,ProtoInstance) and is invalid')
        self.__surface = surface
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.surface
    # output function - - - - - - - - - -

class Switch(_X3DGroupingNode):
    """
    Switch is a Grouping node that only renders one (or zero) child at a time.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Switch'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/grouping.html#Switch'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Switch'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('whichChoice', -1, FieldType.SFInt32, AccessType.inputOutput, 'Switch'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        visible=True,
        whichChoice=-1,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Switch __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.visible = visible
        self.whichChoice = whichChoice
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def whichChoice(self):
        """[-1,+infinity) Index of active child choice, counting from 0."""
        return self.__whichChoice
    @whichChoice.setter
    def whichChoice(self, whichChoice):
        if  whichChoice is None:
            whichChoice = -1  # default
        assertValidSFInt32(whichChoice)
        assertGreaterThanEquals('whichChoice', whichChoice, -1)
        self.__whichChoice = whichChoice
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class TexCoordChaser2D(_X3DChaserNode):
    """
    TexCoordChaser2D generates a series of single floating-point values that progressively change from initial value to destination value.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TexCoordChaser2D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#TexCoordChaser2D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TexCoordChaser2D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('duration', 1, FieldType.SFTime, AccessType.initializeOnly, 'X3DChaserNode'),
        ('initialDestination', [], FieldType.MFVec2f, AccessType.initializeOnly, 'TexCoordChaser2D'),
        ('initialValue', [], FieldType.MFVec2f, AccessType.initializeOnly, 'TexCoordChaser2D'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        duration=1,
        initialDestination=None,
        initialValue=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TexCoordChaser2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.duration = duration
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def duration(self):
        """[0,+infinity) duration is the time interval for filter response in seconds."""
        return self.__duration
    @duration.setter
    def duration(self, duration):
        if  duration is None:
            duration = 1  # default
        assertValidSFTime(duration)
        assertNonNegative('duration', duration)
        self.__duration = duration
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = MFVec2f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec2f.DEFAULT_VALUE()))
        assertValidMFVec2f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = MFVec2f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec2f.DEFAULT_VALUE()))
        assertValidMFVec2f(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class TexCoordDamper2D(_X3DDamperNode):
    """
    TexCoordDamper2D generates a series of 2D floating-point arrays that progressively change from initial value to destination value.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TexCoordDamper2D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#TexCoordDamper2D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TexCoordDamper2D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('initialDestination', [], FieldType.MFVec2f, AccessType.initializeOnly, 'TexCoordDamper2D'),
        ('initialValue', [], FieldType.MFVec2f, AccessType.initializeOnly, 'TexCoordDamper2D'),
        ('order', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DDamperNode'),
        ('tau', 0.3, FieldType.SFTime, AccessType.inputOutput, 'X3DDamperNode'),
        ('tolerance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DDamperNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        initialDestination=None,
        initialValue=None,
        order=3,
        tau=0.3,
        tolerance=-1,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TexCoordDamper2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.order = order
        self.tau = tau
        self.tolerance = tolerance
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = MFVec2f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec2f.DEFAULT_VALUE()))
        assertValidMFVec2f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = MFVec2f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec2f.DEFAULT_VALUE()))
        assertValidMFVec2f(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def order(self):
        """[0,5] order defines the number of internal filters (larger means smoother response, longer delay)."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3  # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 0)
        assertLessThanEquals('order', order, 5)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tau(self):
        """[0,+infinity) tau is the exponential-decay time constant for filter response in seconds."""
        return self.__tau
    @tau.setter
    def tau(self, tau):
        if  tau is None:
            tau = 0.3  # default
        assertValidSFTime(tau)
        assertNonNegative('tau', tau)
        self.__tau = tau
    @property # getter - - - - - - - - - -
    def tolerance(self):
        """[0,+infinity) or -1."""
        return self.__tolerance
    @tolerance.setter
    def tolerance(self, tolerance):
        if  tolerance is None:
            tolerance = -1  # default
        assertValidSFFloat(tolerance)
        self.__tolerance = tolerance
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class Text(_X3DGeometryNode):
    """
    Text is a 2D (flat) geometry node that can contain multiple lines of string values.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Text'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/text.html#Text'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Text'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('length', [], FieldType.MFFloat, AccessType.inputOutput, 'Text'),
        ('maxExtent', 0.0, FieldType.SFFloat, AccessType.inputOutput, 'Text'),
        ('solid', False, FieldType.SFBool, AccessType.initializeOnly, 'Text'),
        ('string', [], FieldType.MFString, AccessType.inputOutput, 'Text'),
        ('fontStyle', None, FieldType.SFNode, AccessType.inputOutput, 'Text'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        length=None,
        maxExtent=0.0,
        solid=False,
        string=None,
        fontStyle=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Text __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.length = length
        self.maxExtent = maxExtent
        self.solid = solid
        self.string = string
        self.fontStyle = fontStyle
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def length(self):
        """Array of length values for each text string in the local coordinate system."""
        return self.__length
    @length.setter
    def length(self, length):
        if  length is None:
            length = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(length)
        assertNonNegative('length', length)
        self.__length = length
    @property # getter - - - - - - - - - -
    def maxExtent(self):
        """Limits/compresses all text strings if max string length is longer than maxExtent, as measured in local coordinate system."""
        return self.__maxExtent
    @maxExtent.setter
    def maxExtent(self, maxExtent):
        if  maxExtent is None:
            maxExtent = 0.0  # default
        assertValidSFFloat(maxExtent)
        assertNonNegative('maxExtent', maxExtent)
        self.__maxExtent = maxExtent
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = False  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def string(self):
        """Single or multiple string values to present as Text."""
        return self.__string
    @string.setter
    def string(self, string):
        if  string is None:
            string = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(string)
        self.__string = string
    @property # getter - - - - - - - - - -
    def fontStyle(self):
        """[X3DFontStyleNode] The fontStyle field can contain a FontStyle or ScreenFontStyle node defining size, family, and style for presented text."""
        return self.__fontStyle
    @fontStyle.setter
    def fontStyle(self, fontStyle):
        if  fontStyle is None:
            fontStyle = None  # default
        assertValidSFNode(fontStyle)
        if not fontStyle is None and not isinstance(fontStyle,(_X3DFontStyleNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(fontStyle) + ' does not match required node type (_X3DFontStyleNode,ProtoInstance) and is invalid')
        self.__fontStyle = fontStyle
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.fontStyle or self.IS or self.metadata
    # output function - - - - - - - - - -

class TextureBackground(_X3DBackgroundNode):
    """
    TextureBackground simulates ground and sky, using vertical arrays of wraparound color values, TextureBackground can also provide backdrop texture images on all six sides.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TextureBackground'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalEffects.html#TextureBackground'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureBackground'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('groundAngle', [], FieldType.MFFloat, AccessType.inputOutput, 'X3DBackgroundNode'),
        ('groundColor', [], FieldType.MFColor, AccessType.inputOutput, 'X3DBackgroundNode'),
        ('skyAngle', [], FieldType.MFFloat, AccessType.inputOutput, 'X3DBackgroundNode'),
        ('skyColor', [(0, 0, 0)], FieldType.MFColor, AccessType.inputOutput, 'X3DBackgroundNode'),
        ('transparency', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DBackgroundNode'),
        ('backTexture', None, FieldType.SFNode, AccessType.inputOutput, 'TextureBackground'),
        ('bottomTexture', None, FieldType.SFNode, AccessType.inputOutput, 'TextureBackground'),
        ('frontTexture', None, FieldType.SFNode, AccessType.inputOutput, 'TextureBackground'),
        ('leftTexture', None, FieldType.SFNode, AccessType.inputOutput, 'TextureBackground'),
        ('rightTexture', None, FieldType.SFNode, AccessType.inputOutput, 'TextureBackground'),
        ('topTexture', None, FieldType.SFNode, AccessType.inputOutput, 'TextureBackground'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        groundAngle=None,
        groundColor=None,
        skyAngle=None,
        skyColor=None,
        transparency=0,
        backTexture=None,
        bottomTexture=None,
        frontTexture=None,
        leftTexture=None,
        rightTexture=None,
        topTexture=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TextureBackground __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.groundAngle = groundAngle
        self.groundColor = groundColor
        self.skyAngle = skyAngle
        self.skyColor = skyColor
        self.transparency = transparency
        self.backTexture = backTexture
        self.bottomTexture = bottomTexture
        self.frontTexture = frontTexture
        self.leftTexture = leftTexture
        self.rightTexture = rightTexture
        self.topTexture = topTexture
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def groundAngle(self):
        """[0,pi/2] The angle array values increase from 0."""
        return self.__groundAngle
    @groundAngle.setter
    def groundAngle(self, groundAngle):
        if  groundAngle is None:
            groundAngle = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(groundAngle)
        assertGreaterThanEquals('groundAngle', groundAngle, 0)
        assertLessThanEquals('groundAngle', groundAngle, 1.5708)
        self.__groundAngle = groundAngle
    @property # getter - - - - - - - - - -
    def groundColor(self):
        """Color of the ground at the various angles on the ground partial sphere."""
        return self.__groundColor
    @groundColor.setter
    def groundColor(self, groundColor):
        if  groundColor is None:
            groundColor = MFColor.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFColor.DEFAULT_VALUE()))
        assertValidMFColor(groundColor)
        assertZeroToOne('groundColor', groundColor)
        self.__groundColor = groundColor
    @property # getter - - - - - - - - - -
    def skyAngle(self):
        """[0,pi] The angle array values increase from 0."""
        return self.__skyAngle
    @skyAngle.setter
    def skyAngle(self, skyAngle):
        if  skyAngle is None:
            skyAngle = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(skyAngle)
        assertGreaterThanEquals('skyAngle', skyAngle, 0)
        assertLessThanEquals('skyAngle', skyAngle, 3.1416)
        self.__skyAngle = skyAngle
    @property # getter - - - - - - - - - -
    def skyColor(self):
        """Color of the sky at various angles on the sky sphere."""
        return self.__skyColor
    @skyColor.setter
    def skyColor(self, skyColor):
        if  skyColor is None:
            skyColor = [(0, 0, 0)]  # default
        assertValidMFColor(skyColor)
        assertZeroToOne('skyColor', skyColor)
        self.__skyColor = skyColor
    @property # getter - - - - - - - - - -
    def transparency(self):
        """transparency applied to texture images, enabling an X3D scene to overlay an HTML page or desktop."""
        return self.__transparency
    @transparency.setter
    def transparency(self, transparency):
        if  transparency is None:
            transparency = 0  # default
        assertValidSFFloat(transparency)
        assertZeroToOne('transparency', transparency)
        self.__transparency = transparency
    @property # getter - - - - - - - - - -
    def backTexture(self):
        """[X3DTexture2DNode|MultiTexture] Parent TextureBackground element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture MultiTexture)."""
        return self.__backTexture
    @backTexture.setter
    def backTexture(self, backTexture):
        if  backTexture is None:
            backTexture = None  # default
        assertValidSFNode(backTexture)
        if not backTexture is None and not isinstance(backTexture,(_X3DTexture2DNode,MultiTexture,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(backTexture) + ' does not match required node type (_X3DTexture2DNode,MultiTexture,ProtoInstance) and is invalid')
        self.__backTexture = backTexture
    @property # getter - - - - - - - - - -
    def bottomTexture(self):
        """[X3DTexture2DNode|MultiTexture] Parent TextureBackground element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture MultiTexture)."""
        return self.__bottomTexture
    @bottomTexture.setter
    def bottomTexture(self, bottomTexture):
        if  bottomTexture is None:
            bottomTexture = None  # default
        assertValidSFNode(bottomTexture)
        if not bottomTexture is None and not isinstance(bottomTexture,(_X3DTexture2DNode,MultiTexture,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(bottomTexture) + ' does not match required node type (_X3DTexture2DNode,MultiTexture,ProtoInstance) and is invalid')
        self.__bottomTexture = bottomTexture
    @property # getter - - - - - - - - - -
    def frontTexture(self):
        """[X3DTexture2DNode|MultiTexture] Parent TextureBackground element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture MultiTexture)."""
        return self.__frontTexture
    @frontTexture.setter
    def frontTexture(self, frontTexture):
        if  frontTexture is None:
            frontTexture = None  # default
        assertValidSFNode(frontTexture)
        if not frontTexture is None and not isinstance(frontTexture,(_X3DTexture2DNode,MultiTexture,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(frontTexture) + ' does not match required node type (_X3DTexture2DNode,MultiTexture,ProtoInstance) and is invalid')
        self.__frontTexture = frontTexture
    @property # getter - - - - - - - - - -
    def leftTexture(self):
        """[X3DTexture2DNode|MultiTexture] Parent TextureBackground element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture MultiTexture)."""
        return self.__leftTexture
    @leftTexture.setter
    def leftTexture(self, leftTexture):
        if  leftTexture is None:
            leftTexture = None  # default
        assertValidSFNode(leftTexture)
        if not leftTexture is None and not isinstance(leftTexture,(_X3DTexture2DNode,MultiTexture,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(leftTexture) + ' does not match required node type (_X3DTexture2DNode,MultiTexture,ProtoInstance) and is invalid')
        self.__leftTexture = leftTexture
    @property # getter - - - - - - - - - -
    def rightTexture(self):
        """[X3DTexture2DNode|MultiTexture] Parent TextureBackground element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture MultiTexture)."""
        return self.__rightTexture
    @rightTexture.setter
    def rightTexture(self, rightTexture):
        if  rightTexture is None:
            rightTexture = None  # default
        assertValidSFNode(rightTexture)
        if not rightTexture is None and not isinstance(rightTexture,(_X3DTexture2DNode,MultiTexture,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(rightTexture) + ' does not match required node type (_X3DTexture2DNode,MultiTexture,ProtoInstance) and is invalid')
        self.__rightTexture = rightTexture
    @property # getter - - - - - - - - - -
    def topTexture(self):
        """[X3DTexture2DNode|MultiTexture] Parent TextureBackground element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture MultiTexture)."""
        return self.__topTexture
    @topTexture.setter
    def topTexture(self, topTexture):
        if  topTexture is None:
            topTexture = None  # default
        assertValidSFNode(topTexture)
        if not topTexture is None and not isinstance(topTexture,(_X3DTexture2DNode,MultiTexture,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(topTexture) + ' does not match required node type (_X3DTexture2DNode,MultiTexture,ProtoInstance) and is invalid')
        self.__topTexture = topTexture
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.backTexture or self.bottomTexture or self.frontTexture or self.IS or self.leftTexture or self.metadata or self.rightTexture or self.topTexture
    # output function - - - - - - - - - -

class TextureCoordinate(_X3DSingleTextureCoordinateNode):
    """
    TextureCoordinate specifies 2D (s,t) texture-coordinate points, used by vertex-based geometry nodes (such as IndexedFaceSet or ElevationGrid) to map textures to vertices (and patches to NURBS surfaces).
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TextureCoordinate'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#TextureCoordinate'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureCoordinate'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('mapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DSingleTextureCoordinateNode'),
        ('point', [], FieldType.MFVec2f, AccessType.inputOutput, 'TextureCoordinate'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        mapping='',
        point=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TextureCoordinate __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.mapping = mapping
        self.point = point
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def mapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__mapping
    @mapping.setter
    def mapping(self, mapping):
        if  mapping is None:
            mapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(mapping)
        self.__mapping = mapping
    @property # getter - - - - - - - - - -
    def point(self):
        """pairs of 2D (s,t) texture coordinates, either in range [0,1] or higher if repeating."""
        return self.__point
    @point.setter
    def point(self, point):
        if  point is None:
            point = MFVec2f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec2f.DEFAULT_VALUE()))
        assertValidMFVec2f(point)
        self.__point = point
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class TextureCoordinate3D(_X3DSingleTextureCoordinateNode):
    """
    TextureCoordinate3D specifies a set of 3D texture coordinates used by vertex-based geometry nodes (such as IndexedFaceSet or ElevationGrid) to map 3D textures to vertices.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TextureCoordinate3D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texture3D.html#TextureCoordinate3D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureCoordinate3D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('mapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DSingleTextureCoordinateNode'),
        ('point', [], FieldType.MFVec3f, AccessType.inputOutput, 'TextureCoordinate3D'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        mapping='',
        point=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TextureCoordinate3D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.mapping = mapping
        self.point = point
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def mapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__mapping
    @mapping.setter
    def mapping(self, mapping):
        if  mapping is None:
            mapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(mapping)
        self.__mapping = mapping
    @property # getter - - - - - - - - - -
    def point(self):
        """triplets of 3D (s,t,r) texture coordinates, either in range [0,1] or higher if repeating."""
        return self.__point
    @point.setter
    def point(self, point):
        if  point is None:
            point = MFVec3f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec3f.DEFAULT_VALUE()))
        assertValidMFVec3f(point)
        self.__point = point
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class TextureCoordinate4D(_X3DSingleTextureCoordinateNode):
    """
    TextureCoordinate4D specifies a set of 4D (homogeneous 3D) texture coordinates used by vertex-based geometry nodes (such as IndexedFaceSet or ElevationGrid) to map 3D textures to vertices.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TextureCoordinate4D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texture3D.html#TextureCoordinate4D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureCoordinate4D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('mapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DSingleTextureCoordinateNode'),
        ('point', [], FieldType.MFVec4f, AccessType.inputOutput, 'TextureCoordinate4D'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        mapping='',
        point=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TextureCoordinate4D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.mapping = mapping
        self.point = point
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def mapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__mapping
    @mapping.setter
    def mapping(self, mapping):
        if  mapping is None:
            mapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(mapping)
        self.__mapping = mapping
    @property # getter - - - - - - - - - -
    def point(self):
        """4-tuple values of 4D texture coordinates, either in range [0,1] or higher if repeating."""
        return self.__point
    @point.setter
    def point(self, point):
        if  point is None:
            point = MFVec4f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec4f.DEFAULT_VALUE()))
        assertValidMFVec4f(point)
        self.__point = point
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class TextureCoordinateGenerator(_X3DSingleTextureCoordinateNode):
    """
    TextureCoordinateGenerator computes 2D (s,t) texture-coordinate points, used by vertex-based geometry nodes (such as IndexedFaceSet or ElevationGrid) to map textures to vertices (and patches to NURBS surfaces).
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TextureCoordinateGenerator'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#TextureCoordinateGenerator'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureCoordinateGenerator'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('mapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DSingleTextureCoordinateNode'),
        ('mode', 'SPHERE', FieldType.SFString, AccessType.inputOutput, 'TextureCoordinateGenerator'),
        ('parameter', [], FieldType.MFFloat, AccessType.inputOutput, 'TextureCoordinateGenerator'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        mapping='',
        mode='SPHERE',
        parameter=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TextureCoordinateGenerator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.mapping = mapping
        self.mode = mode
        self.parameter = parameter
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def mapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__mapping
    @mapping.setter
    def mapping(self, mapping):
        if  mapping is None:
            mapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(mapping)
        self.__mapping = mapping
    @property # getter - - - - - - - - - -
    def mode(self):
        """parameter field defines the algorithm used to compute texture coordinates."""
        return self.__mode
    @mode.setter
    def mode(self, mode):
        if  mode is None:
            mode = 'SPHERE'  # default
        assertValidSFString(mode)
        assertValidTextureCoordinateGeneratorMode('mode', mode)
        self.__mode = mode
    @property # getter - - - - - - - - - -
    def parameter(self):
        """parameter array contains scale and translation (x y z) values for Perlin NOISE mode, parameter[0] contains index of refraction for SPHERE-REFLECT mode, parameter[0] contains index of refraction and parameter[1 to 3] contains the eye point in local coordinates for SPHERE-REFLECT-LOCAL mode."""
        return self.__parameter
    @parameter.setter
    def parameter(self, parameter):
        if  parameter is None:
            parameter = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(parameter)
        self.__parameter = parameter
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class TextureProjector(_X3DTextureProjectorNode):
    """
    TextureProjector is similar to a light that projects a texture into the scene, illuminating geometry that intersects the perspective projection volume.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TextureProjector'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/textureProjector.html#TextureProjector'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureProjector'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('ambientIntensity', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
        ('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'X3DLightNode'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureProjectorNode'),
        ('direction', (0, 0, 1), FieldType.SFVec3f, AccessType.inputOutput, 'X3DTextureProjectorNode'),
        ('farDistance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DTextureProjectorNode'),
        ('fieldOfView', 0.7854, FieldType.SFFloat, AccessType.inputOutput, 'TextureProjector'),
        ('global_', True, FieldType.SFBool, AccessType.inputOutput, 'X3DTextureProjectorNode'),
        ('intensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
        ('location', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'X3DTextureProjectorNode'),
        ('nearDistance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DTextureProjectorNode'),
        ('on', True, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
        ('shadowIntensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
        ('shadows', False, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
        ('upVector', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'X3DTextureProjectorNode'),
        ('texture', None, FieldType.SFNode, AccessType.inputOutput, 'X3DTextureProjectorNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        ambientIntensity=0,
        color=(1, 1, 1),
        description='',
        direction=(0, 0, 1),
        farDistance=-1,
        fieldOfView=0.7854,
        global_=True,
        intensity=1,
        location=(0, 0, 0),
        nearDistance=-1,
        on=True,
        shadowIntensity=1,
        shadows=False,
        upVector=(0, 1, 0),
        texture=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TextureProjector __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ambientIntensity = ambientIntensity
        self.color = color
        self.description = description
        self.direction = direction
        self.farDistance = farDistance
        self.fieldOfView = fieldOfView
        self.global_ = global_
        self.intensity = intensity
        self.location = location
        self.nearDistance = nearDistance
        self.on = on
        self.shadowIntensity = shadowIntensity
        self.shadows = shadows
        self.upVector = upVector
        self.texture = texture
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def ambientIntensity(self):
        """[0,1] Brightness of ambient (nondirectional background) emission from the light."""
        return self.__ambientIntensity
    @ambientIntensity.setter
    def ambientIntensity(self, ambientIntensity):
        if  ambientIntensity is None:
            ambientIntensity = 0  # default
        assertValidSFFloat(ambientIntensity)
        assertZeroToOne('ambientIntensity', ambientIntensity)
        self.__ambientIntensity = ambientIntensity
    @property # getter - - - - - - - - - -
    def color(self):
        """[0,1] color of light, applied to colors of objects."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = (1, 1, 1)  # default
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def direction(self):
        """Direction for projection."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (0, 0, 1)  # default
        assertValidSFVec3f(direction)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def farDistance(self):
        """or (0,+infinity) maximum distance necessary for texture display."""
        return self.__farDistance
    @farDistance.setter
    def farDistance(self, farDistance):
        if  farDistance is None:
            farDistance = -1  # default
        assertValidSFFloat(farDistance)
        assertGreaterThanEquals('farDistance', farDistance, -1)
        self.__farDistance = farDistance
    @property # getter - - - - - - - - - -
    def fieldOfView(self):
        """Preferred minimum viewing angle for this projection in radians, providing minimum height or minimum width (whichever is smaller)."""
        return self.__fieldOfView
    @fieldOfView.setter
    def fieldOfView(self, fieldOfView):
        if  fieldOfView is None:
            fieldOfView = 0.7854  # default
        assertValidSFFloat(fieldOfView)
        assertGreaterThanEquals('fieldOfView', fieldOfView, 0)
        assertLessThanEquals('fieldOfView', fieldOfView, 3.1416)
        self.__fieldOfView = fieldOfView
    @property # getter - - - - - - - - - -
    def global_(self):
        """Global texture projection illuminates all objects within their volume of influence."""
        return self.__global_
    @global_.setter
    def global_(self, global_):
        if  global_ is None:
            global_ = True  # default
        assertValidSFBool(global_)
        self.__global_ = global_
    @property # getter - - - - - - - - - -
    def intensity(self):
        """[0,1] Brightness of direct emission from the light."""
        return self.__intensity
    @intensity.setter
    def intensity(self, intensity):
        if  intensity is None:
            intensity = 1  # default
        assertValidSFFloat(intensity)
        assertNonNegative('intensity', intensity)
        self.__intensity = intensity
    @property # getter - - - - - - - - - -
    def location(self):
        """Position of center of texture projection relative to local coordinate system."""
        return self.__location
    @location.setter
    def location(self, location):
        if  location is None:
            location = (0, 0, 0)  # default
        assertValidSFVec3f(location)
        self.__location = location
    @property # getter - - - - - - - - - -
    def nearDistance(self):
        """or (0,+infinity) minimum distance necessary for texture display."""
        return self.__nearDistance
    @nearDistance.setter
    def nearDistance(self, nearDistance):
        if  nearDistance is None:
            nearDistance = -1  # default
        assertValidSFFloat(nearDistance)
        assertGreaterThanEquals('nearDistance', nearDistance, -1)
        self.__nearDistance = nearDistance
    @property # getter - - - - - - - - - -
    def on(self):
        """Enables/disables this texture projection source."""
        return self.__on
    @on.setter
    def on(self, on):
        if  on is None:
            on = True  # default
        assertValidSFBool(on)
        self.__on = on
    @property # getter - - - - - - - - - -
    def shadowIntensity(self):
        """[0,1] shadowIntensity field defines how much light is obscured by shapes that cast shadows, ranging from 0 (light not obscured, no visible shadows) to 1 (light completely obscured, full-intensity shadows)."""
        return self.__shadowIntensity
    @shadowIntensity.setter
    def shadowIntensity(self, shadowIntensity):
        if  shadowIntensity is None:
            shadowIntensity = 1  # default
        assertValidSFFloat(shadowIntensity)
        assertZeroToOne('shadowIntensity', shadowIntensity)
        self.__shadowIntensity = shadowIntensity
    @property # getter - - - - - - - - - -
    def shadows(self):
        """shadows field indicates whether or not this light casts a shadow behind illuminated X3DShapeNode geometry."""
        return self.__shadows
    @shadows.setter
    def shadows(self, shadows):
        if  shadows is None:
            shadows = False  # default
        assertValidSFBool(shadows)
        self.__shadows = shadows
    @property # getter - - - - - - - - - -
    def upVector(self):
        """upVector describes the roll of the camera by defining which direction is up for the camera's orientation."""
        return self.__upVector
    @upVector.setter
    def upVector(self, upVector):
        if  upVector is None:
            upVector = (0, 1, 0)  # default
        assertValidSFVec3f(upVector)
        self.__upVector = upVector
    @property # getter - - - - - - - - - -
    def texture(self):
        """[X3DTextureNode] Single contained texture node (ImageTexture, MovieTexture, PixelTexture, MultiTexture) that maps image(s) to surface geometry."""
        return self.__texture
    @texture.setter
    def texture(self, texture):
        if  texture is None:
            texture = None  # default
        assertValidSFNode(texture)
        if not texture is None and not isinstance(texture,(_X3DTexture2DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(texture) + ' does not match required node type (_X3DTexture2DNode,ProtoInstance) and is invalid')
        self.__texture = texture
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.texture
    # output function - - - - - - - - - -

class TextureProjectorParallel(_X3DTextureProjectorNode):
    """
    TextureProjectorParallel is similar to a light that projects a texture into the scene, illuminating geometry that intersects the parallel projection volume.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TextureProjectorParallel'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/textureProjector.html#TextureProjectorParallel'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureProjectorParallel'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('ambientIntensity', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
        ('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'X3DLightNode'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureProjectorNode'),
        ('direction', (0, 0, 1), FieldType.SFVec3f, AccessType.inputOutput, 'X3DTextureProjectorNode'),
        ('farDistance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DTextureProjectorNode'),
        ('fieldOfView', (-1, -1, 1, 1), FieldType.SFVec4f, AccessType.inputOutput, 'TextureProjectorParallel'),
        ('global_', True, FieldType.SFBool, AccessType.inputOutput, 'X3DTextureProjectorNode'),
        ('intensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
        ('location', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'X3DTextureProjectorNode'),
        ('nearDistance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DTextureProjectorNode'),
        ('on', True, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
        ('shadowIntensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
        ('shadows', False, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
        ('upVector', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'X3DTextureProjectorNode'),
        ('texture', None, FieldType.SFNode, AccessType.inputOutput, 'X3DTextureProjectorNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        ambientIntensity=0,
        color=(1, 1, 1),
        description='',
        direction=(0, 0, 1),
        farDistance=-1,
        fieldOfView=(-1, -1, 1, 1),
        global_=True,
        intensity=1,
        location=(0, 0, 0),
        nearDistance=-1,
        on=True,
        shadowIntensity=1,
        shadows=False,
        upVector=(0, 1, 0),
        texture=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TextureProjectorParallel __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ambientIntensity = ambientIntensity
        self.color = color
        self.description = description
        self.direction = direction
        self.farDistance = farDistance
        self.fieldOfView = fieldOfView
        self.global_ = global_
        self.intensity = intensity
        self.location = location
        self.nearDistance = nearDistance
        self.on = on
        self.shadowIntensity = shadowIntensity
        self.shadows = shadows
        self.upVector = upVector
        self.texture = texture
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def ambientIntensity(self):
        """[0,1] Brightness of ambient (nondirectional background) emission from the light."""
        return self.__ambientIntensity
    @ambientIntensity.setter
    def ambientIntensity(self, ambientIntensity):
        if  ambientIntensity is None:
            ambientIntensity = 0  # default
        assertValidSFFloat(ambientIntensity)
        assertZeroToOne('ambientIntensity', ambientIntensity)
        self.__ambientIntensity = ambientIntensity
    @property # getter - - - - - - - - - -
    def color(self):
        """[0,1] color of light, applied to colors of objects."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = (1, 1, 1)  # default
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def direction(self):
        """Direction for projection."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (0, 0, 1)  # default
        assertValidSFVec3f(direction)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def farDistance(self):
        """or (0,+infinity) maximum distance necessary for texture display."""
        return self.__farDistance
    @farDistance.setter
    def farDistance(self, farDistance):
        if  farDistance is None:
            farDistance = -1  # default
        assertValidSFFloat(farDistance)
        assertGreaterThanEquals('farDistance', farDistance, -1)
        self.__farDistance = farDistance
    @property # getter - - - - - - - - - -
    def fieldOfView(self):
        """Minimum and maximum extents of projection texture in units of local coordinate system."""
        return self.__fieldOfView
    @fieldOfView.setter
    def fieldOfView(self, fieldOfView):
        if  fieldOfView is None:
            fieldOfView = (-1, -1, 1, 1)  # default
        assertValidSFVec4f(fieldOfView)
        self.__fieldOfView = fieldOfView
    @property # getter - - - - - - - - - -
    def global_(self):
        """Global texture projection illuminates all objects within their volume of influence."""
        return self.__global_
    @global_.setter
    def global_(self, global_):
        if  global_ is None:
            global_ = True  # default
        assertValidSFBool(global_)
        self.__global_ = global_
    @property # getter - - - - - - - - - -
    def intensity(self):
        """[0,1] Brightness of direct emission from the light."""
        return self.__intensity
    @intensity.setter
    def intensity(self, intensity):
        if  intensity is None:
            intensity = 1  # default
        assertValidSFFloat(intensity)
        assertNonNegative('intensity', intensity)
        self.__intensity = intensity
    @property # getter - - - - - - - - - -
    def location(self):
        """Position of center of texture projection relative to local coordinate system."""
        return self.__location
    @location.setter
    def location(self, location):
        if  location is None:
            location = (0, 0, 0)  # default
        assertValidSFVec3f(location)
        self.__location = location
    @property # getter - - - - - - - - - -
    def nearDistance(self):
        """or (0,+infinity) minimum distance necessary for texture display."""
        return self.__nearDistance
    @nearDistance.setter
    def nearDistance(self, nearDistance):
        if  nearDistance is None:
            nearDistance = -1  # default
        assertValidSFFloat(nearDistance)
        assertGreaterThanEquals('nearDistance', nearDistance, -1)
        self.__nearDistance = nearDistance
    @property # getter - - - - - - - - - -
    def on(self):
        """Enables/disables this texture projection source."""
        return self.__on
    @on.setter
    def on(self, on):
        if  on is None:
            on = True  # default
        assertValidSFBool(on)
        self.__on = on
    @property # getter - - - - - - - - - -
    def shadowIntensity(self):
        """[0,1] shadowIntensity field defines how much light is obscured by shapes that cast shadows, ranging from 0 (light not obscured, no visible shadows) to 1 (light completely obscured, full-intensity shadows)."""
        return self.__shadowIntensity
    @shadowIntensity.setter
    def shadowIntensity(self, shadowIntensity):
        if  shadowIntensity is None:
            shadowIntensity = 1  # default
        assertValidSFFloat(shadowIntensity)
        assertZeroToOne('shadowIntensity', shadowIntensity)
        self.__shadowIntensity = shadowIntensity
    @property # getter - - - - - - - - - -
    def shadows(self):
        """shadows field indicates whether or not this light casts a shadow behind illuminated X3DShapeNode geometry."""
        return self.__shadows
    @shadows.setter
    def shadows(self, shadows):
        if  shadows is None:
            shadows = False  # default
        assertValidSFBool(shadows)
        self.__shadows = shadows
    @property # getter - - - - - - - - - -
    def upVector(self):
        """upVector describes the roll of the camera by defining which direction is up for the camera's orientation."""
        return self.__upVector
    @upVector.setter
    def upVector(self, upVector):
        if  upVector is None:
            upVector = (0, 1, 0)  # default
        assertValidSFVec3f(upVector)
        self.__upVector = upVector
    @property # getter - - - - - - - - - -
    def texture(self):
        """[X3DTextureNode] Single contained texture node (ImageTexture, MovieTexture, PixelTexture, MultiTexture) that maps image(s) to surface geometry."""
        return self.__texture
    @texture.setter
    def texture(self, texture):
        if  texture is None:
            texture = None  # default
        assertValidSFNode(texture)
        if not texture is None and not isinstance(texture,(_X3DTexture2DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(texture) + ' does not match required node type (_X3DTexture2DNode,ProtoInstance) and is invalid')
        self.__texture = texture
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.texture
    # output function - - - - - - - - - -

class TextureProperties(_X3DNode):
    """
    TextureProperties allows precise fine-grained control over application of image textures to geometry.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TextureProperties'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#TextureProperties'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureProperties'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('anisotropicDegree', 1, FieldType.SFFloat, AccessType.inputOutput, 'TextureProperties'),
        ('borderColor', (0, 0, 0, 0), FieldType.SFColorRGBA, AccessType.inputOutput, 'TextureProperties'),
        ('borderWidth', 0, FieldType.SFInt32, AccessType.inputOutput, 'TextureProperties'),
        ('boundaryModeR', 'REPEAT', FieldType.SFString, AccessType.inputOutput, 'TextureProperties'),
        ('boundaryModeS', 'REPEAT', FieldType.SFString, AccessType.inputOutput, 'TextureProperties'),
        ('boundaryModeT', 'REPEAT', FieldType.SFString, AccessType.inputOutput, 'TextureProperties'),
        ('generateMipMaps', False, FieldType.SFBool, AccessType.initializeOnly, 'TextureProperties'),
        ('magnificationFilter', 'FASTEST', FieldType.SFString, AccessType.inputOutput, 'TextureProperties'),
        ('minificationFilter', 'FASTEST', FieldType.SFString, AccessType.inputOutput, 'TextureProperties'),
        ('textureCompression', 'FASTEST', FieldType.SFString, AccessType.inputOutput, 'TextureProperties'),
        ('texturePriority', 0, FieldType.SFFloat, AccessType.inputOutput, 'TextureProperties'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        anisotropicDegree=1,
        borderColor=(0, 0, 0, 0),
        borderWidth=0,
        boundaryModeR='REPEAT',
        boundaryModeS='REPEAT',
        boundaryModeT='REPEAT',
        generateMipMaps=False,
        magnificationFilter='FASTEST',
        minificationFilter='FASTEST',
        textureCompression='FASTEST',
        texturePriority=0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TextureProperties __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.anisotropicDegree = anisotropicDegree
        self.borderColor = borderColor
        self.borderWidth = borderWidth
        self.boundaryModeR = boundaryModeR
        self.boundaryModeS = boundaryModeS
        self.boundaryModeT = boundaryModeT
        self.generateMipMaps = generateMipMaps
        self.magnificationFilter = magnificationFilter
        self.minificationFilter = minificationFilter
        self.textureCompression = textureCompression
        self.texturePriority = texturePriority
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def anisotropicDegree(self):
        """[1,+infinity) anisotropicDegree defines minimum degree of anisotropy to account for in texture filtering (1=no effect for symmetric filtering, otherwise provide higher value)."""
        return self.__anisotropicDegree
    @anisotropicDegree.setter
    def anisotropicDegree(self, anisotropicDegree):
        if  anisotropicDegree is None:
            anisotropicDegree = 1  # default
        assertValidSFFloat(anisotropicDegree)
        assertGreaterThanEquals('anisotropicDegree', anisotropicDegree, 1)
        self.__anisotropicDegree = anisotropicDegree
    @property # getter - - - - - - - - - -
    def borderColor(self):
        """[0,1] borderColor defines border pixel color."""
        return self.__borderColor
    @borderColor.setter
    def borderColor(self, borderColor):
        if  borderColor is None:
            borderColor = (0, 0, 0, 0)  # default
        assertValidSFColorRGBA(borderColor)
        assertZeroToOne('borderColor', borderColor)
        self.__borderColor = borderColor
    @property # getter - - - - - - - - - -
    def borderWidth(self):
        """[0,+infinity) borderWidth number of pixels for texture border."""
        return self.__borderWidth
    @borderWidth.setter
    def borderWidth(self, borderWidth):
        if  borderWidth is None:
            borderWidth = 0  # default
        assertValidSFInt32(borderWidth)
        assertNonNegative('borderWidth', borderWidth)
        self.__borderWidth = borderWidth
    @property # getter - - - - - - - - - -
    def boundaryModeR(self):
        """boundaryModeR describes handling of texture-coordinate boundaries."""
        return self.__boundaryModeR
    @boundaryModeR.setter
    def boundaryModeR(self, boundaryModeR):
        if  boundaryModeR is None:
            boundaryModeR = 'REPEAT'  # default
        assertValidSFString(boundaryModeR)
        assertValidTextureBoundaryMode('boundaryModeR', boundaryModeR)
        self.__boundaryModeR = boundaryModeR
    @property # getter - - - - - - - - - -
    def boundaryModeS(self):
        """boundaryModeS describes handling of texture-coordinate boundaries."""
        return self.__boundaryModeS
    @boundaryModeS.setter
    def boundaryModeS(self, boundaryModeS):
        if  boundaryModeS is None:
            boundaryModeS = 'REPEAT'  # default
        assertValidSFString(boundaryModeS)
        assertValidTextureBoundaryMode('boundaryModeS', boundaryModeS)
        self.__boundaryModeS = boundaryModeS
    @property # getter - - - - - - - - - -
    def boundaryModeT(self):
        """boundaryModeT describes handling of texture-coordinate boundaries."""
        return self.__boundaryModeT
    @boundaryModeT.setter
    def boundaryModeT(self, boundaryModeT):
        if  boundaryModeT is None:
            boundaryModeT = 'REPEAT'  # default
        assertValidSFString(boundaryModeT)
        assertValidTextureBoundaryMode('boundaryModeT', boundaryModeT)
        self.__boundaryModeT = boundaryModeT
    @property # getter - - - - - - - - - -
    def generateMipMaps(self):
        """Determines whether MIPMAPs are generated for texture images."""
        return self.__generateMipMaps
    @generateMipMaps.setter
    def generateMipMaps(self, generateMipMaps):
        if  generateMipMaps is None:
            generateMipMaps = False  # default
        assertValidSFBool(generateMipMaps)
        self.__generateMipMaps = generateMipMaps
    @property # getter - - - - - - - - - -
    def magnificationFilter(self):
        """magnificationFilter indicates texture filter when image is smaller than screen space representation."""
        return self.__magnificationFilter
    @magnificationFilter.setter
    def magnificationFilter(self, magnificationFilter):
        if  magnificationFilter is None:
            magnificationFilter = 'FASTEST'  # default
        assertValidSFString(magnificationFilter)
        assertValidTextureMagnificationMode('magnificationFilter', magnificationFilter)
        self.__magnificationFilter = magnificationFilter
    @property # getter - - - - - - - - - -
    def minificationFilter(self):
        """minificationFilter indicates texture filter when image is larger than screen space representation."""
        return self.__minificationFilter
    @minificationFilter.setter
    def minificationFilter(self, minificationFilter):
        if  minificationFilter is None:
            minificationFilter = 'FASTEST'  # default
        assertValidSFString(minificationFilter)
        assertValidTextureMinificationMode('minificationFilter', minificationFilter)
        self.__minificationFilter = minificationFilter
    @property # getter - - - - - - - - - -
    def textureCompression(self):
        """textureCompression indicates compression algorithm selection mode."""
        return self.__textureCompression
    @textureCompression.setter
    def textureCompression(self, textureCompression):
        if  textureCompression is None:
            textureCompression = 'FASTEST'  # default
        assertValidSFString(textureCompression)
        assertValidTextureCompressionMode('textureCompression', textureCompression)
        self.__textureCompression = textureCompression
    @property # getter - - - - - - - - - -
    def texturePriority(self):
        """[0,1] texturePriority defines relative priority for this texture when allocating texture memory, an important rendering resource in graphics-card hardware."""
        return self.__texturePriority
    @texturePriority.setter
    def texturePriority(self, texturePriority):
        if  texturePriority is None:
            texturePriority = 0  # default
        assertValidSFFloat(texturePriority)
        assertZeroToOne('texturePriority', texturePriority)
        self.__texturePriority = texturePriority
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class TextureTransform(_X3DTextureTransformNode):
    """
    TextureTransform shifts 2D texture coordinates for positioning, orienting and scaling image textures on geometry.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TextureTransform'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#TextureTransform'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureTransform'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('center', (0, 0), FieldType.SFVec2f, AccessType.inputOutput, 'TextureTransform'),
        ('mapping', '', FieldType.SFString, AccessType.inputOutput, 'TextureTransform'),
        ('rotation', 0, FieldType.SFFloat, AccessType.inputOutput, 'TextureTransform'),
        ('scale', (1, 1), FieldType.SFVec2f, AccessType.inputOutput, 'TextureTransform'),
        ('translation', (0, 0), FieldType.SFVec2f, AccessType.inputOutput, 'TextureTransform'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        center=(0, 0),
        mapping='',
        rotation=0,
        scale=(1, 1),
        translation=(0, 0),
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TextureTransform __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.center = center
        self.mapping = mapping
        self.rotation = rotation
        self.scale = scale
        self.translation = translation
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def center(self):
        """center point in 2D (s,t) texture coordinates for rotation and scaling."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0)  # default
        assertValidSFVec2f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def mapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__mapping
    @mapping.setter
    def mapping(self, mapping):
        if  mapping is None:
            mapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(mapping)
        self.__mapping = mapping
    @property # getter - - - - - - - - - -
    def rotation(self):
        """single rotation angle of texture about center (opposite effect appears on geometry)."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = 0  # default
        assertValidSFFloat(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        """Non-uniform planar scaling of texture about center (opposite effect appears on geometry)."""
        return self.__scale
    @scale.setter
    def scale(self, scale):
        if  scale is None:
            scale = (1, 1)  # default
        assertValidSFVec2f(scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def translation(self):
        """Lateral/vertical shift in 2D (s,t) texture coordinates (opposite effect appears on geometry)."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0)  # default
        assertValidSFVec2f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class TextureTransform3D(_X3DTextureTransformNode):
    """
    TextureTransform3D applies a 3D transformation to texture coordinates.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TextureTransform3D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texture3D.html#TextureTransform3D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureTransform3D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'TextureTransform3D'),
        ('mapping', '', FieldType.SFString, AccessType.inputOutput, 'TextureTransform3D'),
        ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'TextureTransform3D'),
        ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'TextureTransform3D'),
        ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'TextureTransform3D'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        center=(0, 0, 0),
        mapping='',
        rotation=(0, 0, 1, 0),
        scale=(1, 1, 1),
        translation=(0, 0, 0),
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TextureTransform3D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.center = center
        self.mapping = mapping
        self.rotation = rotation
        self.scale = scale
        self.translation = translation
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def center(self):
        """center point in 2D (s,t) texture coordinates for rotation and scaling."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0)  # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def mapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__mapping
    @mapping.setter
    def mapping(self, mapping):
        if  mapping is None:
            mapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(mapping)
        self.__mapping = mapping
    @property # getter - - - - - - - - - -
    def rotation(self):
        """rotation angle of texture about center (opposite effect appears on geometry)."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = (0, 0, 1, 0)  # default
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        """Non-uniform planar scaling of texture about center (opposite effect appears on geometry)."""
        return self.__scale
    @scale.setter
    def scale(self, scale):
        if  scale is None:
            scale = (1, 1, 1)  # default
        assertValidSFVec3f(scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def translation(self):
        """Lateral/vertical shift in 2D (s,t) texture coordinates (opposite effect appears on geometry)."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0, 0)  # default
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class TextureTransformMatrix3D(_X3DTextureTransformNode):
    """
    TextureTransformMatrix3D applies a 3D transformation to texture coordinates.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TextureTransformMatrix3D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texture3D.html#TextureTransformMatrix3D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureTransformMatrix3D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('mapping', '', FieldType.SFString, AccessType.inputOutput, 'TextureTransformMatrix3D'),
        ('matrix', (1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), FieldType.SFMatrix4f, AccessType.inputOutput, 'TextureTransformMatrix3D'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        mapping='',
        matrix=(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TextureTransformMatrix3D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.mapping = mapping
        self.matrix = matrix
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def mapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__mapping
    @mapping.setter
    def mapping(self, mapping):
        if  mapping is None:
            mapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(mapping)
        self.__mapping = mapping
    @property # getter - - - - - - - - - -
    def matrix(self):
        """matrix is a generalized, unfiltered 4x4 transformation matrix to modify texture (opposite effect appears on geometry)."""
        return self.__matrix
    @matrix.setter
    def matrix(self, matrix):
        if  matrix is None:
            matrix = (1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)  # default
        assertValidSFMatrix4f(matrix)
        self.__matrix = matrix
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class TimeSensor(_X3DTimeDependentNode, _X3DSensorNode):
    """
    TimeSensor continuously generates events as time passes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TimeSensor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/time.html#TimeSensor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TimeSensor'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('cycleInterval', 1.0, FieldType.SFTime, AccessType.inputOutput, 'TimeSensor'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('loop', False, FieldType.SFBool, AccessType.inputOutput, 'TimeSensor'),
        ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        cycleInterval=1.0,
        description='',
        enabled=True,
        loop=False,
        pauseTime=0,
        resumeTime=0,
        startTime=0,
        stopTime=0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TimeSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.cycleInterval = cycleInterval
        self.description = description
        self.enabled = enabled
        self.loop = loop
        self.pauseTime = pauseTime
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def cycleInterval(self):
        """[0,+infinity) cycleInterval is loop duration in seconds."""
        return self.__cycleInterval
    @cycleInterval.setter
    def cycleInterval(self, cycleInterval):
        if  cycleInterval is None:
            cycleInterval = 1.0  # default
        assertValidSFTime(cycleInterval)
        assertNonNegative('cycleInterval', cycleInterval)
        self.__cycleInterval = cycleInterval
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def loop(self):
        """Repeat indefinitely when loop=true, repeat only once when loop=false."""
        return self.__loop
    @loop.setter
    def loop(self, loop):
        if  loop is None:
            loop = False  # default
        assertValidSFBool(loop)
        self.__loop = loop
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and TimeSensor becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0  # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and TimeSensor becomes inactive."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0  # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """When time now >= startTime, isActive becomes true and TimeSensor becomes active."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0  # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """When stopTime becomes <= time now, isActive becomes false and TimeSensor becomes inactive."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0  # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class TimeTrigger(_X3DTriggerNode):
    """
    TimeTrigger converts boolean true events to time events.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TimeTrigger'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/eventUtilities.html#TimeTrigger'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TimeTrigger'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TimeTrigger __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class ToneMappedVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    ToneMappedVolumeStyle specifies that volumetric data is rendered with Gooch shading model of two-toned warm/cool coloring.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ToneMappedVolumeStyle'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#ToneMappedVolumeStyle'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ToneMappedVolumeStyle'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('coolColor', (0, 0, 1, 0), FieldType.SFColorRGBA, AccessType.inputOutput, 'ToneMappedVolumeStyle'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeRenderStyleNode'),
        ('warmColor', (1, 1, 0, 0), FieldType.SFColorRGBA, AccessType.inputOutput, 'ToneMappedVolumeStyle'),
        ('surfaceNormals', None, FieldType.SFNode, AccessType.inputOutput, 'ToneMappedVolumeStyle'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        coolColor=(0, 0, 1, 0),
        enabled=True,
        warmColor=(1, 1, 0, 0),
        surfaceNormals=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ToneMappedVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.coolColor = coolColor
        self.enabled = enabled
        self.warmColor = warmColor
        self.surfaceNormals = surfaceNormals
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def coolColor(self):
        """[0,1] coolColor is used for surfaces facing away from the light direction."""
        return self.__coolColor
    @coolColor.setter
    def coolColor(self, coolColor):
        if  coolColor is None:
            coolColor = (0, 0, 1, 0)  # default
        assertValidSFColorRGBA(coolColor)
        assertZeroToOne('coolColor', coolColor)
        self.__coolColor = coolColor
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def warmColor(self):
        """[0,1] warmColor is used for surfaces facing towards the light."""
        return self.__warmColor
    @warmColor.setter
    def warmColor(self, warmColor):
        if  warmColor is None:
            warmColor = (1, 1, 0, 0)  # default
        assertValidSFColorRGBA(warmColor)
        assertZeroToOne('warmColor', warmColor)
        self.__warmColor = warmColor
    @property # getter - - - - - - - - - -
    def surfaceNormals(self):
        """[X3DTexture3DNode] The surfaceNormals field contains a 3D texture with at least three component values."""
        return self.__surfaceNormals
    @surfaceNormals.setter
    def surfaceNormals(self, surfaceNormals):
        if  surfaceNormals is None:
            surfaceNormals = None  # default
        assertValidSFNode(surfaceNormals)
        if not surfaceNormals is None and not isinstance(surfaceNormals,(_X3DTexture3DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(surfaceNormals) + ' does not match required node type (_X3DTexture3DNode,ProtoInstance) and is invalid')
        self.__surfaceNormals = surfaceNormals
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.surfaceNormals
    # output function - - - - - - - - - -

class TouchSensor(_X3DTouchSensorNode):
    """
    TouchSensor tracks location and state of the pointing device, detecting when a user points at or selects (activates) geometry.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TouchSensor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/pointingDeviceSensor.html#TouchSensor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TouchSensor'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSensorNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        description='',
        enabled=True,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TouchSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.enabled = enabled
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class Transform(_X3DGroupingNode):
    """
    Transform is a Grouping node that can contain most nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Transform'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/grouping.html#Transform'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Transform'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'Transform'),
        ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'Transform'),
        ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'Transform'),
        ('scaleOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'Transform'),
        ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'Transform'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        center=(0, 0, 0),
        rotation=(0, 0, 1, 0),
        scale=(1, 1, 1),
        scaleOrientation=(0, 0, 1, 0),
        translation=(0, 0, 0),
        visible=True,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Transform __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.center = center
        self.rotation = rotation
        self.scale = scale
        self.scaleOrientation = scaleOrientation
        self.translation = translation
        self.visible = visible
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        """Translation offset from origin of local coordinate system, applied prior to rotation or scaling."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0)  # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def rotation(self):
        """Orientation (axis, angle in radians) of children relative to local coordinate system."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = (0, 0, 1, 0)  # default
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        """Non-uniform x-y-z scale of child coordinate system, adjusted by center and scaleOrientation."""
        return self.__scale
    @scale.setter
    def scale(self, scale):
        if  scale is None:
            scale = (1, 1, 1)  # default
        assertValidSFVec3f(scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def scaleOrientation(self):
        """Preliminary rotation of coordinate system before scaling (to allow scaling around arbitrary orientations)."""
        return self.__scaleOrientation
    @scaleOrientation.setter
    def scaleOrientation(self, scaleOrientation):
        if  scaleOrientation is None:
            scaleOrientation = (0, 0, 1, 0)  # default
        assertValidSFRotation(scaleOrientation)
        self.__scaleOrientation = scaleOrientation
    @property # getter - - - - - - - - - -
    def translation(self):
        """Position (x, y, z in meters) of children relative to local coordinate system."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0, 0)  # default
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class TransformSensor(_X3DEnvironmentalSensorNode):
    """
    TransformSensor generates output events when its targetObject enters, exits, and moves within a region in space (defined by a box).
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TransformSensor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalSensor.html#TransformSensor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TransformSensor'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'TransformSensor'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSensorNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('size', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'X3DEnvironmentalSensorNode'),
        ('targetObject', None, FieldType.SFNode, AccessType.inputOutput, 'TransformSensor'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        center=(0, 0, 0),
        description='',
        enabled=True,
        size=(0, 0, 0),
        targetObject=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TransformSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.center = center
        self.description = description
        self.enabled = enabled
        self.size = size
        self.targetObject = targetObject
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def center(self):
        """Translation offset from origin of local coordinate system."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0)  # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def size(self):
        """[0,+infinity) size of transformation-traccking box around center location, oriented within local transformation frame."""
        return self.__size
    @size.setter
    def size(self, size):
        if  size is None:
            size = (0, 0, 0)  # default
        assertValidSFVec3f(size)
        assertNonNegative('size', size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def targetObject(self):
        """[X3DGroupingNode|X3DShapeNode] targetObject is the movable geometry represented by any valid X3DGroupingNode or X3DShapeNode which may enter or exit the box."""
        return self.__targetObject
    @targetObject.setter
    def targetObject(self, targetObject):
        if  targetObject is None:
            targetObject = None  # default
        assertValidSFNode(targetObject)
        if not targetObject is None and not isinstance(targetObject,(_X3DGroupingNode,_X3DShapeNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(targetObject) + ' does not match required node type (_X3DGroupingNode,_X3DShapeNode,ProtoInstance) and is invalid')
        self.__targetObject = targetObject
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.targetObject
    # output function - - - - - - - - - -

class TransmitterPdu(_X3DNetworkSensorNode, _X3DBoundedObject):
    """
    TransmitterPdu is a networked Protocol Data Unit (PDU) information node that provides detailed information about a radio transmitter modeled in a simulation.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TransmitterPdu'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/dis.html#TransmitterPdu'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TransmitterPdu'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('address', 'localhost', FieldType.SFString, AccessType.inputOutput, 'TransmitterPdu'),
        ('antennaLocation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'TransmitterPdu'),
        ('antennaPatternLength', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('antennaPatternType', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('applicationID', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
        ('cryptoKeyID', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('cryptoSystem', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSensorNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('entityID', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('frequency', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('geoCoords', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput, 'TransmitterPdu'),
        ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'TransmitterPdu'),
        ('inputSource', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('lengthOfModulationParameters', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('modulationTypeDetail', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('modulationTypeMajor', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('modulationTypeSpreadSpectrum', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('modulationTypeSystem', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('multicastRelayHost', '', FieldType.SFString, AccessType.inputOutput, 'TransmitterPdu'),
        ('multicastRelayPort', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('networkMode', 'standAlone', FieldType.SFString, AccessType.inputOutput, 'TransmitterPdu'),
        ('port', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('power', 0.0, FieldType.SFFloat, AccessType.inputOutput, 'TransmitterPdu'),
        ('radioEntityTypeCategory', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('radioEntityTypeCountry', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('radioEntityTypeDomain', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('radioEntityTypeKind', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('radioEntityTypeNomenclature', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('radioEntityTypeNomenclatureVersion', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('radioID', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('readInterval', 0.1, FieldType.SFTime, AccessType.inputOutput, 'TransmitterPdu'),
        ('relativeAntennaLocation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'TransmitterPdu'),
        ('rtpHeaderExpected', False, FieldType.SFBool, AccessType.inputOutput, 'TransmitterPdu'),
        ('siteID', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('transmitFrequencyBandwidth', 0, FieldType.SFFloat, AccessType.inputOutput, 'TransmitterPdu'),
        ('transmitState', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
        ('whichGeometry', 1, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
        ('writeInterval', 1.0, FieldType.SFTime, AccessType.inputOutput, 'TransmitterPdu'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        address='localhost',
        antennaLocation=(0, 0, 0),
        antennaPatternLength=0,
        antennaPatternType=0,
        applicationID=0,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        cryptoKeyID=0,
        cryptoSystem=0,
        description='',
        enabled=True,
        entityID=0,
        frequency=0,
        geoCoords=(0, 0, 0),
        geoSystem=None,
        inputSource=0,
        lengthOfModulationParameters=0,
        modulationTypeDetail=0,
        modulationTypeMajor=0,
        modulationTypeSpreadSpectrum=0,
        modulationTypeSystem=0,
        multicastRelayHost='',
        multicastRelayPort=0,
        networkMode='standAlone',
        port=0,
        power=0.0,
        radioEntityTypeCategory=0,
        radioEntityTypeCountry=0,
        radioEntityTypeDomain=0,
        radioEntityTypeKind=0,
        radioEntityTypeNomenclature=0,
        radioEntityTypeNomenclatureVersion=0,
        radioID=0,
        readInterval=0.1,
        relativeAntennaLocation=(0, 0, 0),
        rtpHeaderExpected=False,
        siteID=0,
        transmitFrequencyBandwidth=0,
        transmitState=0,
        visible=True,
        whichGeometry=1,
        writeInterval=1.0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TransmitterPdu __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.address = address
        self.antennaLocation = antennaLocation
        self.antennaPatternLength = antennaPatternLength
        self.antennaPatternType = antennaPatternType
        self.applicationID = applicationID
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.cryptoKeyID = cryptoKeyID
        self.cryptoSystem = cryptoSystem
        self.description = description
        self.enabled = enabled
        self.entityID = entityID
        self.frequency = frequency
        self.geoCoords = geoCoords
        self.geoSystem = geoSystem
        self.inputSource = inputSource
        self.lengthOfModulationParameters = lengthOfModulationParameters
        self.modulationTypeDetail = modulationTypeDetail
        self.modulationTypeMajor = modulationTypeMajor
        self.modulationTypeSpreadSpectrum = modulationTypeSpreadSpectrum
        self.modulationTypeSystem = modulationTypeSystem
        self.multicastRelayHost = multicastRelayHost
        self.multicastRelayPort = multicastRelayPort
        self.networkMode = networkMode
        self.port = port
        self.power = power
        self.radioEntityTypeCategory = radioEntityTypeCategory
        self.radioEntityTypeCountry = radioEntityTypeCountry
        self.radioEntityTypeDomain = radioEntityTypeDomain
        self.radioEntityTypeKind = radioEntityTypeKind
        self.radioEntityTypeNomenclature = radioEntityTypeNomenclature
        self.radioEntityTypeNomenclatureVersion = radioEntityTypeNomenclatureVersion
        self.radioID = radioID
        self.readInterval = readInterval
        self.relativeAntennaLocation = relativeAntennaLocation
        self.rtpHeaderExpected = rtpHeaderExpected
        self.siteID = siteID
        self.transmitFrequencyBandwidth = transmitFrequencyBandwidth
        self.transmitState = transmitState
        self.visible = visible
        self.whichGeometry = whichGeometry
        self.writeInterval = writeInterval
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def address(self):
        """Multicast network address, or else 'localhost'."""
        return self.__address
    @address.setter
    def address(self, address):
        if  address is None:
            address = 'localhost'  # default
        assertValidSFString(address)
        self.__address = address
    @property # getter - - - - - - - - - -
    def antennaLocation(self):
        """World coordinates for antenna location."""
        return self.__antennaLocation
    @antennaLocation.setter
    def antennaLocation(self, antennaLocation):
        if  antennaLocation is None:
            antennaLocation = (0, 0, 0)  # default
        assertValidSFVec3f(antennaLocation)
        self.__antennaLocation = antennaLocation
    @property # getter - - - - - - - - - -
    def antennaPatternLength(self):
        """."""
        return self.__antennaPatternLength
    @antennaPatternLength.setter
    def antennaPatternLength(self, antennaPatternLength):
        if  antennaPatternLength is None:
            antennaPatternLength = 0  # default
        assertValidSFInt32(antennaPatternLength)
        self.__antennaPatternLength = antennaPatternLength
    @property # getter - - - - - - - - - -
    def antennaPatternType(self):
        """Antenna shape pattern: 0 for omnidirectional, 1 for beam, 2 for spherical harmonic (deprecated), or optional higher value."""
        return self.__antennaPatternType
    @antennaPatternType.setter
    def antennaPatternType(self, antennaPatternType):
        if  antennaPatternType is None:
            antennaPatternType = 0  # default
        assertValidSFInt32(antennaPatternType)
        self.__antennaPatternType = antennaPatternType
    @property # getter - - - - - - - - - -
    def applicationID(self):
        """Each simulation application that can respond to simulation management PDUs needs to have a unique applicationID."""
        return self.__applicationID
    @applicationID.setter
    def applicationID(self, applicationID):
        if  applicationID is None:
            applicationID = 0  # default
        assertValidSFInt32(applicationID)
        self.__applicationID = applicationID
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def cryptoKeyID(self):
        """Nonzero value corresponding to the simulated cryptographic key."""
        return self.__cryptoKeyID
    @cryptoKeyID.setter
    def cryptoKeyID(self, cryptoKeyID):
        if  cryptoKeyID is None:
            cryptoKeyID = 0  # default
        assertValidSFInt32(cryptoKeyID)
        self.__cryptoKeyID = cryptoKeyID
    @property # getter - - - - - - - - - -
    def cryptoSystem(self):
        """Indicates type of crypto system being used, even if the encryption equipment is not keyed."""
        return self.__cryptoSystem
    @cryptoSystem.setter
    def cryptoSystem(self, cryptoSystem):
        if  cryptoSystem is None:
            cryptoSystem = 0  # default
        assertValidSFInt32(cryptoSystem)
        self.__cryptoSystem = cryptoSystem
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables the sensor node."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def entityID(self):
        """EntityID unique ID for entity within that application."""
        return self.__entityID
    @entityID.setter
    def entityID(self, entityID):
        if  entityID is None:
            entityID = 0  # default
        assertValidSFInt32(entityID)
        self.__entityID = entityID
    @property # getter - - - - - - - - - -
    def frequency(self):
        """[0,+infinity) Transmission frequency in Hz."""
        return self.__frequency
    @frequency.setter
    def frequency(self, frequency):
        if  frequency is None:
            frequency = 0  # default
        assertValidSFInt32(frequency)
        assertNonNegative('frequency', frequency)
        self.__frequency = frequency
    @property # getter - - - - - - - - - -
    def geoCoords(self):
        """Geographic location (specified in current geoSystem coordinates) for children geometry (specified in relative coordinate system, in meters)."""
        return self.__geoCoords
    @geoCoords.setter
    def geoCoords(self, geoCoords):
        if  geoCoords is None:
            geoCoords = (0, 0, 0)  # default
        assertValidSFVec3d(geoCoords)
        self.__geoCoords = geoCoords
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"]  # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def inputSource(self):
        """Source of transmission input."""
        return self.__inputSource
    @inputSource.setter
    def inputSource(self, inputSource):
        if  inputSource is None:
            inputSource = 0  # default
        assertValidSFInt32(inputSource)
        self.__inputSource = inputSource
    @property # getter - - - - - - - - - -
    def lengthOfModulationParameters(self):
        """."""
        return self.__lengthOfModulationParameters
    @lengthOfModulationParameters.setter
    def lengthOfModulationParameters(self, lengthOfModulationParameters):
        if  lengthOfModulationParameters is None:
            lengthOfModulationParameters = 0  # default
        assertValidSFInt32(lengthOfModulationParameters)
        self.__lengthOfModulationParameters = lengthOfModulationParameters
    @property # getter - - - - - - - - - -
    def modulationTypeDetail(self):
        """Integer enumeration containing detailed information depending on the major modulation type."""
        return self.__modulationTypeDetail
    @modulationTypeDetail.setter
    def modulationTypeDetail(self, modulationTypeDetail):
        if  modulationTypeDetail is None:
            modulationTypeDetail = 0  # default
        assertValidSFInt32(modulationTypeDetail)
        self.__modulationTypeDetail = modulationTypeDetail
    @property # getter - - - - - - - - - -
    def modulationTypeMajor(self):
        """Integer enumeration containing major classification of the modulation type."""
        return self.__modulationTypeMajor
    @modulationTypeMajor.setter
    def modulationTypeMajor(self, modulationTypeMajor):
        if  modulationTypeMajor is None:
            modulationTypeMajor = 0  # default
        assertValidSFInt32(modulationTypeMajor)
        self.__modulationTypeMajor = modulationTypeMajor
    @property # getter - - - - - - - - - -
    def modulationTypeSpreadSpectrum(self):
        """Indicates the spread spectrum technique or combination of spread spectrum techniques in use."""
        return self.__modulationTypeSpreadSpectrum
    @modulationTypeSpreadSpectrum.setter
    def modulationTypeSpreadSpectrum(self, modulationTypeSpreadSpectrum):
        if  modulationTypeSpreadSpectrum is None:
            modulationTypeSpreadSpectrum = 0  # default
        assertValidSFInt32(modulationTypeSpreadSpectrum)
        self.__modulationTypeSpreadSpectrum = modulationTypeSpreadSpectrum
    @property # getter - - - - - - - - - -
    def modulationTypeSystem(self):
        """Specifies radio system associated with this Transmitter PDU and used to interpret other fields whose values depend on a specific radio system."""
        return self.__modulationTypeSystem
    @modulationTypeSystem.setter
    def modulationTypeSystem(self, modulationTypeSystem):
        if  modulationTypeSystem is None:
            modulationTypeSystem = 0  # default
        assertValidSFInt32(modulationTypeSystem)
        self.__modulationTypeSystem = modulationTypeSystem
    @property # getter - - - - - - - - - -
    def multicastRelayHost(self):
        """Fallback server address if multicast not available locally."""
        return self.__multicastRelayHost
    @multicastRelayHost.setter
    def multicastRelayHost(self, multicastRelayHost):
        if  multicastRelayHost is None:
            multicastRelayHost = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(multicastRelayHost)
        self.__multicastRelayHost = multicastRelayHost
    @property # getter - - - - - - - - - -
    def multicastRelayPort(self):
        """Fallback server port if multicast not available locally."""
        return self.__multicastRelayPort
    @multicastRelayPort.setter
    def multicastRelayPort(self, multicastRelayPort):
        if  multicastRelayPort is None:
            multicastRelayPort = 0  # default
        assertValidSFInt32(multicastRelayPort)
        self.__multicastRelayPort = multicastRelayPort
    @property # getter - - - - - - - - - -
    def networkMode(self):
        """Whether this entity is ignoring the network, sending DIS packets to the network, or receiving DIS packets from the network."""
        return self.__networkMode
    @networkMode.setter
    def networkMode(self, networkMode):
        if  networkMode is None:
            networkMode = 'standAlone'  # default
        assertValidSFString(networkMode)
        assertValidNetworkMode('networkMode', networkMode)
        self.__networkMode = networkMode
    @property # getter - - - - - - - - - -
    def port(self):
        """Multicast network port, for example: 3000."""
        return self.__port
    @port.setter
    def port(self, port):
        if  port is None:
            port = 0  # default
        assertValidSFInt32(port)
        self.__port = port
    @property # getter - - - - - - - - - -
    def power(self):
        """Power that radio would be capable of outputting if on and transmitting, independent of actual transmit state of the radio."""
        return self.__power
    @power.setter
    def power(self, power):
        if  power is None:
            power = 0.0  # default
        assertValidSFFloat(power)
        self.__power = power
    @property # getter - - - - - - - - - -
    def radioEntityTypeCategory(self):
        """Integer enumeration containing EntityType of transmitter radio."""
        return self.__radioEntityTypeCategory
    @radioEntityTypeCategory.setter
    def radioEntityTypeCategory(self, radioEntityTypeCategory):
        if  radioEntityTypeCategory is None:
            radioEntityTypeCategory = 0  # default
        assertValidSFInt32(radioEntityTypeCategory)
        self.__radioEntityTypeCategory = radioEntityTypeCategory
    @property # getter - - - - - - - - - -
    def radioEntityTypeCountry(self):
        """Integer enumerations value for country to which the design of the entity or its design specification is attributed."""
        return self.__radioEntityTypeCountry
    @radioEntityTypeCountry.setter
    def radioEntityTypeCountry(self, radioEntityTypeCountry):
        if  radioEntityTypeCountry is None:
            radioEntityTypeCountry = 0  # default
        assertValidSFInt32(radioEntityTypeCountry)
        self.__radioEntityTypeCountry = radioEntityTypeCountry
    @property # getter - - - - - - - - - -
    def radioEntityTypeDomain(self):
        """Integer enumerations value for domain in which the entity operates: LAND, AIR, SURFACE, SUBSURFACE, SPACE or OTHER."""
        return self.__radioEntityTypeDomain
    @radioEntityTypeDomain.setter
    def radioEntityTypeDomain(self, radioEntityTypeDomain):
        if  radioEntityTypeDomain is None:
            radioEntityTypeDomain = 0  # default
        assertValidSFInt32(radioEntityTypeDomain)
        self.__radioEntityTypeDomain = radioEntityTypeDomain
    @property # getter - - - - - - - - - -
    def radioEntityTypeKind(self):
        """Integer enumerations value for whether entity is a PLATFORM, MUNITION, LIFE_FORM, ENVIRONMENTAL, CULTURAL_FEATURE, SUPPLY, RADIO, EXPENDABLE, SENSOR_EMITTER or OTHER."""
        return self.__radioEntityTypeKind
    @radioEntityTypeKind.setter
    def radioEntityTypeKind(self, radioEntityTypeKind):
        if  radioEntityTypeKind is None:
            radioEntityTypeKind = 0  # default
        assertValidSFInt32(radioEntityTypeKind)
        self.__radioEntityTypeKind = radioEntityTypeKind
    @property # getter - - - - - - - - - -
    def radioEntityTypeNomenclature(self):
        """Integer enumerations value indicating nomenclature (name) for a particular emitter."""
        return self.__radioEntityTypeNomenclature
    @radioEntityTypeNomenclature.setter
    def radioEntityTypeNomenclature(self, radioEntityTypeNomenclature):
        if  radioEntityTypeNomenclature is None:
            radioEntityTypeNomenclature = 0  # default
        assertValidSFInt32(radioEntityTypeNomenclature)
        self.__radioEntityTypeNomenclature = radioEntityTypeNomenclature
    @property # getter - - - - - - - - - -
    def radioEntityTypeNomenclatureVersion(self):
        """Named equipment version number."""
        return self.__radioEntityTypeNomenclatureVersion
    @radioEntityTypeNomenclatureVersion.setter
    def radioEntityTypeNomenclatureVersion(self, radioEntityTypeNomenclatureVersion):
        if  radioEntityTypeNomenclatureVersion is None:
            radioEntityTypeNomenclatureVersion = 0  # default
        assertValidSFInt32(radioEntityTypeNomenclatureVersion)
        self.__radioEntityTypeNomenclatureVersion = radioEntityTypeNomenclatureVersion
    @property # getter - - - - - - - - - -
    def radioID(self):
        """Identifies a particular radio within a given entity."""
        return self.__radioID
    @radioID.setter
    def radioID(self, radioID):
        if  radioID is None:
            radioID = 0  # default
        assertValidSFInt32(radioID)
        self.__radioID = radioID
    @property # getter - - - - - - - - - -
    def readInterval(self):
        """[0,+infinity) Seconds between read updates, 0 means no reading."""
        return self.__readInterval
    @readInterval.setter
    def readInterval(self, readInterval):
        if  readInterval is None:
            readInterval = 0.1  # default
        assertValidSFTime(readInterval)
        assertNonNegative('readInterval', readInterval)
        self.__readInterval = readInterval
    @property # getter - - - - - - - - - -
    def relativeAntennaLocation(self):
        """Relative coordinates for antenna location."""
        return self.__relativeAntennaLocation
    @relativeAntennaLocation.setter
    def relativeAntennaLocation(self, relativeAntennaLocation):
        if  relativeAntennaLocation is None:
            relativeAntennaLocation = (0, 0, 0)  # default
        assertValidSFVec3f(relativeAntennaLocation)
        self.__relativeAntennaLocation = relativeAntennaLocation
    @property # getter - - - - - - - - - -
    def rtpHeaderExpected(self):
        """Whether RTP headers are prepended to DIS PDUs."""
        return self.__rtpHeaderExpected
    @rtpHeaderExpected.setter
    def rtpHeaderExpected(self, rtpHeaderExpected):
        if  rtpHeaderExpected is None:
            rtpHeaderExpected = False  # default
        assertValidSFBool(rtpHeaderExpected)
        self.__rtpHeaderExpected = rtpHeaderExpected
    @property # getter - - - - - - - - - -
    def siteID(self):
        """Simulation/exercise siteID of the participating LAN or organization."""
        return self.__siteID
    @siteID.setter
    def siteID(self, siteID):
        if  siteID is None:
            siteID = 0  # default
        assertValidSFInt32(siteID)
        self.__siteID = siteID
    @property # getter - - - - - - - - - -
    def transmitFrequencyBandwidth(self):
        """Bandwidth of the particular transmitter measured between the half-power (-3 dB) points (this value represents total bandwidth, not the deviation from the center frequency)."""
        return self.__transmitFrequencyBandwidth
    @transmitFrequencyBandwidth.setter
    def transmitFrequencyBandwidth(self, transmitFrequencyBandwidth):
        if  transmitFrequencyBandwidth is None:
            transmitFrequencyBandwidth = 0  # default
        assertValidSFFloat(transmitFrequencyBandwidth)
        self.__transmitFrequencyBandwidth = transmitFrequencyBandwidth
    @property # getter - - - - - - - - - -
    def transmitState(self):
        """Specify radio transmission state where enumerations value 0 is for off, value 1 for powered but not transmitting, or value 1 is for powered and transmitting,."""
        return self.__transmitState
    @transmitState.setter
    def transmitState(self, transmitState):
        if  transmitState is None:
            transmitState = 0  # default
        assertValidSFInt32(transmitState)
        self.__transmitState = transmitState
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def whichGeometry(self):
        """Select geometry to render: -1 for no geometry, 0 for text trace, 1 for default geometry, (optional) higher values to render different states."""
        return self.__whichGeometry
    @whichGeometry.setter
    def whichGeometry(self, whichGeometry):
        if  whichGeometry is None:
            whichGeometry = 1  # default
        assertValidSFInt32(whichGeometry)
        self.__whichGeometry = whichGeometry
    @property # getter - - - - - - - - - -
    def writeInterval(self):
        """[0,+infinity) Seconds between write updates, 0 means no writing (sending)."""
        return self.__writeInterval
    @writeInterval.setter
    def writeInterval(self, writeInterval):
        if  writeInterval is None:
            writeInterval = 1.0  # default
        assertValidSFTime(writeInterval)
        assertNonNegative('writeInterval', writeInterval)
        self.__writeInterval = writeInterval
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):

        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class TriangleFanSet(_X3DComposedGeometryNode):
    """
    TriangleFanSet is a geometry node containing a Coordinate|CoordinateDouble node, and can also contain Color|ColorRGBA, Normal and TextureCoordinate nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TriangleFanSet'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#TriangleFanSet'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TriangleFanSet'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('fanCount', [], FieldType.MFInt32, AccessType.inputOutput, 'TriangleFanSet'),
        ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('color', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('attrib', [], FieldType.MFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        ccw=True,
        colorPerVertex=True,
        fanCount=None,
        normalPerVertex=True,
        solid=True,
        color=None,
        coord=None,
        fogCoord=None,
        normal=None,
        texCoord=None,
        attrib=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TriangleFanSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.fanCount = fanCount
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True  # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color|ColorRGBA values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True  # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def fanCount(self):
        """(3,+infinity) fanCount array provides number of vertices in each fan."""
        return self.__fanCount
    @fanCount.setter
    def fanCount(self, fanCount):
        if  fanCount is None:
            fanCount = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(fanCount)
        assertGreaterThanEquals('fanCount', fanCount, 3)
        self.__fanCount = fanCount
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True  # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that can specify color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None  # default
        assertValidSFNode(color)
        if not color is None and not isinstance(color,(_X3DColorNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not match required node type (_X3DColorNode,ProtoInstance) and is invalid')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that can specify a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None  # default
        assertValidSFNode(coord)
        if not coord is None and not isinstance(coord,(_X3DCoordinateNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not match required node type (_X3DCoordinateNode,ProtoInstance) and is invalid')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that can specify depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None  # default
        assertValidSFNode(fogCoord)
        if not fogCoord is None and not isinstance(fogCoord,(FogCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not match required node type (FogCoordinate,ProtoInstance) and is invalid')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that can specify perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None  # default
        assertValidSFNode(normal)
        if not normal is None and not isinstance(normal,(_X3DNormalNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not match required node type (_X3DNormalNode,ProtoInstance) and is invalid')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that can specify coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None  # default
        assertValidSFNode(texCoord)
        if not texCoord is None and not isinstance(texCoord,(_X3DSingleTextureCoordinateNode,MultiTextureCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not match required node type (_X3DSingleTextureCoordinateNode,MultiTextureCoordinate,ProtoInstance) and is invalid')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that can specify list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(attrib)
        self.__attrib = attrib
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or self.texCoord or (len(self.attrib) > 0)
    # output function - - - - - - - - - -

class TriangleSet(_X3DComposedGeometryNode):
    """
    TriangleSet is a geometry node containing a Coordinate|CoordinateDouble node, and can also contain Color|ColorRGBA, Normal and TextureCoordinate nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TriangleSet'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#TriangleSet'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TriangleSet'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('color', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('attrib', [], FieldType.MFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        ccw=True,
        colorPerVertex=True,
        normalPerVertex=True,
        solid=True,
        color=None,
        coord=None,
        fogCoord=None,
        normal=None,
        texCoord=None,
        attrib=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TriangleSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True  # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color|ColorRGBA values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True  # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True  # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that can specify color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None  # default
        assertValidSFNode(color)
        if not color is None and not isinstance(color,(_X3DColorNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not match required node type (_X3DColorNode,ProtoInstance) and is invalid')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that can specify a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None  # default
        assertValidSFNode(coord)
        if not coord is None and not isinstance(coord,(_X3DCoordinateNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not match required node type (_X3DCoordinateNode,ProtoInstance) and is invalid')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that can specify depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None  # default
        assertValidSFNode(fogCoord)
        if not fogCoord is None and not isinstance(fogCoord,(FogCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not match required node type (FogCoordinate,ProtoInstance) and is invalid')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that can specify perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None  # default
        assertValidSFNode(normal)
        if not normal is None and not isinstance(normal,(_X3DNormalNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not match required node type (_X3DNormalNode,ProtoInstance) and is invalid')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that can specify coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None  # default
        assertValidSFNode(texCoord)
        if not texCoord is None and not isinstance(texCoord,(_X3DSingleTextureCoordinateNode,MultiTextureCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not match required node type (_X3DSingleTextureCoordinateNode,MultiTextureCoordinate,ProtoInstance) and is invalid')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that can specify list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(attrib)
        self.__attrib = attrib
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or self.texCoord or (len(self.attrib) > 0)
    # output function - - - - - - - - - -

class TriangleSet2D(_X3DGeometryNode):
    """
    TriangleSet2D is a geometry node that defines a set of filled 2D triangles in X-Y plane.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TriangleSet2D'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry2D.html#TriangleSet2D'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TriangleSet2D'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('solid', False, FieldType.SFBool, AccessType.initializeOnly, 'TriangleSet2D'),
        ('vertices', [], FieldType.MFVec2f, AccessType.inputOutput, 'TriangleSet2D'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        solid=False,
        vertices=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TriangleSet2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.solid = solid
        self.vertices = vertices
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = False  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def vertices(self):
        """2D coordinates of TriangleSet2D vertices."""
        return self.__vertices
    @vertices.setter
    def vertices(self, vertices):
        if  vertices is None:
            vertices = MFVec2f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFVec2f.DEFAULT_VALUE()))
        assertValidMFVec2f(vertices)
        self.__vertices = vertices
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class TriangleStripSet(_X3DComposedGeometryNode):
    """
    TriangleStripSet is a geometry node containing a Coordinate|CoordinateDouble node, and can also contain Color|ColorRGBA, Normal and TextureCoordinate nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TriangleStripSet'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#TriangleStripSet'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TriangleStripSet'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('stripCount', [], FieldType.MFInt32, AccessType.inputOutput, 'TriangleStripSet'),
        ('color', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('attrib', [], FieldType.MFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        ccw=True,
        colorPerVertex=True,
        normalPerVertex=True,
        solid=True,
        stripCount=None,
        color=None,
        coord=None,
        fogCoord=None,
        normal=None,
        texCoord=None,
        attrib=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TriangleStripSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.stripCount = stripCount
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True  # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color|ColorRGBA values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True  # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True  # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def stripCount(self):
        """(3,+infinity) stripCount array provides number of vertices in each strip."""
        return self.__stripCount
    @stripCount.setter
    def stripCount(self, stripCount):
        if  stripCount is None:
            stripCount = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(stripCount)
        assertGreaterThanEquals('stripCount', stripCount, 3)
        self.__stripCount = stripCount
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that can specify color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None  # default
        assertValidSFNode(color)
        if not color is None and not isinstance(color,(_X3DColorNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not match required node type (_X3DColorNode,ProtoInstance) and is invalid')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that can specify a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None  # default
        assertValidSFNode(coord)
        if not coord is None and not isinstance(coord,(_X3DCoordinateNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not match required node type (_X3DCoordinateNode,ProtoInstance) and is invalid')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that can specify depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None  # default
        assertValidSFNode(fogCoord)
        if not fogCoord is None and not isinstance(fogCoord,(FogCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not match required node type (FogCoordinate,ProtoInstance) and is invalid')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that can specify perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None  # default
        assertValidSFNode(normal)
        if not normal is None and not isinstance(normal,(_X3DNormalNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not match required node type (_X3DNormalNode,ProtoInstance) and is invalid')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that can specify coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None  # default
        assertValidSFNode(texCoord)
        if not texCoord is None and not isinstance(texCoord,(_X3DSingleTextureCoordinateNode,MultiTextureCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not match required node type (_X3DSingleTextureCoordinateNode,MultiTextureCoordinate,ProtoInstance) and is invalid')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that can specify list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(attrib)
        self.__attrib = attrib
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or self.texCoord or (len(self.attrib) > 0)
    # output function - - - - - - - - - -

class TwoSidedMaterial(_X3DMaterialNode):
    """
    TwoSidedMaterial specifies surface rendering properties for associated geometry nodes, for outer (front) and inner (back) sides of polygons.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TwoSidedMaterial'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#TwoSidedMaterial'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TwoSidedMaterial'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('ambientIntensity', 0.2, FieldType.SFFloat, AccessType.inputOutput, 'TwoSidedMaterial'),
        ('backAmbientIntensity', 0.2, FieldType.SFFloat, AccessType.inputOutput, 'TwoSidedMaterial'),
        ('backDiffuseColor', (0.8, 0.8, 0.8), FieldType.SFColor, AccessType.inputOutput, 'TwoSidedMaterial'),
        ('backEmissiveColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput, 'TwoSidedMaterial'),
        ('backShininess', 0.2, FieldType.SFFloat, AccessType.inputOutput, 'TwoSidedMaterial'),
        ('backSpecularColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput, 'TwoSidedMaterial'),
        ('backTransparency', 0, FieldType.SFFloat, AccessType.inputOutput, 'TwoSidedMaterial'),
        ('diffuseColor', (0.8, 0.8, 0.8), FieldType.SFColor, AccessType.inputOutput, 'TwoSidedMaterial'),
        ('emissiveColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput, 'TwoSidedMaterial'),
        ('separateBackColor', False, FieldType.SFBool, AccessType.inputOutput, 'TwoSidedMaterial'),
        ('shininess', 0.2, FieldType.SFFloat, AccessType.inputOutput, 'TwoSidedMaterial'),
        ('specularColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput, 'TwoSidedMaterial'),
        ('transparency', 0, FieldType.SFFloat, AccessType.inputOutput, 'TwoSidedMaterial'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        ambientIntensity=0.2,
        backAmbientIntensity=0.2,
        backDiffuseColor=(0.8, 0.8, 0.8),
        backEmissiveColor=(0, 0, 0),
        backShininess=0.2,
        backSpecularColor=(0, 0, 0),
        backTransparency=0,
        diffuseColor=(0.8, 0.8, 0.8),
        emissiveColor=(0, 0, 0),
        separateBackColor=False,
        shininess=0.2,
        specularColor=(0, 0, 0),
        transparency=0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode TwoSidedMaterial __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ambientIntensity = ambientIntensity
        self.backAmbientIntensity = backAmbientIntensity
        self.backDiffuseColor = backDiffuseColor
        self.backEmissiveColor = backEmissiveColor
        self.backShininess = backShininess
        self.backSpecularColor = backSpecularColor
        self.backTransparency = backTransparency
        self.diffuseColor = diffuseColor
        self.emissiveColor = emissiveColor
        self.separateBackColor = separateBackColor
        self.shininess = shininess
        self.specularColor = specularColor
        self.transparency = transparency
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def ambientIntensity(self):
        """[0,1] how much ambient omnidirectional light is reflected from all light sources."""
        return self.__ambientIntensity
    @ambientIntensity.setter
    def ambientIntensity(self, ambientIntensity):
        if  ambientIntensity is None:
            ambientIntensity = 0.2  # default
        assertValidSFFloat(ambientIntensity)
        assertZeroToOne('ambientIntensity', ambientIntensity)
        self.__ambientIntensity = ambientIntensity
    @property # getter - - - - - - - - - -
    def backAmbientIntensity(self):
        """[0,1] how much ambient omnidirectional light is reflected from all light sources."""
        return self.__backAmbientIntensity
    @backAmbientIntensity.setter
    def backAmbientIntensity(self, backAmbientIntensity):
        if  backAmbientIntensity is None:
            backAmbientIntensity = 0.2  # default
        assertValidSFFloat(backAmbientIntensity)
        assertZeroToOne('backAmbientIntensity', backAmbientIntensity)
        self.__backAmbientIntensity = backAmbientIntensity
    @property # getter - - - - - - - - - -
    def backDiffuseColor(self):
        """[0,1] how much direct, angle-dependent light is reflected from all light sources."""
        return self.__backDiffuseColor
    @backDiffuseColor.setter
    def backDiffuseColor(self, backDiffuseColor):
        if  backDiffuseColor is None:
            backDiffuseColor = (0.8, 0.8, 0.8)  # default
        assertValidSFColor(backDiffuseColor)
        assertZeroToOne('backDiffuseColor', backDiffuseColor)
        self.__backDiffuseColor = backDiffuseColor
    @property # getter - - - - - - - - - -
    def backEmissiveColor(self):
        """[0,1] how much glowing light is emitted from this object."""
        return self.__backEmissiveColor
    @backEmissiveColor.setter
    def backEmissiveColor(self, backEmissiveColor):
        if  backEmissiveColor is None:
            backEmissiveColor = (0, 0, 0)  # default
        assertValidSFColor(backEmissiveColor)
        assertZeroToOne('backEmissiveColor', backEmissiveColor)
        self.__backEmissiveColor = backEmissiveColor
    @property # getter - - - - - - - - - -
    def backShininess(self):
        """[0,1] Lower shininess values provide soft specular glows, while higher values result in sharper, smaller highlights."""
        return self.__backShininess
    @backShininess.setter
    def backShininess(self, backShininess):
        if  backShininess is None:
            backShininess = 0.2  # default
        assertValidSFFloat(backShininess)
        assertZeroToOne('backShininess', backShininess)
        self.__backShininess = backShininess
    @property # getter - - - - - - - - - -
    def backSpecularColor(self):
        """[0,1] specular highlights are brightness reflections (example: shiny spots on an apple)."""
        return self.__backSpecularColor
    @backSpecularColor.setter
    def backSpecularColor(self, backSpecularColor):
        if  backSpecularColor is None:
            backSpecularColor = (0, 0, 0)  # default
        assertValidSFColor(backSpecularColor)
        assertZeroToOne('backSpecularColor', backSpecularColor)
        self.__backSpecularColor = backSpecularColor
    @property # getter - - - - - - - - - -
    def backTransparency(self):
        """[0,1] how "clear" an object is: 1."""
        return self.__backTransparency
    @backTransparency.setter
    def backTransparency(self, backTransparency):
        if  backTransparency is None:
            backTransparency = 0  # default
        assertValidSFFloat(backTransparency)
        assertZeroToOne('backTransparency', backTransparency)
        self.__backTransparency = backTransparency
    @property # getter - - - - - - - - - -
    def diffuseColor(self):
        """[0,1] how much direct, angle-dependent light is reflected from all light sources."""
        return self.__diffuseColor
    @diffuseColor.setter
    def diffuseColor(self, diffuseColor):
        if  diffuseColor is None:
            diffuseColor = (0.8, 0.8, 0.8)  # default
        assertValidSFColor(diffuseColor)
        assertZeroToOne('diffuseColor', diffuseColor)
        self.__diffuseColor = diffuseColor
    @property # getter - - - - - - - - - -
    def emissiveColor(self):
        """[0,1] how much glowing light is emitted from this object."""
        return self.__emissiveColor
    @emissiveColor.setter
    def emissiveColor(self, emissiveColor):
        if  emissiveColor is None:
            emissiveColor = (0, 0, 0)  # default
        assertValidSFColor(emissiveColor)
        assertZeroToOne('emissiveColor', emissiveColor)
        self.__emissiveColor = emissiveColor
    @property # getter - - - - - - - - - -
    def separateBackColor(self):
        """separateBackColor determines whether separate Material values are used for back faces."""
        return self.__separateBackColor
    @separateBackColor.setter
    def separateBackColor(self, separateBackColor):
        if  separateBackColor is None:
            separateBackColor = False  # default
        assertValidSFBool(separateBackColor)
        self.__separateBackColor = separateBackColor
    @property # getter - - - - - - - - - -
    def shininess(self):
        """[0,1] Lower shininess values provide soft specular glows, while higher values result in sharper, smaller highlights."""
        return self.__shininess
    @shininess.setter
    def shininess(self, shininess):
        if  shininess is None:
            shininess = 0.2  # default
        assertValidSFFloat(shininess)
        assertZeroToOne('shininess', shininess)
        self.__shininess = shininess
    @property # getter - - - - - - - - - -
    def specularColor(self):
        """[0,1] specular highlights are brightness reflections (example: shiny spots on an apple)."""
        return self.__specularColor
    @specularColor.setter
    def specularColor(self, specularColor):
        if  specularColor is None:
            specularColor = (0, 0, 0)  # default
        assertValidSFColor(specularColor)
        assertZeroToOne('specularColor', specularColor)
        self.__specularColor = specularColor
    @property # getter - - - - - - - - - -
    def transparency(self):
        """[0,1] how "clear" an object is: 1."""
        return self.__transparency
    @transparency.setter
    def transparency(self, transparency):
        if  transparency is None:
            transparency = 0  # default
        assertValidSFFloat(transparency)
        assertZeroToOne('transparency', transparency)
        self.__transparency = transparency
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class UniversalJoint(_X3DRigidJointNode):
    """
    UniversalJoint is like a BallJoint that constrains an extra degree of rotational freedom.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'UniversalJoint'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#UniversalJoint'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#UniversalJoint'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('anchorPoint', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'UniversalJoint'),
        ('axis1', (1, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'UniversalJoint'),
        ('axis2', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'UniversalJoint'),
        ('forceOutput', ["NONE"], FieldType.MFString, AccessType.inputOutput, 'X3DRigidJointNode'),
        ('stop1Bounce', 0, FieldType.SFFloat, AccessType.inputOutput, 'UniversalJoint'),
        ('stop1ErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'UniversalJoint'),
        ('stop2Bounce', 0, FieldType.SFFloat, AccessType.inputOutput, 'UniversalJoint'),
        ('stop2ErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'UniversalJoint'),
        ('body1', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
        ('body2', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        anchorPoint=(0, 0, 0),
        axis1=(1, 0, 0),
        axis2=(0, 1, 0),
        forceOutput=None,
        stop1Bounce=0,
        stop1ErrorCorrection=0.8,
        stop2Bounce=0,
        stop2ErrorCorrection=0.8,
        body1=None,
        body2=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode UniversalJoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.anchorPoint = anchorPoint
        self.axis1 = axis1
        self.axis2 = axis2
        self.forceOutput = forceOutput
        self.stop1Bounce = stop1Bounce
        self.stop1ErrorCorrection = stop1ErrorCorrection
        self.stop2Bounce = stop2Bounce
        self.stop2ErrorCorrection = stop2ErrorCorrection
        self.body1 = body1
        self.body2 = body2
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def anchorPoint(self):
        """anchorPoint is joint center, specified in world coordinates."""
        return self.__anchorPoint
    @anchorPoint.setter
    def anchorPoint(self, anchorPoint):
        if  anchorPoint is None:
            anchorPoint = (0, 0, 0)  # default
        assertValidSFVec3f(anchorPoint)
        self.__anchorPoint = anchorPoint
    @property # getter - - - - - - - - - -
    def axis1(self):
        """axis1 defines axis vector of joint connection to body1."""
        return self.__axis1
    @axis1.setter
    def axis1(self, axis1):
        if  axis1 is None:
            axis1 = (1, 0, 0)  # default
        assertValidSFVec3f(axis1)
        self.__axis1 = axis1
    @property # getter - - - - - - - - - -
    def axis2(self):
        """axis2 defines axis vector of joint connection to body2."""
        return self.__axis2
    @axis2.setter
    def axis2(self, axis2):
        if  axis2 is None:
            axis2 = (0, 1, 0)  # default
        assertValidSFVec3f(axis2)
        self.__axis2 = axis2
    @property # getter - - - - - - - - - -
    def forceOutput(self):
        """forceOutput controls which output fields are generated for the next frame."""
        return self.__forceOutput
    @forceOutput.setter
    def forceOutput(self, forceOutput):
        if  forceOutput is None:
            forceOutput = ["NONE"]  # default
        assertValidMFString(forceOutput)
        self.__forceOutput = forceOutput
    @property # getter - - - - - - - - - -
    def stop1Bounce(self):
        """[0,1] stop1Bounce is velocity factor for bounce back once stop point is reached."""
        return self.__stop1Bounce
    @stop1Bounce.setter
    def stop1Bounce(self, stop1Bounce):
        if  stop1Bounce is None:
            stop1Bounce = 0  # default
        assertValidSFFloat(stop1Bounce)
        assertZeroToOne('stop1Bounce', stop1Bounce)
        self.__stop1Bounce = stop1Bounce
    @property # getter - - - - - - - - - -
    def stop1ErrorCorrection(self):
        """[0,1] stop1ErrorCorrection is fraction of error correction performed during time step once stop point is reached."""
        return self.__stop1ErrorCorrection
    @stop1ErrorCorrection.setter
    def stop1ErrorCorrection(self, stop1ErrorCorrection):
        if  stop1ErrorCorrection is None:
            stop1ErrorCorrection = 0.8  # default
        assertValidSFFloat(stop1ErrorCorrection)
        assertZeroToOne('stop1ErrorCorrection', stop1ErrorCorrection)
        self.__stop1ErrorCorrection = stop1ErrorCorrection
    @property # getter - - - - - - - - - -
    def stop2Bounce(self):
        """[0,1] stop2Bounce is velocity factor for bounce back once stop point is reached."""
        return self.__stop2Bounce
    @stop2Bounce.setter
    def stop2Bounce(self, stop2Bounce):
        if  stop2Bounce is None:
            stop2Bounce = 0  # default
        assertValidSFFloat(stop2Bounce)
        assertZeroToOne('stop2Bounce', stop2Bounce)
        self.__stop2Bounce = stop2Bounce
    @property # getter - - - - - - - - - -
    def stop2ErrorCorrection(self):
        """[0,1] stop2ErrorCorrection is fraction of error correction performed during time step once stop point is reached."""
        return self.__stop2ErrorCorrection
    @stop2ErrorCorrection.setter
    def stop2ErrorCorrection(self, stop2ErrorCorrection):
        if  stop2ErrorCorrection is None:
            stop2ErrorCorrection = 0.8  # default
        assertValidSFFloat(stop2ErrorCorrection)
        assertZeroToOne('stop2ErrorCorrection', stop2ErrorCorrection)
        self.__stop2ErrorCorrection = stop2ErrorCorrection
    @property # getter - - - - - - - - - -
    def body1(self):
        """[RigidBody] The body1 and body2 fields indicate the two RigidBody nodes connected by this joint."""
        return self.__body1
    @body1.setter
    def body1(self, body1):
        if  body1 is None:
            body1 = None  # default
        assertValidSFNode(body1)
        if not body1 is None and not isinstance(body1,(RigidBody,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(body1) + ' does not match required node type (RigidBody,ProtoInstance) and is invalid')
        self.__body1 = body1
    @property # getter - - - - - - - - - -
    def body2(self):
        """[RigidBody] The body1 and body2 fields indicate the two RigidBody nodes connected by this joint."""
        return self.__body2
    @body2.setter
    def body2(self, body2):
        if  body2 is None:
            body2 = None  # default
        assertValidSFNode(body2)
        if not body2 is None and not isinstance(body2,(RigidBody,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(body2) + ' does not match required node type (RigidBody,ProtoInstance) and is invalid')
        self.__body2 = body2
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.body1 or self.body2 or self.IS or self.metadata
    # output function - - - - - - - - - -

class UnlitMaterial(_X3DOneSidedMaterialNode):
    """
    UnlitMaterial specifies surface rendering properties for associated geometry nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'UnlitMaterial'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#UnlitMaterial'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#UnlitMaterial'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('emissiveColor', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'UnlitMaterial'),
        ('emissiveTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
        ('normalScale', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
        ('normalTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
        ('transparency', 0, FieldType.SFFloat, AccessType.inputOutput, 'UnlitMaterial'),
        ('emissiveTexture', None, FieldType.SFNode, AccessType.inputOutput, 'UnlitMaterial'),
        ('normalTexture', None, FieldType.SFNode, AccessType.inputOutput, 'UnlitMaterial'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        emissiveColor=(1, 1, 1),
        emissiveTextureMapping='',
        normalScale=1,
        normalTextureMapping='',
        transparency=0,
        emissiveTexture=None,
        normalTexture=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode UnlitMaterial __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.emissiveColor = emissiveColor
        self.emissiveTextureMapping = emissiveTextureMapping
        self.normalScale = normalScale
        self.normalTextureMapping = normalTextureMapping
        self.transparency = transparency
        self.emissiveTexture = emissiveTexture
        self.normalTexture = normalTexture
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def emissiveColor(self):
        """[0,1] how much glowing light is emitted from this object."""
        return self.__emissiveColor
    @emissiveColor.setter
    def emissiveColor(self, emissiveColor):
        if  emissiveColor is None:
            emissiveColor = (1, 1, 1)  # default
        assertValidSFColor(emissiveColor)
        assertZeroToOne('emissiveColor', emissiveColor)
        self.__emissiveColor = emissiveColor
    @property # getter - - - - - - - - - -
    def emissiveTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__emissiveTextureMapping
    @emissiveTextureMapping.setter
    def emissiveTextureMapping(self, emissiveTextureMapping):
        if  emissiveTextureMapping is None:
            emissiveTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(emissiveTextureMapping)
        self.__emissiveTextureMapping = emissiveTextureMapping
    @property # getter - - - - - - - - - -
    def normalScale(self):
        """[0,infinity] normalScale controls the degree to which normalTexture RGB values apply XYZ-normal bump mapping to pixels in the parent material."""
        return self.__normalScale
    @normalScale.setter
    def normalScale(self, normalScale):
        if  normalScale is None:
            normalScale = 1  # default
        assertValidSFFloat(normalScale)
        assertNonNegative('normalScale', normalScale)
        self.__normalScale = normalScale
    @property # getter - - - - - - - - - -
    def normalTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__normalTextureMapping
    @normalTextureMapping.setter
    def normalTextureMapping(self, normalTextureMapping):
        if  normalTextureMapping is None:
            normalTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(normalTextureMapping)
        self.__normalTextureMapping = normalTextureMapping
    @property # getter - - - - - - - - - -
    def transparency(self):
        """[0,1] how "clear" an object is: 1."""
        return self.__transparency
    @transparency.setter
    def transparency(self, transparency):
        if  transparency is None:
            transparency = 0  # default
        assertValidSFFloat(transparency)
        assertZeroToOne('transparency', transparency)
        self.__transparency = transparency
    @property # getter - - - - - - - - - -
    def emissiveTexture(self):
        """[X3DSingleTextureNode] When applying emissiveColor for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__emissiveTexture
    @emissiveTexture.setter
    def emissiveTexture(self, emissiveTexture):
        if  emissiveTexture is None:
            emissiveTexture = None  # default
        assertValidSFNode(emissiveTexture)
        if not emissiveTexture is None and not isinstance(emissiveTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(emissiveTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__emissiveTexture = emissiveTexture
    @property # getter - - - - - - - - - -
    def normalTexture(self):
        """[X3DSingleTextureNode] When applying normalScale for this material node, the contained texture modulates the texture across the surface."""
        return self.__normalTexture
    @normalTexture.setter
    def normalTexture(self, normalTexture):
        if  normalTexture is None:
            normalTexture = None  # default
        assertValidSFNode(normalTexture)
        if not normalTexture is None and not isinstance(normalTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(normalTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__normalTexture = normalTexture
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.emissiveTexture or self.IS or self.metadata or self.normalTexture
    # output function - - - - - - - - - -

class Viewpoint(_X3DViewpointNode):
    """
    Viewpoint provides a specific location and direction where the user may view the scene.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Viewpoint'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/navigation.html#Viewpoint'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Viewpoint'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('centerOfRotation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'Viewpoint'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DViewpointNode'),
        ('farDistance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DViewpointNode'),
        ('fieldOfView', 0.7854, FieldType.SFFloat, AccessType.inputOutput, 'Viewpoint'),
        ('jump', True, FieldType.SFBool, AccessType.inputOutput, 'X3DViewpointNode'),
        ('nearDistance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DViewpointNode'),
        ('orientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'X3DViewpointNode'),
        ('position', (0, 0, 10), FieldType.SFVec3f, AccessType.inputOutput, 'Viewpoint'),
        ('retainUserOffsets', False, FieldType.SFBool, AccessType.inputOutput, 'X3DViewpointNode'),
        ('viewAll', False, FieldType.SFBool, AccessType.inputOutput, 'X3DViewpointNode'),
        ('navigationInfo', None, FieldType.SFNode, AccessType.inputOutput, 'X3DViewpointNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        centerOfRotation=(0, 0, 0),
        description='',
        farDistance=-1,
        fieldOfView=0.7854,
        jump=True,
        nearDistance=-1,
        orientation=(0, 0, 1, 0),
        position=(0, 0, 10),
        retainUserOffsets=False,
        viewAll=False,
        navigationInfo=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Viewpoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.centerOfRotation = centerOfRotation
        self.description = description
        self.farDistance = farDistance
        self.fieldOfView = fieldOfView
        self.jump = jump
        self.nearDistance = nearDistance
        self.orientation = orientation
        self.position = position
        self.retainUserOffsets = retainUserOffsets
        self.viewAll = viewAll
        self.navigationInfo = navigationInfo
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def centerOfRotation(self):
        """centerOfRotation specifies center point about which to rotate user's eyepoint when in EXAMINE or LOOKAT mode."""
        return self.__centerOfRotation
    @centerOfRotation.setter
    def centerOfRotation(self, centerOfRotation):
        if  centerOfRotation is None:
            centerOfRotation = (0, 0, 0)  # default
        assertValidSFVec3f(centerOfRotation)
        self.__centerOfRotation = centerOfRotation
    @property # getter - - - - - - - - - -
    def description(self):
        """Text description or navigation hint to describe the significance of this model Viewpoint."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def farDistance(self):
        """or (0,+infinity) farDistance defines maximum clipping plane distance allowed for object display."""
        return self.__farDistance
    @farDistance.setter
    def farDistance(self, farDistance):
        if  farDistance is None:
            farDistance = -1  # default
        assertValidSFFloat(farDistance)
        self.__farDistance = farDistance
    @property # getter - - - - - - - - - -
    def fieldOfView(self):
        """Preferred minimum viewing angle from this viewpoint in radians, providing minimum height or minimum width (whichever is smaller)."""
        return self.__fieldOfView
    @fieldOfView.setter
    def fieldOfView(self, fieldOfView):
        if  fieldOfView is None:
            fieldOfView = 0.7854  # default
        assertValidSFFloat(fieldOfView)
        assertGreaterThan('fieldOfView', fieldOfView, 0)
        assertLessThan('fieldOfView', fieldOfView, 3.1416)
        self.__fieldOfView = fieldOfView
    @property # getter - - - - - - - - - -
    def jump(self):
        """Transition instantly by jumping, otherwise smoothly adjust offsets in place when changing to this Viewpoint."""
        return self.__jump
    @jump.setter
    def jump(self, jump):
        if  jump is None:
            jump = True  # default
        assertValidSFBool(jump)
        self.__jump = jump
    @property # getter - - - - - - - - - -
    def nearDistance(self):
        """or (0,+infinity) nearDistance defines minimum clipping plane distance necessary for object display."""
        return self.__nearDistance
    @nearDistance.setter
    def nearDistance(self, nearDistance):
        if  nearDistance is None:
            nearDistance = -1  # default
        assertValidSFFloat(nearDistance)
        self.__nearDistance = nearDistance
    @property # getter - - - - - - - - - -
    def orientation(self):
        """Rotation (axis, angle in radians) of Viewpoint, relative to default -Z axis direction in local coordinate system."""
        return self.__orientation
    @orientation.setter
    def orientation(self, orientation):
        if  orientation is None:
            orientation = (0, 0, 1, 0)  # default
        assertValidSFRotation(orientation)
        self.__orientation = orientation
    @property # getter - - - - - - - - - -
    def position(self):
        """position (x, y, z in meters) relative to local coordinate system."""
        return self.__position
    @position.setter
    def position(self, position):
        if  position is None:
            position = (0, 0, 10)  # default
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def retainUserOffsets(self):
        """Retain (true) or reset to zero (false) any prior user navigation offsets from defined viewpoint position, orientation."""
        return self.__retainUserOffsets
    @retainUserOffsets.setter
    def retainUserOffsets(self, retainUserOffsets):
        if  retainUserOffsets is None:
            retainUserOffsets = False  # default
        assertValidSFBool(retainUserOffsets)
        self.__retainUserOffsets = retainUserOffsets
    @property # getter - - - - - - - - - -
    def viewAll(self):
        """Viewpoint is automatically adjusted to view all visible geometry."""
        return self.__viewAll
    @viewAll.setter
    def viewAll(self, viewAll):
        if  viewAll is None:
            viewAll = False  # default
        assertValidSFBool(viewAll)
        self.__viewAll = viewAll
    @property # getter - - - - - - - - - -
    def navigationInfo(self):
        """[NavigationInfo] The navigationInfo field defines a dedicated NavigationInfo node for this X3DViewpointNode."""
        return self.__navigationInfo
    @navigationInfo.setter
    def navigationInfo(self, navigationInfo):
        if  navigationInfo is None:
            navigationInfo = None  # default
        assertValidSFNode(navigationInfo)
        if not navigationInfo is None and not isinstance(navigationInfo,(NavigationInfo,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(navigationInfo) + ' does not match required node type (NavigationInfo,ProtoInstance) and is invalid')
        self.__navigationInfo = navigationInfo
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.navigationInfo
    # output function - - - - - - - - - -

class ViewpointGroup(_X3DChildNode):
    """
    ViewpointGroup can contain Viewpoint, OrthoViewpoint, GeoViewpoint and other ViewpointGroup nodes for better user-navigation support with a shared description on the viewpoint list.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ViewpointGroup'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/navigation.html#ViewpointGroup'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ViewpointGroup'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'ViewpointGroup'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'ViewpointGroup'),
        ('displayed', True, FieldType.SFBool, AccessType.inputOutput, 'ViewpointGroup'),
        ('retainUserOffsets', False, FieldType.SFBool, AccessType.inputOutput, 'ViewpointGroup'),
        ('size', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'ViewpointGroup'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'ViewpointGroup'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        center=(0, 0, 0),
        description='',
        displayed=True,
        retainUserOffsets=False,
        size=(0, 0, 0),
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode ViewpointGroup __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.center = center
        self.description = description
        self.displayed = displayed
        self.retainUserOffsets = retainUserOffsets
        self.size = size
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def center(self):
        """center specifies center point of proximity box within which ViewpointGroup is usable and displayed on viewpoint list."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0)  # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def description(self):
        """Text description or navigation hint to identify this ViewpointGroup."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def displayed(self):
        """displayed determines whether this ViewpointGroup is displayed in the current viewpoint list."""
        return self.__displayed
    @displayed.setter
    def displayed(self, displayed):
        if  displayed is None:
            displayed = True  # default
        assertValidSFBool(displayed)
        self.__displayed = displayed
    @property # getter - - - - - - - - - -
    def retainUserOffsets(self):
        """Retain (true) or reset to zero (false) any prior user navigation offsets from defined viewpoint position, orientation."""
        return self.__retainUserOffsets
    @retainUserOffsets.setter
    def retainUserOffsets(self, retainUserOffsets):
        if  retainUserOffsets is None:
            retainUserOffsets = False  # default
        assertValidSFBool(retainUserOffsets)
        self.__retainUserOffsets = retainUserOffsets
    @property # getter - - - - - - - - - -
    def size(self):
        """[0,+infinity) size of Proximity box around center location, oriented within local transformation frame, within which ViewpointGroup is usable and displayed on viewpoint list."""
        return self.__size
    @size.setter
    def size(self, size):
        if  size is None:
            size = (0, 0, 0)  # default
        assertValidSFVec3f(size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] ViewpointGroup contains Viewpoint, OrthoViewpoint, GeoViewpoint and other ViewpointGroup nodes that each have containerField='children' default value."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class Viewport(_X3DViewportNode):
    """
    Viewport is a Grouping node that can contain most nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Viewport'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/layering.html#Viewport'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Viewport'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
        ('clipBoundary', [0, 1, 0, 1], FieldType.MFFloat, AccessType.inputOutput, 'Viewport'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        clipBoundary=None,
        visible=True,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Viewport __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.clipBoundary = clipBoundary
        self.visible = visible
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def clipBoundary(self):
        """[0,1] clipBoundary is specified in fractions of the normal render surface in the sequence left/right/bottom/top."""
        return self.__clipBoundary
    @clipBoundary.setter
    def clipBoundary(self, clipBoundary):
        if  clipBoundary is None:
            clipBoundary = [0, 1, 0, 1]  # default
        assertValidMFFloat(clipBoundary)
        assertZeroToOne('clipBoundary', clipBoundary)
        self.__clipBoundary = clipBoundary
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class VisibilitySensor(_X3DEnvironmentalSensorNode):
    """
    VisibilitySensor detects when user can see a specific object or region as they navigate the world.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'VisibilitySensor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalSensor.html#VisibilitySensor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#VisibilitySensor'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'VisibilitySensor'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSensorNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('size', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'X3DEnvironmentalSensorNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        center=(0, 0, 0),
        description='',
        enabled=True,
        size=(0, 0, 0),
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode VisibilitySensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.center = center
        self.description = description
        self.enabled = enabled
        self.size = size
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def center(self):
        """Translation offset from origin of local coordinate system."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0)  # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def size(self):
        """[0,+infinity) size of visibility box around center location, oriented within local transformation frame."""
        return self.__size
    @size.setter
    def size(self, size):
        if  size is None:
            size = (0, 0, 0)  # default
        assertValidSFVec3f(size)
        assertNonNegative('size', size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class VolumeData(_X3DVolumeDataNode):
    """
    VolumeData displays a simple non-segmented voxel dataset with a single RenderStyle node.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'VolumeData'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#VolumeData'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#VolumeData'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DVolumeDataNode'),
        ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeDataNode'),
        ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DVolumeDataNode'),
        ('dimensions', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'X3DVolumeDataNode'),
        ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeDataNode'),
        ('renderStyle', None, FieldType.SFNode, AccessType.inputOutput, 'VolumeData'),
        ('voxels', None, FieldType.SFNode, AccessType.inputOutput, 'VolumeData'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        bboxCenter=(0, 0, 0),
        bboxDisplay=False,
        bboxSize=(-1, -1, -1),
        dimensions=(1, 1, 1),
        visible=True,
        renderStyle=None,
        voxels=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode VolumeData __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.dimensions = dimensions
        self.visible = visible
        self.renderStyle = renderStyle
        self.voxels = voxels
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0)  # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False  # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1)  # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def dimensions(self):
        """Actual-size X-Y-Z dimensions of volume data in local coordinate system."""
        return self.__dimensions
    @dimensions.setter
    def dimensions(self, dimensions):
        if  dimensions is None:
            dimensions = (1, 1, 1)  # default
        assertValidSFVec3f(dimensions)
        assertPositive('dimensions', dimensions)
        self.__dimensions = dimensions
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True  # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def renderStyle(self):
        """[X3DVolumeRenderStyleNode] Single contained X3DVolumeRenderStyleNode node that defines specific rendering technique for this volumetric object."""
        return self.__renderStyle
    @renderStyle.setter
    def renderStyle(self, renderStyle):
        if  renderStyle is None:
            renderStyle = None  # default
        assertValidSFNode(renderStyle)
        if not renderStyle is None and not isinstance(renderStyle,(_X3DVolumeRenderStyleNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(renderStyle) + ' does not match required node type (_X3DVolumeRenderStyleNode,ProtoInstance) and is invalid')
        self.__renderStyle = renderStyle
    @property # getter - - - - - - - - - -
    def voxels(self):
        """[X3DTexture3DNode] Single contained X3DTexture3DNode (ComposedTexture3D, ImageTexture3D, PixelTexture3D) that provides raw voxel information utilized by corresponding rendering styles."""
        return self.__voxels
    @voxels.setter
    def voxels(self, voxels):
        if  voxels is None:
            voxels = None  # default
        assertValidSFNode(voxels)
        if not voxels is None and not isinstance(voxels,(_X3DTexture3DNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(voxels) + ' does not match required node type (_X3DTexture3DNode,ProtoInstance) and is invalid')
        self.__voxels = voxels
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.renderStyle or self.voxels
    # output function - - - - - - - - - -

class VolumeEmitter(_X3DParticleEmitterNode):
    """
    VolumeEmitter emits particles from a random position confined within the given closed geometry volume.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'VolumeEmitter'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#VolumeEmitter'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#VolumeEmitter'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('coordIndex', [-1], FieldType.MFInt32, AccessType.initializeOnly, 'VolumeEmitter'),
        ('direction', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'VolumeEmitter'),
        ('internal', True, FieldType.SFBool, AccessType.initializeOnly, 'VolumeEmitter'),
        ('mass', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('on', True, FieldType.SFBool, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('speed', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('surfaceArea', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('variation', 0.25, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
        ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'VolumeEmitter'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        coordIndex=None,
        direction=(0, 1, 0),
        internal=True,
        mass=0,
        on=True,
        speed=0,
        surfaceArea=0,
        variation=0.25,
        coord=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode VolumeEmitter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.coordIndex = coordIndex
        self.direction = direction
        self.internal = internal
        self.mass = mass
        self.on = on
        self.speed = speed
        self.surfaceArea = surfaceArea
        self.variation = variation
        self.coord = coord
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def coordIndex(self):
        """[-1,+infinity) coordIndex indices are applied to contained Coordinate values in order to define randomly generated initial geometry of the particles."""
        return self.__coordIndex
    @coordIndex.setter
    def coordIndex(self, coordIndex):
        if  coordIndex is None:
            coordIndex = [-1]  # default
        assertValidMFInt32(coordIndex)
        assertGreaterThanEquals('coordIndex', coordIndex, -1)
        self.__coordIndex = coordIndex
    @property # getter - - - - - - - - - -
    def direction(self):
        """Initial direction from which particles emanate."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (0, 1, 0)  # default
        assertValidSFVec3f(direction)
        assertGreaterThanEquals('direction', direction, -1)
        assertLessThanEquals('direction', direction, 1)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def internal(self):
        """TODO, X3D specification is undefined."""
        return self.__internal
    @internal.setter
    def internal(self, internal):
        if  internal is None:
            internal = True  # default
        assertValidSFBool(internal)
        self.__internal = internal
    @property # getter - - - - - - - - - -
    def mass(self):
        """[0,+infinity) Basic mass of each particle, defined in mass base units (default is kilograms)."""
        return self.__mass
    @mass.setter
    def mass(self, mass):
        if  mass is None:
            mass = 0  # default
        assertValidSFFloat(mass)
        assertNonNegative('mass', mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def on(self):
        """Enables/disables production of particles from this emitter node."""
        return self.__on
    @on.setter
    def on(self, on):
        if  on is None:
            on = True  # default
        assertValidSFBool(on)
        self.__on = on
    @property # getter - - - - - - - - - -
    def speed(self):
        """[0,+infinity) Initial linear speed (default is m/s) imparted to all particles along their direction of movement."""
        return self.__speed
    @speed.setter
    def speed(self, speed):
        if  speed is None:
            speed = 0  # default
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def surfaceArea(self):
        """[0,+infinity) Particle surface area in area base units (default is meters squared)."""
        return self.__surfaceArea
    @surfaceArea.setter
    def surfaceArea(self, surfaceArea):
        if  surfaceArea is None:
            surfaceArea = 0  # default
        assertValidSFFloat(surfaceArea)
        assertNonNegative('surfaceArea', surfaceArea)
        self.__surfaceArea = surfaceArea
    @property # getter - - - - - - - - - -
    def variation(self):
        """[0,+infinity) Multiplier for the randomness used to control the range of possible output values."""
        return self.__variation
    @variation.setter
    def variation(self, variation):
        if  variation is None:
            variation = 0.25  # default
        assertValidSFFloat(variation)
        assertNonNegative('variation', variation)
        self.__variation = variation
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Coordinates for the geometry used as the emitting volume."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None  # default
        assertValidSFNode(coord)
        if not coord is None and not isinstance(coord,(_X3DCoordinateNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not match required node type (_X3DCoordinateNode,ProtoInstance) and is invalid')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.coord or self.IS or self.metadata
    # output function - - - - - - - - - -

class VolumePickSensor(_X3DPickSensorNode):
    """
    VolumePickSensor tests picking intersections using the pickingGeometry against the pickTarget geometry volume.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'VolumePickSensor'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/picking.html#VolumePickSensor'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#VolumePickSensor'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSensorNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
        ('intersectionType', 'BOUNDS', FieldType.SFString, AccessType.initializeOnly, 'X3DPickSensorNode'),
        ('matchCriterion', 'MATCH_ANY', FieldType.SFString, AccessType.inputOutput, 'X3DPickSensorNode'),
        ('objectType', ["ALL"], FieldType.MFString, AccessType.inputOutput, 'X3DPickSensorNode'),
        ('sortOrder', 'CLOSEST', FieldType.SFString, AccessType.initializeOnly, 'X3DPickSensorNode'),
        ('pickingGeometry', None, FieldType.SFNode, AccessType.inputOutput, 'X3DPickSensorNode'),
        ('pickTarget', [], FieldType.MFNode, AccessType.inputOutput, 'X3DPickSensorNode'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        description='',
        enabled=True,
        intersectionType='BOUNDS',
        matchCriterion='MATCH_ANY',
        objectType=None,
        sortOrder='CLOSEST',
        pickingGeometry=None,
        pickTarget=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode VolumePickSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.enabled = enabled
        self.intersectionType = intersectionType
        self.matchCriterion = matchCriterion
        self.objectType = objectType
        self.sortOrder = sortOrder
        self.pickingGeometry = pickingGeometry
        self.pickTarget = pickTarget
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def intersectionType(self):
        """intersectionType specifies precision of the collision computation."""
        return self.__intersectionType
    @intersectionType.setter
    def intersectionType(self, intersectionType):
        if  intersectionType is None:
            intersectionType = 'BOUNDS'  # default
        assertValidSFString(intersectionType)
        self.__intersectionType = intersectionType
    @property # getter - - - - - - - - - -
    def matchCriterion(self):
        """defines whether the intersection test (i."""
        return self.__matchCriterion
    @matchCriterion.setter
    def matchCriterion(self, matchCriterion):
        if  matchCriterion is None:
            matchCriterion = 'MATCH_ANY'  # default
        assertValidSFString(matchCriterion)
        assertValidPickSensorMatchCriterion('matchCriterion', matchCriterion)
        self.__matchCriterion = matchCriterion
    @property # getter - - - - - - - - - -
    def objectType(self):
        """The objectType field specifies a set of labels used in the picking process."""
        return self.__objectType
    @objectType.setter
    def objectType(self, objectType):
        if  objectType is None:
            objectType = ["ALL"]  # default
        assertValidMFString(objectType)
        self.__objectType = objectType
    @property # getter - - - - - - - - - -
    def sortOrder(self):
        """The sortOrder field determines the order provided for picked output events."""
        return self.__sortOrder
    @sortOrder.setter
    def sortOrder(self, sortOrder):
        if  sortOrder is None:
            sortOrder = 'CLOSEST'  # default
        assertValidSFString(sortOrder)
        self.__sortOrder = sortOrder
    @property # getter - - - - - - - - - -
    def pickingGeometry(self):
        """[X3DGeometryNode] pickingGeometry specifies the exact geometry coordinates that are used to perform the intersection testing of the picking operation."""
        return self.__pickingGeometry
    @pickingGeometry.setter
    def pickingGeometry(self, pickingGeometry):
        if  pickingGeometry is None:
            pickingGeometry = None  # default
        assertValidSFNode(pickingGeometry)
        if not pickingGeometry is None and not isinstance(pickingGeometry,(_X3DGeometryNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(pickingGeometry) + ' does not match required node type (_X3DGeometryNode,ProtoInstance) and is invalid')
        self.__pickingGeometry = pickingGeometry
    @property # getter - - - - - - - - - -
    def pickTarget(self):
        """[X3DGroupingNode|X3DShapeNode|Inline] pickTarget specifies the list of nodes against which picking operations are performed."""
        return self.__pickTarget
    @pickTarget.setter
    def pickTarget(self, pickTarget):
        if  pickTarget is None:
            pickTarget = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(pickTarget)
        self.__pickTarget = pickTarget
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or self.pickingGeometry or (len(self.pickTarget) > 0)
    # output function - - - - - - - - - -

class WaveShaper(_X3DSoundProcessingNode):
    """
    WaveShaper node represents a nonlinear distorter that applies a wave-shaping distortion curve to the signal.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'WaveShaper'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#WaveShaper'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#WaveShaper'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('channelCountMode', 'MAX', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('channelInterpretation', 'SPEAKERS', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('oversample', 'NONE', FieldType.SFString, AccessType.inputOutput, 'WaveShaper'),
        ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
        ('tailTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DSoundProcessingNode'),
        ('children', [], FieldType.MFNode, AccessType.inputOutput, 'WaveShaper'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        channelCountMode='MAX',
        channelInterpretation='SPEAKERS',
        description='',
        enabled=True,
        gain=1,
        oversample='NONE',
        pauseTime=0,
        resumeTime=0,
        startTime=0,
        stopTime=0,
        tailTime=0,
        children=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode WaveShaper __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.oversample = oversample
        self.pauseTime = pauseTime
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
        self.tailTime = tailTime
        self.children = children
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'MAX'  # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'SPEAKERS'  # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1  # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def oversample(self):
        """The oversample field is specifies what type of oversampling (if any) should be used when applying the shaping curve."""
        return self.__oversample
    @oversample.setter
    def oversample(self, oversample):
        if  oversample is None:
            oversample = 'NONE'  # default
        assertValidSFString(oversample)
        assertValidWaveShaperOversample('oversample', oversample)
        self.__oversample = oversample
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0  # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0  # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0  # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0  # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def tailTime(self):
        """[0,+infinity) tailTime is duration of time that a node continues to provide output signal after the input signal becomes silent."""
        return self.__tailTime
    @tailTime.setter
    def tailTime(self, tailTime):
        if  tailTime is None:
            tailTime = 0  # default
        assertValidSFTime(tailTime)
        assertNonNegative('tailTime', tailTime)
        self.__tailTime = tailTime
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DSoundChannelNode|X3DSoundProcessingNode|X3DSoundSourceNode] The children field specifies audio-graph sound sources providing input signals for this node."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata or (len(self.children) > 0)
    # output function - - - - - - - - - -

class WindPhysicsModel(_X3DParticlePhysicsModelNode):
    """
    WindPhysicsModel applies a wind effect to the particles.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'WindPhysicsModel'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#WindPhysicsModel'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#WindPhysicsModel'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('direction', (1, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'WindPhysicsModel'),
        ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DParticlePhysicsModelNode'),
        ('gustiness', 0.1, FieldType.SFFloat, AccessType.inputOutput, 'WindPhysicsModel'),
        ('speed', 0.1, FieldType.SFFloat, AccessType.inputOutput, 'WindPhysicsModel'),
        ('turbulence', 0, FieldType.SFFloat, AccessType.inputOutput, 'WindPhysicsModel'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        direction=(1, 0, 0),
        enabled=True,
        gustiness=0.1,
        speed=0.1,
        turbulence=0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode WindPhysicsModel __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.direction = direction
        self.enabled = enabled
        self.gustiness = gustiness
        self.speed = speed
        self.turbulence = turbulence
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def direction(self):
        """direction in which wind is travelling in the form of a normalized, unit vector."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (1, 0, 0)  # default
        assertValidSFVec3f(direction)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True  # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gustiness(self):
        """[0,+infinity) gustiness specifies how much wind speed varies from the average speed."""
        return self.__gustiness
    @gustiness.setter
    def gustiness(self, gustiness):
        if  gustiness is None:
            gustiness = 0.1  # default
        assertValidSFFloat(gustiness)
        assertNonNegative('gustiness', gustiness)
        self.__gustiness = gustiness
    @property # getter - - - - - - - - - -
    def speed(self):
        """[0,+infinity) Initial linear speed (default is m/s) imparted to all particles along their direction of movement."""
        return self.__speed
    @speed.setter
    def speed(self, speed):
        if  speed is None:
            speed = 0.1  # default
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def turbulence(self):
        """[0,1] turbulence field specifies how much the wind acts directly in line with the direction, and how much variation is applied in directions other than the wind direction."""
        return self.__turbulence
    @turbulence.setter
    def turbulence(self, turbulence):
        if  turbulence is None:
            turbulence = 0  # default
        assertValidSFFloat(turbulence)
        assertZeroToOne('turbulence', turbulence)
        self.__turbulence = turbulence
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -

class WorldInfo(_X3DInfoNode):
    """
    WorldInfo contains a title and simple persistent metadata information about an X3D scene. This node is strictly for documentation purposes and has no effect on the visual appearance or behaviour of the world.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'WorldInfo'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#WorldInfo'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#WorldInfo'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('info', [], FieldType.MFString, AccessType.inputOutput, 'WorldInfo'),
        ('title', '', FieldType.SFString, AccessType.inputOutput, 'WorldInfo'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        info=None,
        title='',
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode WorldInfo __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.info = info
        self.title = title
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def info(self):
        """Additional information about this model."""
        return self.__info
    @info.setter
    def info(self, info):
        if  info is None:
            info = MFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFString.DEFAULT_VALUE()))
        assertValidMFString(info)
        self.__info = info
    @property # getter - - - - - - - - - -
    def title(self):
        """title of this world, placed in window title."""
        return self.__title
    @title.setter
    def title(self, title):
        if  title is None:
            title = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(title)
        self.__title = title
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -


class CGESkin(_X3DChildNode):
    """
    Skin defines Castle Game Engine character.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'Skin'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://castle-engine.io/skin'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://castle-engine.io/skin'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('inverseBindMatrices', [], FieldType.MFMatrix4f, AccessType.initializeOnly, 'CGESkin'),
        ('shapes',              [], FieldType.MFNode,     AccessType.initializeOnly, 'CGESkin'),
        ('skeleton',          None, FieldType.SFNode,     AccessType.inputOutput,    'CGESkin'),
        ('joints',              [], FieldType.MFNode,     AccessType.initializeOnly, 'CGESkin'),
        ('DEF',                 '', FieldType.SFString,   AccessType.inputOutput, 'X3DNode'),
        ('USE',                 '', FieldType.SFString,   AccessType.inputOutput, 'X3DNode'),
        ('class_',              '', FieldType.SFString,   AccessType.inputOutput, 'X3DNode'),
        ('id_',                 '', FieldType.SFString,   AccessType.inputOutput, 'X3DNode'),
        ('style_',              '', FieldType.SFString,   AccessType.inputOutput, 'X3DNode'),
        ('IS',                None, FieldType.SFNode,     AccessType.inputOutput, 'X3DNode'),
        ('metadata',          None, FieldType.SFNode,     AccessType.inputOutput, 'X3DNode')]
        
    def __init__(self, DEF='', USE='', class_='', id_='', style_='', IS=None, metadata=None, inverseBindMatrices=None, shapes=None, skeleton=None, joints=None):
        # fields for _X3DNode only
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata)
        self.inverseBindMatrices = inverseBindMatrices
        self.shapes   = shapes
        self.skeleton = skeleton
        self.joints   = joints
    
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
        
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
        
    @property # getter - - - - - - - - - -
    def inverseBindMatrices(self):
        """inverseBindMatrices specifies an arbitrary collection of matrix inverseBindMatricess that will be passed to the shader as per-vertex information."""
        return self.__inverseBindMatrices
    @inverseBindMatrices.setter
    def inverseBindMatrices(self, inverseBindMatrices):
        if  inverseBindMatrices is None:
            inverseBindMatrices = MFMatrix4f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set inverseBindMatrices to .DEFAULT_VALUE()=' + str(MFMatrix4f.DEFAULT_VALUE()))
        assertValidMFMatrix4f(inverseBindMatrices)
        self.__inverseBindMatrices = inverseBindMatrices

    @property # getter - - - - - - - - - -
    def shapes(self):
        """[Shapes] Multiple Shape nodes that serve as the Chracter meshes."""
        return self.__shapes
    @shapes.setter
    def shapes(self, shapes):
        if  shapes is None:
            shapes = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(shapes)
        self.__shapes = shapes

    @property # getter - - - - - - - - - -
    def skeleton(self):
        """[X3DGroupingNode] Single grouping node (Transform or HAnimJoint)"""
        return self.__skeleton
    @skeleton.setter
    def skeleton(self, skeleton):
        if  skeleton is None:
            skeleton = None  # default
        assertValidSFNode(skeleton)
        if not skeleton is None and not isinstance(skeleton, (Transform, HAnimJoint, ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(skeleton) + ' does not match required node type (Transform,HAnimJoint,ProtoInstance) and is invalid')
        self.__skeleton = skeleton

    @property # getter - - - - - - - - - -
    def joints(self):
        """[Transform/HAnimJoint nodes] list of joint nodes found in the decendents of Character's skeleton field."""
        return self.__joints
    @joints.setter
    def joints(self, joints):
        if  joints is None:
            joints = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(joints)
        self.__joints = joints

    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.shapes or self.skeleton or self.joints or self.IS or self.metadata


class CGEIndexedFaceSet(_X3DComposedGeometryNode):
    """
    IndexedFaceSet defines polygons using index lists corresponding to vertex coordinates.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'IndexedFaceSet'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry3D.html#IndexedFaceSet'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IndexedFaceSet'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('DEF',               '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE',               '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('class_',            '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_',               '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_',            '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS',              None, FieldType.SFNode,   AccessType.inputOutput, 'X3DNode'),
        ('metadata',        None, FieldType.SFNode,   AccessType.inputOutput, 'X3DNode'),
        
        ('ccw',             True, FieldType.SFBool,   AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('colorIndex',        [], FieldType.MFInt32,  AccessType.initializeOnly, 'IndexedFaceSet'),
        ('colorPerVertex',  True, FieldType.SFBool,   AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('convex',          True, FieldType.SFBool,   AccessType.initializeOnly, 'IndexedFaceSet'),
        ('coordIndex',        [], FieldType.MFInt32,  AccessType.initializeOnly, 'IndexedFaceSet'),
        ('creaseAngle',        0, FieldType.SFFloat,  AccessType.initializeOnly, 'IndexedFaceSet'),
        ('normalIndex',       [], FieldType.MFInt32,  AccessType.initializeOnly, 'IndexedFaceSet'),
        ('normalPerVertex', True, FieldType.SFBool,   AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('solid',           True, FieldType.SFBool,   AccessType.initializeOnly, 'X3DComposedGeometryNode'),
        ('texCoordIndex',     [], FieldType.MFInt32,  AccessType.initializeOnly, 'IndexedFaceSet'),
        ('color',           None, FieldType.SFNode,   AccessType.inputOutput,    'X3DComposedGeometryNode'),
        ('coord',           None, FieldType.SFNode,   AccessType.inputOutput,    'X3DComposedGeometryNode'),
        ('fogCoord',        None, FieldType.SFNode,   AccessType.inputOutput,    'X3DComposedGeometryNode'),
        ('normal',          None, FieldType.SFNode,   AccessType.inputOutput,    'X3DComposedGeometryNode'),
        ('texCoord',        None, FieldType.SFNode,   AccessType.inputOutput,    'X3DComposedGeometryNode'),
        ('attrib',            [], FieldType.MFNode,   AccessType.inputOutput,    'X3DComposedGeometryNode'),
        ('skinJoints0',       [], FieldType.MFInt32,  AccessType.initializeOnly, 'IndexedFaceSet'),
        ('skinJoints1',       [], FieldType.MFInt32,  AccessType.initializeOnly, 'IndexedFaceSet'),
        ('skinWeights0',      [], FieldType.MFVec4f,  AccessType.initializeOnly, 'IndexedFaceSet'),
        ('skinWeights1',      [], FieldType.MFVec4f,  AccessType.initializeOnly, 'IndexedFaceSet')]
    def __init__(self,
        DEF='',
        USE='',
        class_='',
        id_='',
        style_='',
        IS=None,
        metadata=None,
        ccw=True,
        colorIndex=None,
        colorPerVertex=True,
        convex=True,
        coordIndex=None,
        creaseAngle=0,
        normalIndex=None,
        normalPerVertex=True,
        solid=True,
        texCoordIndex=None,
        color=None,
        coord=None,
        fogCoord=None,
        normal=None,
        texCoord=None,
        attrib=None,
        skinJoints0=None,
        skinJoints1=None,
        skinWeights0=None,
        skinWeights1=None):
        # if _DEBUG: print('...DEBUG... in ConcreteNode IndexedFaceSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorIndex = colorIndex
        self.colorPerVertex = colorPerVertex
        self.convex = convex
        self.coordIndex = coordIndex
        self.creaseAngle = creaseAngle
        self.normalIndex = normalIndex
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.texCoordIndex = texCoordIndex
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
        self.id_ = id_
        self.style_ = style_
        self.skinJoints0 = skinJoints0
        self.skinJoints1 = skinJoints1
        self.skinWeights0 = skinWeights0
        self.skinWeights1 = skinWeights1
        
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True  # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorIndex(self):
        """[-1,+infinity) colorIndex values define the order in which Color|ColorRGBA values are applied to polygons (or vertices), interspersed by -1 if colorlPerVertex=true."""
        return self.__colorIndex
    @colorIndex.setter
    def colorIndex(self, colorIndex):
        if  colorIndex is None:
            colorIndex = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(colorIndex)
        assertGreaterThanEquals('colorIndex', colorIndex, -1)
        self.__colorIndex = colorIndex
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color|ColorRGBA values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True  # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def convex(self):
        """The convex field is a hint to renderers whether all polygons in a shape are convex (true), or possibly concave (false)."""
        return self.__convex
    @convex.setter
    def convex(self, convex):
        if  convex is None:
            convex = True  # default
        assertValidSFBool(convex)
        self.__convex = convex
    @property # getter - - - - - - - - - -
    def coordIndex(self):
        """[-1,+infinity) coordIndex indices provide the order in which coordinates are applied to construct each polygon face."""
        return self.__coordIndex
    @coordIndex.setter
    def coordIndex(self, coordIndex):
        if  coordIndex is None:
            coordIndex = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(coordIndex)
        assertGreaterThanEquals('coordIndex', coordIndex, -1)
        self.__coordIndex = coordIndex
    @property # getter - - - - - - - - - -
    def creaseAngle(self):
        """[0,+infinity) creaseAngle defines angle (in radians) for determining whether adjacent polygons are drawn with sharp edges or smooth shading."""
        return self.__creaseAngle
    @creaseAngle.setter
    def creaseAngle(self, creaseAngle):
        if  creaseAngle is None:
            creaseAngle = 0  # default
        assertValidSFFloat(creaseAngle)
        assertNonNegative('creaseAngle', creaseAngle)
        self.__creaseAngle = creaseAngle
    @property # getter - - - - - - - - - -
    def normalIndex(self):
        """[-1,+infinity) normalIndex values define the order in which normal vectors are applied to polygons (or vertices), interspersed by -1 if normalPerVertex=true."""
        return self.__normalIndex
    @normalIndex.setter
    def normalIndex(self, normalIndex):
        if  normalIndex is None:
            normalIndex = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(normalIndex)
        assertGreaterThanEquals('normalIndex', normalIndex, -1)
        self.__normalIndex = normalIndex
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True  # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True  # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def texCoordIndex(self):
        """[-1,+infinity) List of texture-coordinate indices mapping attached texture to corresponding coordinates."""
        return self.__texCoordIndex
    @texCoordIndex.setter
    def texCoordIndex(self, texCoordIndex):
        if  texCoordIndex is None:
            texCoordIndex = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(texCoordIndex)
        assertGreaterThanEquals('texCoordIndex', texCoordIndex, -1)
        self.__texCoordIndex = texCoordIndex
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that can specify color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None  # default
        assertValidSFNode(color)
        if not color is None and not isinstance(color,(_X3DColorNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not match required node type (_X3DColorNode,ProtoInstance) and is invalid')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that can specify a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None  # default
        assertValidSFNode(coord)
        if not coord is None and not isinstance(coord,(_X3DCoordinateNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not match required node type (_X3DCoordinateNode,ProtoInstance) and is invalid')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that can specify depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None  # default
        assertValidSFNode(fogCoord)
        if not fogCoord is None and not isinstance(fogCoord,(FogCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not match required node type (FogCoordinate,ProtoInstance) and is invalid')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that can specify perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None  # default
        assertValidSFNode(normal)
        if not normal is None and not isinstance(normal,(_X3DNormalNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not match required node type (_X3DNormalNode,ProtoInstance) and is invalid')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that can specify coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None  # default
        assertValidSFNode(texCoord)
        if not texCoord is None and not isinstance(texCoord,(_X3DSingleTextureCoordinateNode,MultiTextureCoordinate,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not match required node type (_X3DSingleTextureCoordinateNode,MultiTextureCoordinate,ProtoInstance) and is invalid')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that can specify list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(attrib)
        self.__attrib = attrib
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_

    @property # getter - - - - - - - - - -
    def skinJoints0(self):
        """[0,+infinity) coordIndex indices provide the order in which coordinates are applied to construct each polygon face."""
        return self.__skinJoints0
    @skinJoints0.setter
    def skinJoints0(self, skinJoints0):
        if  skinJoints0 is None:
            skinJoints0 = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(skinJoints0)
        assertGreaterThanEquals('skinJoints0', skinJoints0, 0)
        self.__skinJoints0 = skinJoints0
    @property # getter - - - - - - - - - -
    def skinJoints1(self):
        """[0,+infinity) coordIndex indices provide the order in which coordinates are applied to construct each polygon face."""
        return self.__skinJoints1
    @skinJoints1.setter
    def skinJoints1(self, skinJoints1):
        if  skinJoints1 is None:
            skinJoints1 = MFInt32.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFInt32(skinJoints1)
        assertGreaterThanEquals('skinJoints1', skinJoints1, 0)
        self.__skinJoints1 = skinJoints1
    @property # getter - - - - - - - - - -
    def skinWeights0(self):
        """[0,1.0) coordIndex indices provide the order in which coordinates are applied to construct each polygon face."""
        return self.__skinWeights0
    @skinWeights0.setter
    def skinWeights0(self, skinWeights0):
        if  skinWeights0 is None:
            skinWeights0 = MFVec4f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFVec4f(skinWeights0)
        assertGreaterThanEquals('skinWeights0', skinWeights0, 0.0)
        assertLessThanEquals('skinWeights0', skinWeights0, 1.0)
        self.__skinWeights0 = skinWeights0
    @property # getter - - - - - - - - - -
    def skinWeights1(self):
        """[0,1.0) coordIndex indices provide the order in which coordinates are applied to construct each polygon face."""
        return self.__skinWeights1
    @skinWeights0.setter
    def skinWeights1(self, skinWeights1):
        if  skinWeights1 is None:
            skinWeights1 = MFVec4f.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFInt32.DEFAULT_VALUE()))
        assertValidMFVec4f(skinWeights1)
        assertGreaterThanEquals('skinWeights1', skinWeights1, 0.0)
        assertLessThanEquals('skinWeights1', skinWeights1, 1.0)
        self.__skinWeights1 = skinWeights1

    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or self.texCoord or (len(self.attrib) > 0)


class _X3DMaterialExtensionNode(_X3DNode):
    """
    Add extensions to material nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Abstract Type class. """
        return '_X3DMaterialExtensionNode'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'NA - Aaron does not have this infomration'


class PhysicalMaterialExt(_X3DOneSidedMaterialNode):
    """
    PhysicalMaterialExt specifies surface rendering properties for associated geometry nodes with an additional 'extensions' field.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'PhysicalMaterial'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#PhysicalMaterial'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PhysicalMaterial'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('baseColor', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'PhysicalMaterialExt'),
        ('baseTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'PhysicalMaterialExt'),
        ('emissiveColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput, 'PhysicalMaterialExt'),
        ('emissiveTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
        ('metallic', 1, FieldType.SFFloat, AccessType.inputOutput, 'PhysicalMaterialExt'),
        ('metallicRoughnessTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'PhysicalMaterialExt'),
        ('normalScale', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
        ('normalTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
        ('occlusionStrength', 1, FieldType.SFFloat, AccessType.inputOutput, 'PhysicalMaterialExt'),
        ('occlusionTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'PhysicalMaterialExt'),
        ('roughness', 1, FieldType.SFFloat, AccessType.inputOutput, 'PhysicalMaterialExt'),
        ('transparency', 0, FieldType.SFFloat, AccessType.inputOutput, 'PhysicalMaterialExt'),
        ('baseTexture', None, FieldType.SFNode, AccessType.inputOutput, 'PhysicalMaterialExt'),
        ('emissiveTexture', None, FieldType.SFNode, AccessType.inputOutput, 'PhysicalMaterialExt'),
        ('extensions', [], FieldType.MFNode, AccessType.inputOutput, 'PhysicalMaterialExt'),
        ('metallicRoughnessTexture', None, FieldType.SFNode, AccessType.inputOutput, 'PhysicalMaterialExt'),
        ('normalTexture', None, FieldType.SFNode, AccessType.inputOutput, 'PhysicalMaterialExt'),
        ('occlusionTexture', None, FieldType.SFNode, AccessType.inputOutput, 'PhysicalMaterialExt'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        baseColor=(1, 1, 1),
        baseTextureMapping='',
        emissiveColor=(0, 0, 0),
        emissiveTextureMapping='',
        metallic=1,
        metallicRoughnessTextureMapping='',
        normalScale=1,
        normalTextureMapping='',
        occlusionStrength=1,
        occlusionTextureMapping='',
        roughness=1,
        transparency=0,
        baseTexture=None,
        emissiveTexture=None,
        extensions=None,
        metallicRoughnessTexture=None,
        normalTexture=None,
        occlusionTexture=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode PhysicalMaterial __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.baseColor = baseColor
        self.baseTextureMapping = baseTextureMapping
        self.emissiveColor = emissiveColor
        self.emissiveTextureMapping = emissiveTextureMapping
        self.metallic = metallic
        self.metallicRoughnessTextureMapping = metallicRoughnessTextureMapping
        self.normalScale = normalScale
        self.normalTextureMapping = normalTextureMapping
        self.occlusionStrength = occlusionStrength
        self.occlusionTextureMapping = occlusionTextureMapping
        self.roughness = roughness
        self.transparency = transparency
        self.baseTexture = baseTexture
        self.emissiveTexture = emissiveTexture
        self.extensions = extensions
        self.metallicRoughnessTexture = metallicRoughnessTexture
        self.normalTexture = normalTexture
        self.occlusionTexture = occlusionTexture
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def baseColor(self):
        """[0,1] similar to diffuseColor, TODO define more precisely."""
        return self.__baseColor
    @baseColor.setter
    def baseColor(self, baseColor):
        if  baseColor is None:
            baseColor = (1, 1, 1)  # default
        assertValidSFColor(baseColor)
        assertZeroToOne('baseColor', baseColor)
        self.__baseColor = baseColor
    @property # getter - - - - - - - - - -
    def baseTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__baseTextureMapping
    @baseTextureMapping.setter
    def baseTextureMapping(self, baseTextureMapping):
        if  baseTextureMapping is None:
            baseTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(baseTextureMapping)
        self.__baseTextureMapping = baseTextureMapping
    @property # getter - - - - - - - - - -
    def emissiveColor(self):
        """[0,1] how much glowing light is emitted from this object."""
        return self.__emissiveColor
    @emissiveColor.setter
    def emissiveColor(self, emissiveColor):
        if  emissiveColor is None:
            emissiveColor = (0, 0, 0)  # default
        assertValidSFColor(emissiveColor)
        assertZeroToOne('emissiveColor', emissiveColor)
        self.__emissiveColor = emissiveColor
    @property # getter - - - - - - - - - -
    def emissiveTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__emissiveTextureMapping
    @emissiveTextureMapping.setter
    def emissiveTextureMapping(self, emissiveTextureMapping):
        if  emissiveTextureMapping is None:
            emissiveTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(emissiveTextureMapping)
        self.__emissiveTextureMapping = emissiveTextureMapping
    @property # getter - - - - - - - - - -
    def metallic(self):
        """[0,1] metallic is a PBR parameter (TODO elaborate)."""
        return self.__metallic
    @metallic.setter
    def metallic(self, metallic):
        if  metallic is None:
            metallic = 1  # default
        assertValidSFFloat(metallic)
        assertZeroToOne('metallic', metallic)
        self.__metallic = metallic
    @property # getter - - - - - - - - - -
    def metallicRoughnessTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__metallicRoughnessTextureMapping
    @metallicRoughnessTextureMapping.setter
    def metallicRoughnessTextureMapping(self, metallicRoughnessTextureMapping):
        if  metallicRoughnessTextureMapping is None:
            metallicRoughnessTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(metallicRoughnessTextureMapping)
        self.__metallicRoughnessTextureMapping = metallicRoughnessTextureMapping
    @property # getter - - - - - - - - - -
    def normalScale(self):
        """[0,infinity] normalScale controls the degree to which normalTexture RGB values apply XYZ-normal bump mapping to pixels in the parent material."""
        return self.__normalScale
    @normalScale.setter
    def normalScale(self, normalScale):
        if  normalScale is None:
            normalScale = 1  # default
        assertValidSFFloat(normalScale)
        assertNonNegative('normalScale', normalScale)
        self.__normalScale = normalScale
    @property # getter - - - - - - - - - -
    def normalTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__normalTextureMapping
    @normalTextureMapping.setter
    def normalTextureMapping(self, normalTextureMapping):
        if  normalTextureMapping is None:
            normalTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(normalTextureMapping)
        self.__normalTextureMapping = normalTextureMapping
    @property # getter - - - - - - - - - -
    def occlusionStrength(self):
        """[0,1] occlusionStrength indicates areas of indirect lighting, typically called ambient occlusion."""
        return self.__occlusionStrength
    @occlusionStrength.setter
    def occlusionStrength(self, occlusionStrength):
        if  occlusionStrength is None:
            occlusionStrength = 1  # default
        assertValidSFFloat(occlusionStrength)
        assertZeroToOne('occlusionStrength', occlusionStrength)
        self.__occlusionStrength = occlusionStrength
    @property # getter - - - - - - - - - -
    def occlusionTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__occlusionTextureMapping
    @occlusionTextureMapping.setter
    def occlusionTextureMapping(self, occlusionTextureMapping):
        if  occlusionTextureMapping is None:
            occlusionTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(occlusionTextureMapping)
        self.__occlusionTextureMapping = occlusionTextureMapping
    @property # getter - - - - - - - - - -
    def roughness(self):
        """[0,1] roughness is a PBR parameter (TODO elaborate)."""
        return self.__roughness
    @roughness.setter
    def roughness(self, roughness):
        if  roughness is None:
            roughness = 1  # default
        assertValidSFFloat(roughness)
        assertZeroToOne('roughness', roughness)
        self.__roughness = roughness
    @property # getter - - - - - - - - - -
    def transparency(self):
        """[0,1] how "clear" an object is: 1."""
        return self.__transparency
    @transparency.setter
    def transparency(self, transparency):
        if  transparency is None:
            transparency = 0  # default
        assertValidSFFloat(transparency)
        assertZeroToOne('transparency', transparency)
        self.__transparency = transparency
    @property # getter - - - - - - - - - -
    def baseTexture(self):
        """[X3DSingleTextureNode] When applying baseColor for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__baseTexture
    @baseTexture.setter
    def baseTexture(self, baseTexture):
        if  baseTexture is None:
            baseTexture = None  # default
        assertValidSFNode(baseTexture)
        if not baseTexture is None and not isinstance(baseTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(baseTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__baseTexture = baseTexture
    @property # getter - - - - - - - - - -
    def emissiveTexture(self):
        """[X3DSingleTextureNode] When applying emissiveColor for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__emissiveTexture
    @emissiveTexture.setter
    def emissiveTexture(self, emissiveTexture):
        if  emissiveTexture is None:
            emissiveTexture = None  # default
        assertValidSFNode(emissiveTexture)
        if not emissiveTexture is None and not isinstance(emissiveTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(emissiveTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__emissiveTexture = emissiveTexture
    @property # getter - - - - - - - - - -
    def extensions(self):
        """[X3DMaterialExtensionNode] - stuff."""
        return self.__extensions
    @extensions.setter
    def extensions(self, extensions):
        if  extensions is None:
            extensions = MFNode.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFNode.DEFAULT_VALUE()))
        assertValidMFNode(extensions)
        self.__extensions = extensions
    @property # getter - - - - - - - - - -
    def metallicRoughnessTexture(self):
        """[X3DSingleTextureNode] When applying metallic for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__metallicRoughnessTexture
    @metallicRoughnessTexture.setter
    def metallicRoughnessTexture(self, metallicRoughnessTexture):
        if  metallicRoughnessTexture is None:
            metallicRoughnessTexture = None  # default
        assertValidSFNode(metallicRoughnessTexture)
        if not metallicRoughnessTexture is None and not isinstance(metallicRoughnessTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(metallicRoughnessTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__metallicRoughnessTexture = metallicRoughnessTexture
    @property # getter - - - - - - - - - -
    def normalTexture(self):
        """[X3DSingleTextureNode] When applying normalScale for this material node, the contained texture modulates the texture across the surface."""
        return self.__normalTexture
    @normalTexture.setter
    def normalTexture(self, normalTexture):
        if  normalTexture is None:
            normalTexture = None  # default
        assertValidSFNode(normalTexture)
        if not normalTexture is None and not isinstance(normalTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(normalTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__normalTexture = normalTexture
    @property # getter - - - - - - - - - -
    def occlusionTexture(self):
        """[X3DSingleTextureNode] When applying occlusionStrength for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__occlusionTexture
    @occlusionTexture.setter
    def occlusionTexture(self, occlusionTexture):
        if  occlusionTexture is None:
            occlusionTexture = None  # default
        assertValidSFNode(occlusionTexture)
        if not occlusionTexture is None and not isinstance(occlusionTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(occlusionTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__occlusionTexture = occlusionTexture
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.baseTexture or self.emissiveTexture or self.IS or self.metadata or self.metallicRoughnessTexture or self.normalTexture or self.occlusionTexture
    # output function - - - - - - - - - -


class EnvironmentLight(_X3DLightNode):
    """
    EnvironmentLight
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'EnvironmentLight'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4.1-CD/Part01/components/lighting.html#EnvironmentLight'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'NA'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('ambientIntensity', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
        ('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'X3DLightNode'),
        ('diffuse', None, FieldType.SFNode, AccessType.inputOutput, 'EnvironmentLight')
        ('diffuseTexture', None, FieldType.SFNode, AccessType.inputOutput, 'EnvironmentLight')
        ('diffuseCoefficients', [], FieldType.MFFloat, AccessType.inputOutput, 'EnvironmentLight')
        ('global_', False, FieldType.SFBool, AccessType.inputOutput, 'EnvironmentLight'),
        ('intensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
        ('on', True, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
        ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'EnvironmentLight')
        ('shadowIntensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
        ('shadows', False, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
        ('specularTexture', None, FieldType.SFNode, AccessType.inputOutput, 'EnvironmentLight')
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        ambientIntensity=0,
        color=(1, 1, 1),
        diffuse=None,
        diffuseTexture=None,
        diffuseCoefficients=None,
        global_=False,
        intensity=1,
        on=True,
        rotation=(0, 0, 1, 0),
        shadowIntensity=1,
        shadows=False,
        specularTexture=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode DirectionalLight __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.ambientIntensity = ambientIntensity
        self.color = color
        self.diffuse = diffuse
        self.diffuseTexture = diffuseTexture
        self.diffuseCoefficients = diffuseCoefficients
        self.global_ = global_
        self.intensity = intensity
        self.on = on
        self.rotation = rotation
        self.shadowIntensity = shadowIntensity
        self.shadows = shadows
        self.specularTexture = specularTexture
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def ambientIntensity(self):
        """[0,1] Brightness of ambient (nondirectional background) emission from the light."""
        return self.__ambientIntensity
    @ambientIntensity.setter
    def ambientIntensity(self, ambientIntensity):
        if  ambientIntensity is None:
            ambientIntensity = 0  # default
        assertValidSFFloat(ambientIntensity)
        assertZeroToOne('ambientIntensity', ambientIntensity)
        self.__ambientIntensity = ambientIntensity
    @property # getter - - - - - - - - - -
    def color(self):
        """[0,1] color of light, applied to colors of objects."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = (1, 1, 1)  # default
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def diffuse(self):
        """[X3DSingleTextureNode] NA - Aaron doesn't ahve info for this."""
        return self.__diffuse
    @diffuse.setter
    def diffuse(self, diffuse):
        if  diffuse is None:
            diffuse = None  # default
        assertValidSFNode(diffuse)
        if not diffuse is None and not isinstance(diffuse,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(diffuse) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__diffuse = diffuse
    @property # getter - - - - - - - - - -
    def diffuseTexture(self):
        """[X3DEnvironmentTextureNode] NA - Aaron doesn't ahve info for this."""
        return self.__diffuseTexture
    @diffuseTexture.setter
    def diffuseTexture(self, diffuseTexture):
        if  diffuseTexture is None:
            diffuseTexture = None  # default
        assertValidSFNode(diffuseTexture)
        if not diffuseTexture is None and not isinstance(diffuseTexture,(_X3DEnvironmentTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(diffuseTexture) + ' does not match required node type (_X3DEnvironmentTextureNode,ProtoInstance) and is invalid')
        self.__diffuseTexture = diffuseTexture
    @property # getter - - - - - - - - - -
    def diffuseCoefficients(self):
        """NA - Aaron doesn't knwo what this is for."""
        return self.__diffuseCoefficients
    @diffuseCoefficients.setter
    def diffuseCoefficients(self, diffuseCoefficients):
        if  diffuseCoefficients is None:
            diffuseCoefficients = MFFloat.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(MFFloat.DEFAULT_VALUE()))
        assertValidMFFloat(diffuseCoefficients)
        self.__diffuseCoefficients = diffuseCoefficients
    @property # getter - - - - - - - - - -
    def global_(self):
        """Global lights illuminate all objects within their volume of lighting influence."""
        return self.__global_
    @global_.setter
    def global_(self, global_):
        if  global_ is None:
            global_ = False  # default
        assertValidSFBool(global_)
        self.__global_ = global_
    @property # getter - - - - - - - - - -
    def intensity(self):
        """[0,+infinity] Brightness of direct emission from the light."""
        return self.__intensity
    @intensity.setter
    def intensity(self, intensity):
        if  intensity is None:
            intensity = 1  # default
        assertValidSFFloat(intensity)
        assertNonNegative('intensity', intensity)
        self.__intensity = intensity
    @property # getter - - - - - - - - - -
    def on(self):
        """Enables/disables this light source."""
        return self.__on
    @on.setter
    def on(self, on):
        if  on is None:
            on = True  # default
        assertValidSFBool(on)
        self.__on = on
    @property # getter - - - - - - - - - -
    def rotation(self):
        """Orientation (axis, angle in radians) of children relative to local coordinate system."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = (0, 0, 1, 0)  # default
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def shadowIntensity(self):
        """[0,1] shadowIntensity field defines how much light is obscured by shapes that cast shadows, ranging from 0 (light not obscured, no visible shadows) to 1 (light completely obscured, full-intensity shadows)."""
        return self.__shadowIntensity
    @shadowIntensity.setter
    def shadowIntensity(self, shadowIntensity):
        if  shadowIntensity is None:
            shadowIntensity = 1  # default
        assertValidSFFloat(shadowIntensity)
        assertZeroToOne('shadowIntensity', shadowIntensity)
        self.__shadowIntensity = shadowIntensity
    @property # getter - - - - - - - - - -
    def shadows(self):
        """shadows field indicates whether or not this light casts a shadow behind illuminated X3DShapeNode geometry."""
        return self.__shadows
    @shadows.setter
    def shadows(self, shadows):
        if  shadows is None:
            shadows = False  # default
        assertValidSFBool(shadows)
        self.__shadows = shadows
    @property # getter - - - - - - - - - -
    def specularTexture(self):
        """[X3DEnvironmentTextureNode] NA - Aaron doesn't ahve info for this."""
        return self.__specularTexture
    @specularTexture.setter
    def specularTexture(self, specularTexture):
        if  specularTexture is None:
            specularTexture = None  # default
        assertValidSFNode(specularTexture)
        if not specularTexture is None and not isinstance(specularTexture,(_X3DEnvironmentTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(specularTexture) + ' does not match required node type (_X3DEnvironmentTextureNode,ProtoInstance) and is invalid')
        self.__specularTexture = specularTexture
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata
    # output function - - - - - - - - - -


class AnisotropyMaterialExtension(_X3DMaterialExtensionNode):
    """
    AnisotropyMaterialExtension only works with X_ITE, hopefully other viewers ignore it.
    Adds Anisotropy to PhysicalMaterial nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'AnisotropyMaterialExtension'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://create3000.github.io/x_ite/components/x-ite/anisotropymaterialextension/'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://create3000.github.io/x_ite/components/x-ite/anisotropymaterialextension/'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('anisotropyStrength', 0.0, FieldType.SFFloat, AccessType.inputOutput, 'AnisotropyMaterialExtension'),
        ('anisotropyRotation', 0.0, FieldType.SFFloat, AccessType.inputOutput, 'AnisotropyMaterialExtension'),
        ('anisotropyTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'AnisotropyMaterialExtension'),
        ('anisotropyTexture', None, FieldType.SFNode, AccessType.inputOutput, 'AnisotropyMaterialExtension'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        anisotropyStrength=0.0,
        anisotropyRotation=0.0,
        anisotropyTextureMapping='',
        anisotropyTexture=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Group __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.anisotropyStrength = anisotropyStrength
        self.anisotropyRotation = anisotropyRotation
        self.anisotropyStrength = anisotropyStrength
        self.anisotropyRotation = anisotropyRotation
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def anisotropyStrength(self):
        """The anisotropyStrength defines ior for PhysicalMaterial nodes."""
        return self.__anisotropyStrength
    @anisotropyStrength.setter
    def anisotropyStrength(self, anisotropyStrength):
        if  anisotropyStrength is None:
            anisotropyStrength = 0.0 # default
        assertValidSFFloat(anisotropyStrength)
        assertNonNegative('anisotropyStrength', anisotropyStrength)
        self.__anisotropyStrength = anisotropyStrength
    @property # getter - - - - - - - - - -
    def anisotropyRotation(self):
        """The anisotropyRotation defines ior for PhysicalMaterial nodes."""
        return self.__anisotropyRotation
    @anisotropyRotation.setter
    def anisotropyRotation(self, anisotropyRotation):
        if  anisotropyRotation is None:
            anisotropyRotation = 0.0 # default
        assertValidSFFloat(anisotropyRotation)
        self.__anisotropyRotation = anisotropyRotation
    @property # getter - - - - - - - - - -
    def anisotropyTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__anisotropyTextureMapping
    @anisotropyTextureMapping.setter
    def anisotropyTextureMapping(self, anisotropyTextureMapping):
        if  anisotropyTextureMapping is None:
            anisotropyTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(anisotropyTextureMapping)
        self.__anisotropyTextureMapping = anisotropyTextureMapping
    @property # getter - - - - - - - - - -
    def anisotropyTexture(self):
        """[X3DSingleTextureNode] When applying ambientIntensity for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__anisotropyTexture
    @anisotropyTexture.setter
    def anisotropyTexture(self, anisotropyTexture):
        if  anisotropyTexture is None:
            anisotropyTexture = None  # default
        assertValidSFNode(anisotropyTexture)
        if not anisotropyTexture is None and not isinstance(anisotropyTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(anisotropyTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__anisotropyTexture = anisotropyTexture
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata


class ClearcoatMaterialExtension(_X3DMaterialExtensionNode):
    """
    ClearcoatMaterialExtension only works with X_ITE, hopefully other viewers ignore it.
    Adds Transmission/Transparency to PhysicalMaterial nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'ClearcoatMaterialExtension'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://create3000.github.io/x_ite/components/x-ite/clearcoatmaterialextension/'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://create3000.github.io/x_ite/components/x-ite/clearcoatmaterialextension/'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('clearcoat', 0.0, FieldType.SFFloat, AccessType.inputOutput, 'ClearcoatMaterialExtension'),
        ('clearcoatTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'ClearcoatMaterialExtension'),
        ('clearcoatTexture', None, FieldType.SFNode, AccessType.inputOutput, 'ClearcoatMaterialExtension'),
        ('clearcoatRoughness', 0.0, FieldType.SFFloat, AccessType.inputOutput, 'ClearcoatMaterialExtension'),
        ('clearcoatRoughnessTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'ClearcoatMaterialExtension'),
        ('clearcoatRoughnessTexture', None, FieldType.SFNode, AccessType.inputOutput, 'ClearcoatMaterialExtension'),
        ('clearcoatNormalTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'ClearcoatMaterialExtension'),
        ('clearcoatNormalTexture', None, FieldType.SFNode, AccessType.inputOutput, 'ClearcoatMaterialExtension'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        clearcoat=0.0,
        clearcoatTextureMapping="",
        clearcoatTexture=None,
        clearcoatRoughness=0.0,
        clearcoatRoughnessTextureMapping="",
        clearcoatRoughnessTexture=None,
        clearcoatNormalTextureMapping="",
        clearcoatNormalTexture=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Group __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.clearcoat = clearcoat
        self.clearcoatTextureMapping = clearcoatTextureMapping
        self.clearcoatTexture = clearcoatTexture
        self.clearcoatRoughness = clearcoatRoughness
        self.clearcoatRoughnessTextureMapping = clearcoatRoughnessTextureMapping
        self.clearcoatRoughnessTexture = clearcoatRoughnessTexture
        self.clearcoatNormalTextureMapping = clearcoatNormalTextureMapping
        self.clearcoatNormalTexture = clearcoatNormalTexture
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def clearcoat(self):
        """The clearcoat - NA -  PhysicalMaterial nodes."""
        return self.__clearcoat
    @clearcoat.setter
    def clearcoat(self, clearcoat):
        if  clearcoat is None:
            clearcoat = 0.0 # default
        assertValidSFFloat(clearcoat)
        assertNonNegative('clearcoat', clearcoat)
        self.__clearcoat = clearcoat
    @property # getter - - - - - - - - - -
    def clearcoatTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__clearcoatTextureMapping
    @clearcoatTextureMapping.setter
    def clearcoatTextureMapping(self, clearcoatTextureMapping):
        if  clearcoatTextureMapping is None:
            clearcoatTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(clearcoatTextureMapping)
        self.__clearcoatTextureMapping = clearcoatTextureMapping
    @property # getter - - - - - - - - - -
    def clearcoatTexture(self):
        """[X3DSingleTextureNode] - IDK."""
        return self.__clearcoatTexture
    @clearcoatTexture.setter
    def clearcoatTexture(self, clearcoatTexture):
        if  clearcoatTexture is None:
            clearcoatTexture = None  # default
        assertValidSFNode(clearcoatTexture)
        if not clearcoatTexture is None and not isinstance(clearcoatTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(clearcoatTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__clearcoatTexture = clearcoatTexture
    @property # getter - - - - - - - - - -
    def clearcoatRoughness(self):
        """The clearcoatRoughness - NA -  PhysicalMaterial nodes."""
        return self.__clearcoatRoughness
    @clearcoatRoughness.setter
    def clearcoatRoughness(self, clearcoatRoughness):
        if  clearcoatRoughness is None:
            clearcoatRoughness = 0.0 # default
        assertValidSFFloat(clearcoatRoughness)
        assertNonNegative('clearcoatRoughness', clearcoatRoughness)
        self.__clearcoatRoughness = clearcoatRoughness
    @property # getter - - - - - - - - - -
    def clearcoatRoughnessTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__clearcoatRoughnessTextureMapping
    @clearcoatRoughnessTextureMapping.setter
    def clearcoatRoughnessTextureMapping(self, clearcoatRoughnessTextureMapping):
        if  clearcoatRoughnessTextureMapping is None:
            clearcoatRoughnessTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(clearcoatRoughnessTextureMapping)
        self.__clearcoatRoughnessTextureMapping = clearcoatRoughnessTextureMapping
    @property # getter - - - - - - - - - -
    def clearcoatRoughnessTexture(self):
        """[X3DSingleTextureNode] - IDK."""
        return self.__clearcoatRoughnessTexture
    @clearcoatRoughnessTexture.setter
    def clearcoatRoughnessTexture(self, clearcoatRoughnessTexture):
        if  clearcoatRoughnessTexture is None:
            clearcoatRoughnessTexture = None  # default
        assertValidSFNode(clearcoatRoughnessTexture)
        if not clearcoatRoughnessTexture is None and not isinstance(clearcoatRoughnessTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(clearcoatRoughnessTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__clearcoatRoughnessTexture = clearcoatRoughnessTexture
    @property # getter - - - - - - - - - -
    def clearcoatNormalTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__clearcoatNormalTextureMapping
    @clearcoatNormalTextureMapping.setter
    def clearcoatNormalTextureMapping(self, clearcoatNormalTextureMapping):
        if  clearcoatNormalTextureMapping is None:
            clearcoatNormalTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(clearcoatNormalTextureMapping)
        self.__clearcoatNormalTextureMapping = clearcoatNormalTextureMapping
    @property # getter - - - - - - - - - -
    def clearcoatNormalTexture(self):
        """[X3DSingleTextureNode] - IDK."""
        return self.__clearcoatNormalTexture
    @clearcoatNormalTexture.setter
    def clearcoatNormalTexture(self, clearcoatNormalTexture):
        if  clearcoatNormalTexture is None:
            clearcoatNormalTexture = None  # default
        assertValidSFNode(clearcoatNormalTexture)
        if not clearcoatNormalTexture is None and not isinstance(clearcoatNormalTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(clearcoatNormalTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__clearcoatNormalTexture = clearcoatNormalTexture
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata


class DiffuseTransmissionMaterialExtension(_X3DMaterialExtensionNode):
    """
    DiffuseTransmissionMaterialExtension only works with X_ITE, hopefully other viewers ignore it.
    Adds Transmission/Transparency to PhysicalMaterial nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'DiffuseTransmissionMaterialExtension'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://create3000.github.io/x_ite/components/x-ite/diffusetransmissionmaterialextension/'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://create3000.github.io/x_ite/components/x-ite/diffusetransmissionmaterialextension/'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('diffuseTransmission', 0.0, FieldType.SFFloat, AccessType.inputOutput, 'DiffuseTransmissionMaterialExtension'),
        ('diffuseTransmissionTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'DiffuseTransmissionMaterialExtension'),
        ('diffuseTransmissionTexture', None, FieldType.SFNode, AccessType.inputOutput, 'DiffuseTransmissionMaterialExtension'),
        ('diffuseTransmissionColor', (1.0, 1.0, 1.0), FieldType.SFColor, AccessType.inputOutput, 'DiffuseTransmissionMaterialExtension'),
        ('diffuseTransmissionColorTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'DiffuseTransmissionMaterialExtension'),
        ('diffuseTransmissionColorTexture', None, FieldType.SFNode, AccessType.inputOutput, 'DiffuseTransmissionMaterialExtension'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        diffuseTransmission=0.0,
        diffuseTransmissionTextureMapping="",
        diffuseTransmissionTexture=None,
        diffuseTransmissionColor=(1.0, 1.0, 1.0),
        diffuseTransmissionColorTextureMapping="",
        diffuseTransmissionColorTexture=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Group __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.diffuseTransmission = diffuseTransmission
        self.diffuseTransmissionTextureMapping = diffuseTransmissionTextureMapping
        self.diffuseTransmissionTexture = diffuseTransmissionTexture
        self.diffuseTransmissionColor   = diffuseTransmissionColor
        self.diffuseTransmissionColorTextureMapping = diffuseTransmissionColorTextureMapping
        self.diffuseTransmissionColorTexture = diffuseTransmissionColorTexture
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def diffuseTransmission(self):
        """The specualr - NA -  PhysicalMaterial nodes."""
        return self.__diffuseTransmission
    @diffuseTransmission.setter
    def diffuseTransmission(self, diffuseTransmission):
        if  diffuseTransmission is None:
            diffuseTransmission = 0.0 # default
        assertValidSFFloat(diffuseTransmission)
        assertNonNegative('diffuseTransmission', diffuseTransmission)
        self.__diffuseTransmission = diffuseTransmission
    @property # getter - - - - - - - - - -
    def diffuseTransmissionTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__diffuseTransmissionTextureMapping
    @diffuseTransmissionTextureMapping.setter
    def diffuseTransmissionTextureMapping(self, diffuseTransmissionTextureMapping):
        if  diffuseTransmissionTextureMapping is None:
            diffuseTransmissionTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(diffuseTransmissionTextureMapping)
        self.__diffuseTransmissionTextureMapping = diffuseTransmissionTextureMapping
    @property # getter - - - - - - - - - -
    def diffuseTransmissionTexture(self):
        """[X3DSingleTextureNode] - IDK."""
        return self.__diffuseTransmissionTexture
    @diffuseTransmissionTexture.setter
    def diffuseTransmissionTexture(self, diffuseTransmissionTexture):
        if  diffuseTransmissionTexture is None:
            diffuseTransmissionTexture = None  # default
        assertValidSFNode(diffuseTransmissionTexture)
        if not diffuseTransmissionTexture is None and not isinstance(diffuseTransmissionTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(diffuseTransmissionTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__diffuseTransmissionTexture = diffuseTransmissionTexture
    @property # getter - - - - - - - - - -
    def diffuseTransmissionColor(self):
        """Initial starting value for this node."""
        return self.__diffuseTransmissionColor
    @diffuseTransmissionColor.setter
    def diffuseTransmissionColor(self, diffuseTransmissionColor):
        if  diffuseTransmissionColor is None:
            diffuseTransmissionColor = (1.0, 1.0, 1.0)  # default
        assertValidSFColor(diffuseTransmissionColor)
        assertZeroToOne('diffuseTransmissionColor', diffuseTransmissionColor)
        self.__diffuseTransmissionColor = diffuseTransmissionColor
    @property # getter - - - - - - - - - -
    def diffuseTransmissionColorTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__diffuseTransmissionColorTextureMapping
    @diffuseTransmissionColorTextureMapping.setter
    def diffuseTransmissionColorTextureMapping(self, diffuseTransmissionColorTextureMapping):
        if  diffuseTransmissionColorTextureMapping is None:
            diffuseTransmissionColorTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(diffuseTransmissionColorTextureMapping)
        self.__diffuseTransmissionColorTextureMapping = diffuseTransmissionColorTextureMapping
    @property # getter - - - - - - - - - -
    def diffuseTransmissionColorTexture(self):
        """[X3DSingleTextureNode] - IDK."""
        return self.__diffuseTransmissionColorTexture
    @diffuseTransmissionColorTexture.setter
    def diffuseTransmissionColorTexture(self, diffuseTransmissionColorTexture):
        if  diffuseTransmissionColorTexture is None:
            diffuseTransmissionColorTexture = None  # default
        assertValidSFNode(diffuseTransmissionColorTexture)
        if not diffuseTransmissionColorTexture is None and not isinstance(diffuseTransmissionColorTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(diffuseTransmissionColorTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__diffuseTransmissionColorTexture = diffuseTransmissionColorTexture
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata


class DispersionMaterialExtension(_X3DMaterialExtensionNode):
    """
    DispersionMaterialExtension only works with X_ITE, hopefully other viewers ignore it.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'DispersionMaterialExtension'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://create3000.github.io/x_ite/components/x-ite/dispersionmaterialextension/'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://create3000.github.io/x_ite/components/x-ite/dispersionmaterialextension/'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('dispersion', 0.0, FieldType.SFFloat, AccessType.inputOutput, 'DispersionMaterialExtension'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        dispersion=0.0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Group __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.dispersion = dispersion
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def dispersion(self):
        """The dispersion - PhysicalMaterial nodes."""
        return self.__dispersion
    @dispersion.setter
    def dispersion(self, dispersion):
        if  dispersion is None:
            dispersion = 0.0 # default
        elif dispersion < 0.0:
            dispersion = 0.0
        assertValidSFFloat(dispersion)
        assertNonNegative('dispersion', dispersion)
        self.__dispersion = dispersion
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata


class EmissiveStrengthMaterialExtension(_X3DMaterialExtensionNode):
    """
    EmissiveStrengthMaterialExtension only works with X_ITE, hopefully other viewers ignore it.
    Adds EmissiveStrength/Intensity to PhysicalMaterial nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'EmissiveStrengthMaterialExtension'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://create3000.github.io/x_ite/components/x-ite/emissivestrengthmaterialextension/'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://create3000.github.io/x_ite/components/x-ite/emissivestrengthmaterialextension/'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('emissiveStrength', 1.0, FieldType.SFFloat, AccessType.inputOutput, 'EmissiveStrengthMaterialExtension'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        emissiveStrength=1.0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Group __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.emissiveStrength = emissiveStrength
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def emissiveStrength(self):
        """The emissiveStrength defines ior for PhysicalMaterial nodes."""
        return self.__emissiveStrength
    @emissiveStrength.setter
    def emissiveStrength(self, emissiveStrength):
        if  emissiveStrength is None:
            emissiveStrength = 1.0 # default
        assertValidSFFloat(emissiveStrength)
        assertNonNegative('emissiveStrength', emissiveStrength)
        self.__emissiveStrength = emissiveStrength
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata


class IORMaterialExtension(_X3DMaterialExtensionNode):
    """
    IORMaterialExtension only works with X_ITE, hopefully other viewers ignore it.
    Adds IOR to PhysicalMaterial nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'IORMaterialExtension'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://create3000.github.io/x_ite/components/x-ite/iormaterialextension'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://create3000.github.io/x_ite/components/x-ite/iormaterialextension'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('indexOfRefraction', 1.5, FieldType.SFFloat, AccessType.inputOutput, 'IORMaterialExtension'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        indexOfRefraction=1.5,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Group __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.indexOfRefraction = indexOfRefraction
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def indexOfRefraction(self):
        """The indexOfRefraction defines ior for PhysicalMaterial nodes."""
        return self.__indexOfRefraction
    @indexOfRefraction.setter
    def indexOfRefraction(self, indexOfRefraction):
        if  indexOfRefraction is None:
            indexOfRefraction = 1.5 # default
        elif indexOfRefraction < 1.0:
            indexOfRefraction = 1.0
        assertValidSFFloat(indexOfRefraction)
        self.__indexOfRefraction = indexOfRefraction
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata


class SheenMaterialExtension(_X3DMaterialExtensionNode):
    """
    SheenMaterialExtension only works with X_ITE, hopefully other viewers ignore it.
    Adds Transmission/Transparency to PhysicalMaterial nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'SheenMaterialExtension'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://create3000.github.io/x_ite/components/x-ite/sheenmaterialextension/'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://create3000.github.io/x_ite/components/x-ite/sheenmaterialextension/'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('sheenColor', (0.0, 0.0, 0.0), FieldType.SFColor, AccessType.inputOutput, 'SheenMaterialExtension'),
        ('sheenColorTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'SheenMaterialExtension'),
        ('sheenColorTexture', None, FieldType.SFNode, AccessType.inputOutput, 'SheenMaterialExtension'),
        ('sheenRoughness', 0.0, FieldType.SFFloat, AccessType.inputOutput, 'SheenMaterialExtension'),
        ('sheenRoughnessTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'SheenMaterialExtension'),
        ('sheenRoughnessTexture', None, FieldType.SFNode, AccessType.inputOutput, 'SheenMaterialExtension'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        sheenColor=(0.0, 0.0, 0.0),
        sheenColorTextureMapping="",
        sheenColorTexture=None,
        sheenRoughness=0.0,
        sheenRoughnessTextureMapping="",
        sheenRoughnessTexture=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Group __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.sheenColor   = sheenColor
        self.sheenColorTextureMapping = sheenColorTextureMapping
        self.sheenColorTexture = sheenColorTexture
        self.sheenRoughness = sheenRoughness
        self.sheenRoughnessTextureMapping = sheenRoughnessTextureMapping
        self.sheenRoughnessTexture = sheenRoughnessTexture
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def sheenColor(self):
        """Initial starting value for this node."""
        return self.__sheenColor
    @sheenColor.setter
    def sheenColor(self, sheenColor):
        if  sheenColor is None:
            sheenColor = (0.0, 0.0, 0.0)  # default
        assertValidSFColor(sheenColor)
        assertZeroToOne('sheenColor', sheenColor)
        self.__sheenColor = sheenColor
    @property # getter - - - - - - - - - -
    def sheenColorTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__sheenColorTextureMapping
    @sheenColorTextureMapping.setter
    def sheenColorTextureMapping(self, sheenColorTextureMapping):
        if  sheenColorTextureMapping is None:
            sheenColorTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(sheenColorTextureMapping)
        self.__sheenColorTextureMapping = sheenColorTextureMapping
    @property # getter - - - - - - - - - -
    def sheenColorTexture(self):
        """[X3DSingleTextureNode] - IDK."""
        return self.__sheenColorTexture
    @sheenColorTexture.setter
    def sheenColorTexture(self, sheenColorTexture):
        if  sheenColorTexture is None:
            sheenColorTexture = None  # default
        assertValidSFNode(sheenColorTexture)
        if not sheenColorTexture is None and not isinstance(sheenColorTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(sheenColorTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__sheenColorTexture = sheenColorTexture
    @property # getter - - - - - - - - - -
    def sheenRoughness(self):
        """The specualr - NA -  PhysicalMaterial nodes."""
        return self.__sheenRoughness
    @sheenRoughness.setter
    def sheenRoughness(self, sheenRoughness):
        if  sheenRoughness is None:
            sheenRoughness = 0.0 # default
        assertValidSFFloat(sheenRoughness)
        assertNonNegative('sheenRoughness', sheenRoughness)
        self.__sheenRoughness = sheenRoughness
    @property # getter - - - - - - - - - -
    def sheenRoughnessTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__sheenRoughnessTextureMapping
    @sheenRoughnessTextureMapping.setter
    def sheenRoughnessTextureMapping(self, sheenRoughnessTextureMapping):
        if  sheenRoughnessTextureMapping is None:
            sheenRoughnessTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(sheenRoughnessTextureMapping)
        self.__sheenRoughnessTextureMapping = sheenRoughnessTextureMapping
    @property # getter - - - - - - - - - -
    def sheenRoughnessTexture(self):
        """[X3DSingleTextureNode] - IDK."""
        return self.__sheenRoughnessTexture
    @sheenRoughnessTexture.setter
    def sheenRoughnessTexture(self, sheenRoughnessTexture):
        if  sheenRoughnessTexture is None:
            sheenRoughnessTexture = None  # default
        assertValidSFNode(sheenRoughnessTexture)
        if not sheenRoughnessTexture is None and not isinstance(sheenRoughnessTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(sheenRoughnessTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__sheenRoughnessTexture = sheenRoughnessTexture
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata


class SpecularMaterialExtension(_X3DMaterialExtensionNode):
    """
    SpecularMaterialExtension only works with X_ITE, hopefully other viewers ignore it.
    Adds Transmission/Transparency to PhysicalMaterial nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'SpecularMaterialExtension'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://create3000.github.io/x_ite/components/x-ite/specularmaterialextension/'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://create3000.github.io/x_ite/components/x-ite/specularmaterialextension/'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('specular', 1.0, FieldType.SFFloat, AccessType.inputOutput, 'SpecularMaterialExtension'),
        ('specularTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'SpecularMaterialExtension'),
        ('specularTexture', None, FieldType.SFNode, AccessType.inputOutput, 'SpecularMaterialExtension'),
        ('specularColor', (1.0, 1.0, 1.0), FieldType.SFColor, AccessType.inputOutput, 'SpecularMaterialExtension'),
        ('specularColorTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'SpecularMaterialExtension'),
        ('specularColorTexture', None, FieldType.SFNode, AccessType.inputOutput, 'SpecularMaterialExtension'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        specular=1.0,
        specularTextureMapping="",
        specularTexture=None,
        specularColor=(1.0, 1.0, 1.0),#Scatter
        specularColorTextureMapping="",
        specularColorTexture=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Group __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.specular = specular
        self.specularTextureMapping = specularTextureMapping
        self.specularTexture = specularTexture
        self.specularColor   = specularColor
        self.specularColorTextureMapping = specularColorTextureMapping
        self.specularColorTexture = specularColorTexture
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def specular(self):
        """The specualr - NA -  PhysicalMaterial nodes."""
        return self.__specular
    @specular.setter
    def specular(self, specular):
        if  specular is None:
            specular = 1.0 # default
        assertValidSFFloat(specular)
        assertNonNegative('specular', specular)
        self.__specular = specular
    @property # getter - - - - - - - - - -
    def specularTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__specularTextureMapping
    @specularTextureMapping.setter
    def specularTextureMapping(self, specularTextureMapping):
        if  specularTextureMapping is None:
            specularTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(specularTextureMapping)
        self.__specularTextureMapping = specularTextureMapping
    @property # getter - - - - - - - - - -
    def specularTexture(self):
        """[X3DSingleTextureNode] - IDK."""
        return self.__specularTexture
    @specularTexture.setter
    def specularTexture(self, specularTexture):
        if  specularTexture is None:
            specularTexture = None  # default
        assertValidSFNode(specularTexture)
        if not specularTexture is None and not isinstance(specularTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(specularTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__specularTexture = specularTexture
    @property # getter - - - - - - - - - -
    def specularColor(self):
        """Initial starting value for this node."""
        return self.__specularColor
    @specularColor.setter
    def specularColor(self, specularColor):
        if  specularColor is None:
            specularColor = (1.0, 1.0, 1.0)  # default
        assertValidSFColor(specularColor)
        assertZeroToOne('specularColor', specularColor)
        self.__specularColor = specularColor
    @property # getter - - - - - - - - - -
    def specularColorTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__specularColorTextureMapping
    @specularColorTextureMapping.setter
    def specularColorTextureMapping(self, specularColorTextureMapping):
        if  specularColorTextureMapping is None:
            specularColorTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(specularColorTextureMapping)
        self.__specularColorTextureMapping = specularColorTextureMapping
    @property # getter - - - - - - - - - -
    def specularColorTexture(self):
        """[X3DSingleTextureNode] - IDK."""
        return self.__specularColorTexture
    @specularColorTexture.setter
    def specularColorTexture(self, specularColorTexture):
        if  specularColorTexture is None:
            specularColorTexture = None  # default
        assertValidSFNode(specularColorTexture)
        if not specularColorTexture is None and not isinstance(specularColorTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(specularColorTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__specularColorTexture = specularColorTexture
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata


class TransmissionMaterialExtension(_X3DMaterialExtensionNode):
    """
    TransmissionMaterialExtension only works with X_ITE, hopefully other viewers ignore it.
    Adds Transmission/Transparency to PhysicalMaterial nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'TransmissionMaterialExtension'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://create3000.github.io/x_ite/components/x-ite/transmissionmaterialextension/'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://create3000.github.io/x_ite/components/x-ite/transmissionmaterialextension/'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('transmission', 0.0, FieldType.SFFloat, AccessType.inputOutput, 'TransmissionMaterialExtension'),
        ('transmissionTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'TransmissionMaterialExtension'),
        ('transmissionTexture', None, FieldType.SFNode, AccessType.inputOutput, 'TransmissionMaterialExtension'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        transmission=0.0,
        transmissionTextureMapping="",
        transmissionTexture=None,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Group __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.transmission = transmission
        self.transmissionTextureMapping = transmissionTextureMapping
        self.transmissionTexture = transmissionTexture
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def transmission(self):
        """The transmission defines ior for PhysicalMaterial nodes."""
        return self.__transmission
    @transmission.setter
    def transmission(self, transmission):
        if  transmission is None:
            transmission = 0.0 # default
        assertValidSFFloat(transmission)
        assertNonNegative('transmission', transmission)
        self.__transmission = transmission
    @property # getter - - - - - - - - - -
    def transmissionTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__transmissionTextureMapping
    @transmissionTextureMapping.setter
    def transmissionTextureMapping(self, transmissionTextureMapping):
        if  transmissionTextureMapping is None:
            transmissionTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(transmissionTextureMapping)
        self.__transmissionTextureMapping = transmissionTextureMapping
    @property # getter - - - - - - - - - -
    def transmissionTexture(self):
        """[X3DSingleTextureNode] - IDK."""
        return self.__transmissionTexture
    @transmissionTexture.setter
    def transmissionTexture(self, transmissionTexture):
        if  transmissionTexture is None:
            transmissionTexture = None  # default
        assertValidSFNode(transmissionTexture)
        if not transmissionTexture is None and not isinstance(transmissionTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(transmissionTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__transmissionTexture = transmissionTexture
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata


class VolumeMaterialExtension(_X3DMaterialExtensionNode):
    """
    VolumeMaterialExtension only works with X_ITE, hopefully other viewers ignore it.
    Adds IOR to PhysicalMaterial nodes.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'VolumeMaterialExtension'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://create3000.github.io/x_ite/components/x-ite/volumematerialextension/'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://create3000.github.io/x_ite/components/x-ite/volumematerialextension/'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('thickness', 0.0, FieldType.SFFloat, AccessType.inputOutput, 'VolumeMaterialExtension'),
        ('thicknessTextureMapping',   '', FieldType.SFString, AccessType.inputOutput, 'VolumeMaterialExtension'),
        ('thicknessTexture',        None, FieldType.SFNode,   AccessType.inputOutput, 'VolumeMaterialExtension'),
        ('attenuationDistance', 1000000.0, FieldType.SFFloat, AccessType.inputOutput, 'VolumeMaterialExtension'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        thickness=0.0,
        thicknessTextureMapping='',
        thicknessTexture=None,
        attenuationDistance=1000000.0,
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Group __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.thickness = thickness
        self.thicknessTextureMapping = thicknessTextureMapping
        self.thicknessTexture = thicknessTexture
        self.attenuationDistance = attenuationDistance
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def thickness(self):
        """thickness - PhysicalMaterial nodes."""
        return self.__thickness
    @thickness.setter
    def thickness(self, thickness):
        if  thickness is None:
            thickness = 0.0 # default
        assertValidSFFloat(thickness)
        assertNonNegative('thickness', thickness)
        self.__thickness = thickness
    @property # getter - - - - - - - - - -
    def thicknessTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__thicknessTextureMapping
    @thicknessTextureMapping.setter
    def thicknessTextureMapping(self, thicknessTextureMapping):
        if  thicknessTextureMapping is None:
            thicknessTextureMapping = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(thicknessTextureMapping)
        self.__thicknessTextureMapping = thicknessTextureMapping
    @property # getter - - - - - - - - - -
    def thicknessTexture(self):
        """[X3DSingleTextureNode] - IDK."""
        return self.__thicknessTexture
    @thicknessTexture.setter
    def thicknessTexture(self, thicknessTexture):
        if  thicknessTexture is None:
            thicknessTexture = None  # default
        assertValidSFNode(thicknessTexture)
        if not thicknessTexture is None and not isinstance(thicknessTexture,(_X3DSingleTextureNode,ProtoInstance)):
            # print(flush=True)
            raise X3DTypeError(str(thicknessTexture) + ' does not match required node type (_X3DSingleTextureNode,ProtoInstance) and is invalid')
        self.__thicknessTexture = thicknessTexture
    @property # getter - - - - - - - - - -
    def attenuationDistance(self):
        """attenuationDistance - PhysicalMaterial nodes."""
        return self.__attenuationDistance
    @attenuationDistance.setter
    def attenuationDistance(self, attenuationDistance):
        if  attenuationDistance is None:
            attenuationDistance = 1000000.0 # default
        assertValidSFFloat(attenuationDistance)
        assertNonNegative('attenuationDistance', attenuationDistance)
        self.__attenuationDistance = attenuationDistance
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata


class VolumeScatterMaterialExtension(_X3DMaterialExtensionNode):
    """
    VolumeScatterMaterialExtension only works with X_ITE, hopefully other viewers ignore it.
    """
    # immutable constant functions have getter but no setter - - - - - - - - - -
    @classmethod
    def NAME(cls):
        """ Name of this X3D Node class. """
        return 'VolumeScatterMaterialExtension'
    @classmethod
    def SPECIFICATION_URL(cls):
        """ Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. """
        return 'https://create3000.github.io/x_ite/components/x-ite/volumescattermaterialextension/'
    @classmethod
    def TOOLTIP_URL(cls):
        """ X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. """
        return 'https://create3000.github.io/x_ite/components/x-ite/volumescattermaterialextension/'
    @classmethod
    def FIELD_DECLARATIONS(cls):
        """ Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom """
        return [
        ('scatterAnisotropy', 0.0, FieldType.SFFloat, AccessType.inputOutput, 'VolumeScatterMaterialExtension'),
        ('multiscatterColor', (0.0, 0.0, 0.0), FieldType.SFColor, AccessType.inputOutput, 'VolumeScatterMaterialExtension'),
        ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
        ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('id_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
        ('style_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
        scatterAnisotropy=0.0,
        multiscatterColor=(0.0, 0.0, 0.0),
        DEF='',
        USE='',
        IS=None,
        metadata=None,
        class_='',
        id_='',
        style_=''):
        # if _DEBUG: print('...DEBUG... in ConcreteNode Group __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(id_) + ',' + str(style_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, id_, style_, IS, metadata) # fields for _X3DNode only
        self.scatterAnisotropy = scatterAnisotropy
        self.multiscatterColor = multiscatterColor
        self.id_ = id_
        self.style_ = style_
    @property # getter - - - - - - - - - -
    def scatterAnisotropy(self):
        """The scatterAnisotropy defines ior for PhysicalMaterial nodes."""
        return self.__scatterAnisotropy
    @scatterAnisotropy.setter
    def scatterAnisotropy(self, scatterAnisotropy):
        if  scatterAnisotropy is None:
            scatterAnisotropy = 0.0 # default
        elif scatterAnisotropy < -1.0:
            scatterAnisotropy = -1.0
        elif scatterAnisotropy > 1.0:
            scatterAnisotropy = 1.0
        assertValidSFFloat(scatterAnisotropy)
        self.__scatterAnisotropy = scatterAnisotropy
    @property # getter - - - - - - - - - -
    def multiscatterColor(self):
        """Initial starting value for this node."""
        return self.__multiscatterColor
    @multiscatterColor.setter
    def multiscatterColor(self, multiscatterColor):
        if  multiscatterColor is None:
            multiscatterColor = (0.0, 0.0, 0.0)  # default
        assertValidSFColor(multiscatterColor)
        assertZeroToOne('multiscatterColor', multiscatterColor)
        self.__multiscatterColor = multiscatterColor
    @property # getter - - - - - - - - - -
    def id_(self):
        """ id_ attribute is a unique identifier for use within HTML pages. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__id_
    @id_.setter
    def id_(self, id_):
        if  id_ is None:
            id_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(id_)
        self.__id_ = id_
    @property # getter - - - - - - - - - -
    def style_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading style_sheets. Appended underscore to field name to avoid naming collision with Python reserved word. """
        return self.__style_
    @style_.setter
    def style_(self, style_):
        if  style_ is None:
            style_ = SFString.DEFAULT_VALUE()
            # if _DEBUG: print('...DEBUG... set value to .DEFAULT_VALUE()=' + str(SFString.DEFAULT_VALUE()))
        assertValidSFString(style_)
        self.__style_ = style_
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        """ Whether or not this node has any child node or statement """
        return self.IS or self.metadata


class X3DError(Exception):
    """ Base class for all exceptions raised by this module.
        Reference: X3D Scene Access Interface (SAI), 5.3 Error types
        https://www.web3d.org/documents/specifications/19775-2/V3.3/Part02/dataRef.html
    """

class X3DTypeError(X3DError):
    """ Type error for simple fields (SFBool, SFInt32, SFVec3f etc.) or contained nodes (SFNode, MFNode) according to content model."""

class X3DValueError(X3DError):
    """ Value error for a given X3D type."""

###############################################

# Python x3d Package Loading Complete

# TODO how to introspect the version number at run time from the object. Specifically,
# get the magic dictionary __dict__ and then perform standard dictionary lookups on that version key.

print("x3d.py package 4.0.64.5 loaded, have fun with X3D Graphics!", flush=True)

###############################################


def instantiateNodeFromString(x3dType):
    x3dNodeMapping = {
        ####################################### A
        'AcousticProperties':AcousticProperties,
        'Analyser':Analyser,
        'Anchor':Anchor,
        'AnisotropyMaterialExtension':AnisotropyMaterialExtension, # X_ITE - glTF extension
        'Appearance':Appearance,
        'Arc2D':Arc2D,
        'ArcClose2D':ArcClose2D,
        'AudioClip':AudioClip,
        'AudioDestination':AudioDestination,
        ####################################### B
        'Background':Background,
        'BallJoint':BallJoint,
        'Billboard':Billboard,
        'BiquadFilter':BiquadFilter,
        'BlendedVolumeStyle':BlendedVolumeStyle,
        'BooleanFilter':BooleanFilter,
        'BooleanSequencer':BooleanSequencer,
        'BooleanToggle':BooleanToggle,
        'BooleanTrigger':BooleanTrigger,
        'BoundaryEnhancementVolumeStyle':BoundaryEnhancementVolumeStyle,
        'BoundedPhysicsModel':BoundedPhysicsModel,
        'Box':Box,
        'BufferAudioSource':BufferAudioSource,
        ####################################### C
        'CADAssembly':CADAssembly,
        'CADFace':CADFace,
        'CADLayer':CADLayer,
        'CADPart':CADPart,
        'CartoonVolumeStyle':CartoonVolumeStyle,
        'CGEIndexedFaceSet':CGEIndexedFaceSet,# Castle Game Engine - character skeleton custom node
        'CGESkin':CGESkin, #                    Castle Game Engine - character skeleton custom node
        'ChannelMerger':ChannelMerger,
        'ChannelSelector':ChannelSelector,
        'ChannelSplitter':ChannelSplitter,
        'Circle2D':Circle2D,
        'ClipPlane':ClipPlane,
        'CollidableOffset':CollidableOffset,
        'CollidableShape':CollidableShape,
        'Collision':Collision,
        'CollisionCollection':CollisionCollection,
        'CollisionSensor':CollisionSensor,
        'CollisionSpace':CollisionSpace,
        'Color':Color,
        'ColorChaser':ColorChaser,
        'ColorDamper':ColorDamper,
        'ColorInterpolator':ColorInterpolator,
        'ColorRGBA':ColorRGBA,
        'ComposedCubeMapTexture':ComposedCubeMapTexture,
        'ComposedShader':ComposedShader,
        'ComposedTexture3D':ComposedTexture3D,
        'ComposedVolumeStyle':ComposedVolumeStyle,
        'Cone':Cone,
        'ConeEmitter':ConeEmitter,
        'Contact':Contact,
        'Contour2D':Contour2D,
        'ContourPolyline2D':ContourPolyline2D,
        'Convolver':Convolver,
        'Coordinate':Coordinate,
        'CoordinateChaser':CoordinateChaser,
        'CoordinateDamper':CoordinateDamper,
        'CoordinateDouble':CoordinateDouble,
        'CoordinateInterpolator':CoordinateInterpolator,
        'CoordinateInterpolator2D':CoordinateInterpolator2D,
        'Cylinder':Cylinder,
        'CylinderSensor':CylinderSensor,
        ####################################### D
        'Delay':Delay,
        'DirectionalLight':DirectionalLight,
        'DISEntityManager':DISEntityManager,
        'DISEntityTypeMapping':DISEntityTypeMapping,
        'Disk2D':Disk2D,
        'DoubleAxisHingeJoint':DoubleAxisHingeJoint,
        'DynamicsCompressor':DynamicsCompressor,
        ####################################### E
        'EaseInEaseOut':EaseInEaseOut,
        'EdgeEnhancementVolumeStyle':EdgeEnhancementVolumeStyle,
        'ElevationGrid':ElevationGrid,
        'EmissiveStrengthMaterialExtension':EmissiveStrengthMaterialExtension, # X_ITE - glTF extension
        'EnvironmentLight':EnvironmentLight, # X3D 4.1 specification
        'EspduTransform':EspduTransform,
        'ExplosionEmitter':ExplosionEmitter,
        'Extrusion':Extrusion,
        ####################################### F
        'FillProperties':FillProperties,
        'FloatVertexAttribute':FloatVertexAttribute,
        'Fog':Fog,
        'FogCoordinate':FogCoordinate,
        'FontStyle':FontStyle,
        'ForcePhysicsModel':ForcePhysicsModel,
        ####################################### G
        'Gain':Gain,
        'GeneratedCubeMapTexture':GeneratedCubeMapTexture,
        'GeoCoordinate':GeoCoordinate,
        'GeoElevationGrid':GeoElevationGrid,
        'GeoLocation':GeoLocation,
        'GeoLOD':GeoLOD,
        'GeoMetadata':GeoMetadata,
        'GeoOrigin':GeoOrigin,
        'GeoPositionInterpolator':GeoPositionInterpolator,
        'GeoProximitySensor':GeoProximitySensor,
        'GeoTouchSensor':GeoTouchSensor,
        'GeoTransform':GeoTransform,
        'GeoViewpoint':GeoViewpoint,
        'Group':Group,
        ####################################### H
        'HAnimDisplacer':HAnimDisplacer,
        'HAnimHumanoid':HAnimHumanoid,
        'HAnimJoint':HAnimJoint,
        'HAnimMotion':HAnimMotion,
        'HAnimSegment':HAnimSegment,
        'HAnimSite':HAnimSite,
        ####################################### I
        'ImageCubeMapTexture':ImageCubeMapTexture,
        'ImageTexture':ImageTexture,
        'ImageTexture3D':ImageTexture3D,
        'IndexedFaceSet':IndexedFaceSet,
        'IndexedLineSet':IndexedLineSet,
        'IndexedQuadSet':IndexedQuadSet,
        'IndexedTriangleFanSet':IndexedTriangleFanSet,
        'IndexedTriangleSet':IndexedTriangleSet,
        'IndexedTriangleStripSet':IndexedTriangleStripSet,
        'Inline':Inline,
        'IntegerSequencer':IntegerSequencer,
        'IntegerTrigger':IntegerTrigger,
        'IORMaterialExtension':IORMaterialExtension, # X_ITE - glTF extension
        'IsoSurfaceVolumeData':IsoSurfaceVolumeData,
        ####################################### K
        'KeySensor':KeySensor,
        ####################################### L
        'Layer':Layer,
        'LayerSet':LayerSet,
        'Layout':Layout,
        'LayoutGroup':LayoutGroup,
        'LayoutLayer':LayoutLayer,
        'LinePickSensor':LinePickSensor,
        'LineProperties':LineProperties,
        'LineSet':LineSet,
        'ListenerPointSource':ListenerPointSource,
        'LoadSensor':LoadSensor,
        'LocalFog':LocalFog,
        'LOD':LOD,
        ####################################### M
        'Material':Material,
        'Matrix3VertexAttribute':Matrix3VertexAttribute,
        'Matrix4VertexAttribute':Matrix4VertexAttribute,
        'MetadataBoolean':MetadataBoolean,
        'MetadataDouble':MetadataDouble,
        'MetadataFloat':MetadataFloat,
        'MetadataInteger':MetadataInteger,
        'MetadataSet':MetadataSet,
        'MetadataString':MetadataString,
        'MicrophoneSource':MicrophoneSource,
        'MotorJoint':MotorJoint,
        'MovieTexture':MovieTexture,
        'MultiTexture':MultiTexture,
        'MultiTextureCoordinate':MultiTextureCoordinate,
        'MultiTextureTransform':MultiTextureTransform,
        ####################################### N
        'NavigationInfo':NavigationInfo,
        'Normal':Normal,
        'NormalInterpolator':NormalInterpolator,
        'NurbsCurve':NurbsCurve,
        'NurbsCurve2D':NurbsCurve2D,
        'NurbsOrientationInterpolator':NurbsOrientationInterpolator,
        'NurbsPatchSurface':NurbsPatchSurface,
        'NurbsPositionInterpolator':NurbsPositionInterpolator,
        'NurbsSet':NurbsSet,
        'NurbsSurfaceInterpolator':NurbsSurfaceInterpolator,
        'NurbsSweptSurface':NurbsSweptSurface,
        'NurbsSwungSurface':NurbsSwungSurface,
        'NurbsTextureCoordinate':NurbsTextureCoordinate,
        'NurbsTrimmedSurface':NurbsTrimmedSurface,
        ####################################### O
        'OpacityMapVolumeStyle':OpacityMapVolumeStyle,
        'OrientationChaser':OrientationChaser,
        'OrientationDamper':OrientationDamper,
        'OrientationInterpolator':OrientationInterpolator,
        'OrthoViewpoint':OrthoViewpoint,
        'OscillatorSource':OscillatorSource,
        ####################################### P
        'PackagedShader':PackagedShader,
        'ParticleSystem':ParticleSystem,
        'PeriodicWave':PeriodicWave,
        'PhysicalMaterial':PhysicalMaterial,
        'PickableGroup':PickableGroup,
        'PixelTexture':PixelTexture,
        'PixelTexture3D':PixelTexture3D,
        'PlaneSensor':PlaneSensor,
        'PointEmitter':PointEmitter,
        'PointLight':PointLight,
        'PointPickSensor':PointPickSensor,
        'PointProperties':PointProperties,
        'PointSet':PointSet,
        'Polyline2D':Polyline2D,
        'PolylineEmitter':PolylineEmitter,
        'Polypoint2D':Polypoint2D,
        'PositionChaser':PositionChaser,
        'PositionChaser2D':PositionChaser2D,
        'PositionDamper':PositionDamper,
        'PositionDamper2D':PositionDamper2D,
        'PositionInterpolator':PositionInterpolator,
        'PositionInterpolator2D':PositionInterpolator2D,
        'PrimitivePickSensor':PrimitivePickSensor,
        'ProgramShader':ProgramShader,
        'ProjectionVolumeStyle':ProjectionVolumeStyle,
        'ProximitySensor':ProximitySensor,
        ####################################### Q
        'QuadSet':QuadSet,
        ####################################### R
        'ReceiverPdu':ReceiverPdu,
        'Rectangle2D':Rectangle2D,
        'RigidBody':RigidBody,
        'RigidBodyCollection':RigidBodyCollection,
        'ROUTE':ROUTE,
        ####################################### S
        'ScalarChaser':ScalarChaser,
        'ScalarDamper':ScalarDamper,
        'ScalarInterpolator':ScalarInterpolator,
        'ScreenFontStyle':ScreenFontStyle,
        'ScreenGroup':ScreenGroup,
        'Script':Script,
        'SegmentedVolumeData':SegmentedVolumeData,
        'ShadedVolumeStyle':ShadedVolumeStyle,
        'ShaderPart':ShaderPart,
        'ShaderProgram':ShaderProgram,
        'Shape':Shape,
        'SignalPdu':SignalPdu,
        'SilhouetteEnhancementVolumeStyle':SilhouetteEnhancementVolumeStyle,
        'SingleAxisHingeJoint':SingleAxisHingeJoint,
        'SliderJoint':SliderJoint,
        'Sound':Sound,
        'SpatialSound':SpatialSound,
        'Sphere':Sphere,
        'SphereSensor':SphereSensor,
        'SplinePositionInterpolator':SplinePositionInterpolator,
        'SplinePositionInterpolator2D':SplinePositionInterpolator2D,
        'SplineScalarInterpolator':SplineScalarInterpolator,
        'SpotLight':SpotLight,
        'StaticGroup':StaticGroup,
        'StreamAudioDestination':StreamAudioDestination,
        'StreamAudioSource':StreamAudioSource,
        'StringSensor':StringSensor,
        'SurfaceEmitter':SurfaceEmitter,
        'Switch':Switch,
        ####################################### T
        'TexCoordChaser2D':TexCoordChaser2D,
        'TexCoordDamper2D':TexCoordDamper2D,
        'Text':Text,
        'TextureBackground':TextureBackground,
        'TextureCoordinate':TextureCoordinate,
        'TextureCoordinate3D':TextureCoordinate3D,
        'TextureCoordinate4D':TextureCoordinate4D,
        'TextureCoordinateGenerator':TextureCoordinateGenerator,
        'TextureProjector':TextureProjector,
        'TextureProjectorParallel':TextureProjectorParallel,
        'TextureProperties':TextureProperties,
        'TextureTransform':TextureTransform,
        'TextureTransform3D':TextureTransform3D,
        'TextureTransformMatrix3D':TextureTransformMatrix3D,
        'TimeSensor':TimeSensor,
        'TimeTrigger':TimeTrigger,
        'ToneMappedVolumeStyle':ToneMappedVolumeStyle,
        'TouchSensor':TouchSensor,
        'Transform':Transform,
        'TransformSensor':TransformSensor,
        'TransmitterPdu':TransmitterPdu,
        'TriangleFanSet':TriangleFanSet,
        'TriangleSet':TriangleSet,
        'TriangleSet2D':TriangleSet2D,
        'TriangleStripSet':TriangleStripSet,
        'TwoSidedMaterial':TwoSidedMaterial,
        ####################################### U
        'UniversalJoint':UniversalJoint,
        'UnlitMaterial':UnlitMaterial,
        ####################################### V
        'Viewpoint':Viewpoint,
        'ViewpointGroup':ViewpointGroup,
        'Viewport':Viewport,
        'VisibilitySensor':VisibilitySensor,
        'VolumeData':VolumeData,
        'VolumeEmitter':VolumeEmitter,
        'VolumePickSensor':VolumePickSensor,
        ####################################### W
        'WaveShaper':WaveShaper,
        'WindPhysicsModel':WindPhysicsModel,
        'WorldInfo':WorldInfo
    }

    return x3dNodeMapping[x3dType]()
